!function (f) { typeof module != 'undefined' && typeof exports == 'object' ? module.exports = f() : typeof define != 'undefined' && define.amd ? define(['fflate', f]) : (typeof self != 'undefined' ? self : this).fflate = f() }(function () { var _e = {}; "use strict"; var t = (typeof module != 'undefined' && typeof exports == 'object' ? function (_f) { "use strict"; var e, t = ";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global"; try { e = require("worker_threads").Worker } catch (e) { } exports.default = e ? function (r, n, o, a, s) { var u = !1, i = new e(r + t, { eval: !0 }).on("error", (function (e) { return s(e, null) })).on("message", (function (e) { return s(null, e) })).on("exit", (function (e) { e && !u && s(Error("exited with code " + e), null) })); return i.postMessage(o, a), i.terminate = function () { return u = !0, e.prototype.terminate.call(i) }, i } : function (e, t, r, n, o) { setImmediate((function () { return o(Error("async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)"), null) })); var a = function () { }; return { terminate: a, postMessage: a } }; return _f } : function (_f) { "use strict"; var e = {}; _f.default = function (r, t, s, a, n) { var o = new Worker(e[t] || (e[t] = URL.createObjectURL(new Blob([r + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'], { type: "text/javascript" })))); return o.onmessage = function (e) { var r = e.data, t = r.$e$; if (t) { var s = Error(t[0]); s.code = t[1], s.stack = t[2], n(s, null) } else n(null, r) }, o.postMessage(s, a), o }; return _f })({}), n = Uint8Array, r = Uint16Array, e = Uint32Array, i = new n([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new n([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new n([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), s = function (t, n) { for (var i = new r(31), o = 0; o < 31; ++o)i[o] = n += 1 << t[o - 1]; var a = new e(i[30]); for (o = 1; o < 30; ++o)for (var s = i[o]; s < i[o + 1]; ++s)a[s] = s - i[o] << 5 | o; return [i, a] }, u = s(i, 2), f = u[0], h = u[1]; f[28] = 258, h[258] = 28; for (var c = s(o, 0), l = c[0], p = c[1], v = new r(32768), d = 0; d < 32768; ++d) { var g = (43690 & d) >>> 1 | (21845 & d) << 1; v[d] = ((65280 & (g = (61680 & (g = (52428 & g) >>> 2 | (13107 & g) << 2)) >>> 4 | (3855 & g) << 4)) >>> 8 | (255 & g) << 8) >>> 1 } var y = function (t, n, e) { for (var i = t.length, o = 0, a = new r(n); o < i; ++o)++a[t[o] - 1]; var s, u = new r(n); for (o = 0; o < n; ++o)u[o] = u[o - 1] + a[o - 1] << 1; if (e) { s = new r(1 << n); var f = 15 - n; for (o = 0; o < i; ++o)if (t[o]) for (var h = o << 4 | t[o], c = n - t[o], l = u[t[o] - 1]++ << c, p = l | (1 << c) - 1; l <= p; ++l)s[v[l] >>> f] = h } else for (s = new r(i), o = 0; o < i; ++o)t[o] && (s[o] = v[u[t[o] - 1]++] >>> 15 - t[o]); return s }, m = new n(288); for (d = 0; d < 144; ++d)m[d] = 8; for (d = 144; d < 256; ++d)m[d] = 9; for (d = 256; d < 280; ++d)m[d] = 7; for (d = 280; d < 288; ++d)m[d] = 8; var w = new n(32); for (d = 0; d < 32; ++d)w[d] = 5; var x = y(m, 9, 0), b = y(m, 9, 1), z = y(w, 5, 0), k = y(w, 5, 1), M = function (t) { for (var n = t[0], r = 1; r < t.length; ++r)t[r] > n && (n = t[r]); return n }, S = function (t, n, r) { var e = n / 8 | 0; return (t[e] | t[e + 1] << 8) >> (7 & n) & r }, A = function (t, n) { var r = n / 8 | 0; return (t[r] | t[r + 1] << 8 | t[r + 2] << 16) >> (7 & n) }, T = function (t) { return (t + 7) / 8 | 0 }, D = function (t, i, o) { (null == i || i < 0) && (i = 0), (null == o || o > t.length) && (o = t.length); var a = new (t instanceof r ? r : t instanceof e ? e : n)(o - i); return a.set(t.subarray(i, o)), a }; _e.FlateErrorCode = { UnexpectedEOF: 0, InvalidBlockType: 1, InvalidLengthLiteral: 2, InvalidDistance: 3, StreamFinished: 4, NoStreamHandler: 5, InvalidHeader: 6, NoCallback: 7, InvalidUTF8: 8, ExtraFieldTooLong: 9, InvalidDate: 10, FilenameTooLong: 11, StreamFinishing: 12, InvalidZipData: 13, UnknownCompressionMethod: 14 }; var C = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], U = function (t, n, r) { var e = Error(n || C[t]); if (e.code = t, Error.captureStackTrace && Error.captureStackTrace(e, U), !r) throw e; return e }, I = function (t, r, e) { var s = t.length; if (!s || e && e.f && !e.l) return r || new n(0); var u = !r || e, h = !e || e.i; e || (e = {}), r || (r = new n(3 * s)); var c = function (t) { var e = r.length; if (t > e) { var i = new n(Math.max(2 * e, t)); i.set(r), r = i } }, p = e.f || 0, v = e.p || 0, d = e.b || 0, g = e.l, m = e.d, w = e.m, x = e.n, z = 8 * s; do { if (!g) { p = S(t, v, 1); var C = S(t, v + 1, 3); if (v += 3, !C) { var I = t[(P = T(v) + 4) - 4] | t[P - 3] << 8, F = P + I; if (F > s) { h && U(0); break } u && c(d + I), r.set(t.subarray(P, F), d), e.b = d += I, e.p = v = 8 * F, e.f = p; continue } if (1 == C) g = b, m = k, w = 9, x = 5; else if (2 == C) { var E = S(t, v, 31) + 257, Z = S(t, v + 10, 15) + 4, O = E + S(t, v + 5, 31) + 1; v += 14; for (var G = new n(O), L = new n(19), q = 0; q < Z; ++q)L[a[q]] = S(t, v + 3 * q, 7); v += 3 * Z; var H = M(L), j = (1 << H) - 1, N = y(L, H, 1); for (q = 0; q < O;) { var P, B = N[S(t, v, j)]; if (v += 15 & B, (P = B >>> 4) < 16) G[q++] = P; else { var Y = 0, J = 0; for (16 == P ? (J = 3 + S(t, v, 3), v += 2, Y = G[q - 1]) : 17 == P ? (J = 3 + S(t, v, 7), v += 3) : 18 == P && (J = 11 + S(t, v, 127), v += 7); J--;)G[q++] = Y } } var K = G.subarray(0, E), Q = G.subarray(E); w = M(K), x = M(Q), g = y(K, w, 1), m = y(Q, x, 1) } else U(1); if (v > z) { h && U(0); break } } u && c(d + 131072); for (var R = (1 << w) - 1, V = (1 << x) - 1, W = v; ; W = v) { var X = (Y = g[A(t, v) & R]) >>> 4; if ((v += 15 & Y) > z) { h && U(0); break } if (Y || U(2), X < 256) r[d++] = X; else { if (256 == X) { W = v, g = null; break } var $ = X - 254; X > 264 && ($ = S(t, v, (1 << (nt = i[q = X - 257])) - 1) + f[q], v += nt); var _ = m[A(t, v) & V], tt = _ >>> 4; if (_ || U(3), v += 15 & _, Q = l[tt], tt > 3) { var nt = o[tt]; Q += A(t, v) & (1 << nt) - 1, v += nt } if (v > z) { h && U(0); break } u && c(d + 131072); for (var rt = d + $; d < rt; d += 4)r[d] = r[d - Q], r[d + 1] = r[d + 1 - Q], r[d + 2] = r[d + 2 - Q], r[d + 3] = r[d + 3 - Q]; d = rt } } e.l = g, e.p = W, e.b = d, e.f = p, g && (p = 1, e.m = w, e.d = m, e.n = x) } while (!p); return d == r.length ? r : D(r, 0, d) }, F = function (t, n, r) { var e = n / 8 | 0; t[e] |= r <<= 7 & n, t[e + 1] |= r >>> 8 }, E = function (t, n, r) { var e = n / 8 | 0; t[e] |= r <<= 7 & n, t[e + 1] |= r >>> 8, t[e + 2] |= r >>> 16 }, Z = function (t, e) { for (var i = [], o = 0; o < t.length; ++o)t[o] && i.push({ s: o, f: t[o] }); var a = i.length, s = i.slice(); if (!a) return [N, 0]; if (1 == a) { var u = new n(i[0].s + 1); return u[i[0].s] = 1, [u, 1] } i.sort((function (t, n) { return t.f - n.f })), i.push({ s: -1, f: 25001 }); var f = i[0], h = i[1], c = 0, l = 1, p = 2; for (i[0] = { s: -1, f: f.f + h.f, l: f, r: h }; l != a - 1;)f = i[i[c].f < i[p].f ? c++ : p++], h = i[c != l && i[c].f < i[p].f ? c++ : p++], i[l++] = { s: -1, f: f.f + h.f, l: f, r: h }; var v = s[0].s; for (o = 1; o < a; ++o)s[o].s > v && (v = s[o].s); var d = new r(v + 1), g = O(i[l - 1], d, 0); if (g > e) { o = 0; var y = 0, m = g - e, w = 1 << m; for (s.sort((function (t, n) { return d[n.s] - d[t.s] || t.f - n.f })); o < a; ++o) { var x = s[o].s; if (!(d[x] > e)) break; y += w - (1 << g - d[x]), d[x] = e } for (y >>>= m; y > 0;) { var b = s[o].s; d[b] < e ? y -= 1 << e - d[b]++ - 1 : ++o } for (; o >= 0 && y; --o) { var z = s[o].s; d[z] == e && (--d[z], ++y) } g = e } return [new n(d), g] }, O = function (t, n, r) { return -1 == t.s ? Math.max(O(t.l, n, r + 1), O(t.r, n, r + 1)) : n[t.s] = r }, G = function (t) { for (var n = t.length; n && !t[--n];); for (var e = new r(++n), i = 0, o = t[0], a = 1, s = function (t) { e[i++] = t }, u = 1; u <= n; ++u)if (t[u] == o && u != n) ++a; else { if (!o && a > 2) { for (; a > 138; a -= 138)s(32754); a > 2 && (s(a > 10 ? a - 11 << 5 | 28690 : a - 3 << 5 | 12305), a = 0) } else if (a > 3) { for (s(o), --a; a > 6; a -= 6)s(8304); a > 2 && (s(a - 3 << 5 | 8208), a = 0) } for (; a--;)s(o); a = 1, o = t[u] } return [e.subarray(0, i), n] }, L = function (t, n) { for (var r = 0, e = 0; e < n.length; ++e)r += t[e] * n[e]; return r }, q = function (t, n, r) { var e = r.length, i = T(n + 2); t[i] = 255 & e, t[i + 1] = e >>> 8, t[i + 2] = 255 ^ t[i], t[i + 3] = 255 ^ t[i + 1]; for (var o = 0; o < e; ++o)t[i + o + 4] = r[o]; return 8 * (i + 4 + e) }, H = function (t, n, e, s, u, f, h, c, l, p, v) { F(n, v++, e), ++u[256]; for (var d = Z(u, 15), g = d[0], b = d[1], k = Z(f, 15), M = k[0], S = k[1], A = G(g), T = A[0], D = A[1], C = G(M), U = C[0], I = C[1], O = new r(19), H = 0; H < T.length; ++H)O[31 & T[H]]++; for (H = 0; H < U.length; ++H)O[31 & U[H]]++; for (var j = Z(O, 7), N = j[0], P = j[1], B = 19; B > 4 && !N[a[B - 1]]; --B); var Y, J, K, Q, R = p + 5 << 3, V = L(u, m) + L(f, w) + h, W = L(u, g) + L(f, M) + h + 14 + 3 * B + L(O, N) + (2 * O[16] + 3 * O[17] + 7 * O[18]); if (R <= V && R <= W) return q(n, v, t.subarray(l, l + p)); if (F(n, v, 1 + (W < V)), v += 2, W < V) { Y = y(g, b, 0), J = g, K = y(M, S, 0), Q = M; var X = y(N, P, 0); for (F(n, v, D - 257), F(n, v + 5, I - 1), F(n, v + 10, B - 4), v += 14, H = 0; H < B; ++H)F(n, v + 3 * H, N[a[H]]); v += 3 * B; for (var $ = [T, U], _ = 0; _ < 2; ++_) { var tt = $[_]; for (H = 0; H < tt.length; ++H)F(n, v, X[nt = 31 & tt[H]]), v += N[nt], nt > 15 && (F(n, v, tt[H] >>> 5 & 127), v += tt[H] >>> 12) } } else Y = x, J = m, K = z, Q = w; for (H = 0; H < c; ++H)if (s[H] > 255) { var nt; E(n, v, Y[257 + (nt = s[H] >>> 18 & 31)]), v += J[nt + 257], nt > 7 && (F(n, v, s[H] >>> 23 & 31), v += i[nt]); var rt = 31 & s[H]; E(n, v, K[rt]), v += Q[rt], rt > 3 && (E(n, v, s[H] >>> 5 & 8191), v += o[rt]) } else E(n, v, Y[s[H]]), v += J[s[H]]; return E(n, v, Y[256]), v + J[256] }, j = new e([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), N = new n(0), P = function (t, a, s, u, f, c) { var l = t.length, v = new n(u + l + 5 * (1 + Math.ceil(l / 7e3)) + f), d = v.subarray(u, v.length - f), g = 0; if (!a || l < 8) for (var y = 0; y <= l; y += 65535) { var m = y + 65535; m < l ? g = q(d, g, t.subarray(y, m)) : (d[y] = c, g = q(d, g, t.subarray(y, l))) } else { for (var w = j[a - 1], x = w >>> 13, b = 8191 & w, z = (1 << s) - 1, k = new r(32768), M = new r(z + 1), S = Math.ceil(s / 3), A = 2 * S, C = function (n) { return (t[n] ^ t[n + 1] << S ^ t[n + 2] << A) & z }, U = new e(25e3), I = new r(288), F = new r(32), E = 0, Z = 0, O = (y = 0, 0), G = 0, L = 0; y < l; ++y) { var P = C(y), B = 32767 & y, Y = M[P]; if (k[B] = Y, M[P] = B, G <= y) { var J = l - y; if ((E > 7e3 || O > 24576) && J > 423) { g = H(t, d, 0, U, I, F, Z, O, L, y - L, g), O = E = Z = 0, L = y; for (var K = 0; K < 286; ++K)I[K] = 0; for (K = 0; K < 30; ++K)F[K] = 0 } var Q = 2, R = 0, V = b, W = B - Y & 32767; if (J > 2 && P == C(y - W)) for (var X = Math.min(x, J) - 1, $ = Math.min(32767, y), _ = Math.min(258, J); W <= $ && --V && B != Y;) { if (t[y + Q] == t[y + Q - W]) { for (var tt = 0; tt < _ && t[y + tt] == t[y + tt - W]; ++tt); if (tt > Q) { if (Q = tt, R = W, tt > X) break; var nt = Math.min(W, tt - 2), rt = 0; for (K = 0; K < nt; ++K) { var et = y - W + K + 32768 & 32767, it = et - k[et] + 32768 & 32767; it > rt && (rt = it, Y = et) } } } W += (B = Y) - (Y = k[B]) + 32768 & 32767 } if (R) { U[O++] = 268435456 | h[Q] << 18 | p[R]; var ot = 31 & h[Q], at = 31 & p[R]; Z += i[ot] + o[at], ++I[257 + ot], ++F[at], G = y + Q, ++E } else U[O++] = t[y], ++I[t[y]] } } g = H(t, d, c, U, I, F, Z, O, L, y - L, g), !c && 7 & g && (g = q(d, g + 1, N)) } return D(v, 0, u + T(g) + f) }, B = function () { for (var t = new Int32Array(256), n = 0; n < 256; ++n) { for (var r = n, e = 9; --e;)r = (1 & r && -306674912) ^ r >>> 1; t[n] = r } return t }(), Y = function () { var t = -1; return { p: function (n) { for (var r = t, e = 0; e < n.length; ++e)r = B[255 & r ^ n[e]] ^ r >>> 8; t = r }, d: function () { return ~t } } }, J = function () { var t = 1, n = 0; return { p: function (r) { for (var e = t, i = n, o = 0 | r.length, a = 0; a != o;) { for (var s = Math.min(a + 2655, o); a < s; ++a)i += e += r[a]; e = (65535 & e) + 15 * (e >> 16), i = (65535 & i) + 15 * (i >> 16) } t = e, n = i }, d: function () { return (255 & (t %= 65521)) << 24 | t >>> 8 << 16 | (255 & (n %= 65521)) << 8 | n >>> 8 } } }, K = function (t, n, r, e, i) { return P(t, null == n.level ? 6 : n.level, null == n.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + n.mem, r, e, !i) }, Q = function (t, n) { var r = {}; for (var e in t) r[e] = t[e]; for (var e in n) r[e] = n[e]; return r }, R = function (t, n, r) { for (var e = t(), i = "" + t, o = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), a = 0; a < e.length; ++a) { var s = e[a], u = o[a]; if ("function" == typeof s) { n += ";" + u + "="; var f = "" + s; if (s.prototype) if (-1 != f.indexOf("[native code]")) { var h = f.indexOf(" ", 8) + 1; n += f.slice(h, f.indexOf("(", h)) } else for (var c in n += f, s.prototype) n += ";" + u + ".prototype." + c + "=" + s.prototype[c]; else n += f } else r[u] = s } return [n, r] }, V = [], W = function (t) { var i = []; for (var o in t) (t[o] instanceof n || t[o] instanceof r || t[o] instanceof e) && i.push((t[o] = new t[o].constructor(t[o])).buffer); return i }, X = function (n, r, e, i) { var o; if (!V[e]) { for (var a = "", s = {}, u = n.length - 1, f = 0; f < u; ++f)a = (o = R(n[f], a, s))[0], s = o[1]; V[e] = R(n[u], a, s) } var h = Q({}, V[e][1]); return t.default(V[e][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + r + "}", e, h, W(h), i) }, $ = function () { return [n, r, e, i, o, a, f, l, b, k, v, C, y, M, S, A, T, D, U, I, Tt, it, ot] }, _ = function () { return [n, r, e, i, o, a, h, p, x, m, z, w, v, j, N, y, F, E, Z, O, G, L, q, H, T, D, P, K, kt, it] }, tt = function () { return [pt, gt, lt, Y, B] }, nt = function () { return [vt, dt] }, rt = function () { return [yt, lt, J] }, et = function () { return [mt] }, it = function (t) { return postMessage(t, [t.buffer]) }, ot = function (t) { return t && t.size && new n(t.size) }, at = function (t, n, r, e, i, o) { var a = X(r, e, i, (function (t, n) { a.terminate(), o(t, n) })); return a.postMessage([t, n], n.consume ? [t.buffer] : []), function () { a.terminate() } }, st = function (t) { return t.ondata = function (t, n) { return postMessage([t, n], [t.buffer]) }, function (n) { return t.push(n.data[0], n.data[1]) } }, ut = function (t, n, r, e, i) { var o, a = X(t, e, i, (function (t, r) { t ? (a.terminate(), n.ondata.call(n, t)) : (r[1] && a.terminate(), n.ondata.call(n, t, r[0], r[1])) })); a.postMessage(r), n.push = function (t, r) { n.ondata || U(5), o && n.ondata(U(4, 0, 1), null, !!r), a.postMessage([t, o = r], [t.buffer]) }, n.terminate = function () { a.terminate() } }, ft = function (t, n) { return t[n] | t[n + 1] << 8 }, ht = function (t, n) { return (t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24) >>> 0 }, ct = function (t, n) { return ht(t, n) + 4294967296 * ht(t, n + 4) }, lt = function (t, n, r) { for (; r; ++n)t[n] = r, r >>>= 8 }, pt = function (t, n) { var r = n.filename; if (t[0] = 31, t[1] = 139, t[2] = 8, t[8] = n.level < 2 ? 4 : 9 == n.level ? 2 : 0, t[9] = 3, 0 != n.mtime && lt(t, 4, Math.floor(new Date(n.mtime || Date.now()) / 1e3)), r) { t[3] = 8; for (var e = 0; e <= r.length; ++e)t[e + 10] = r.charCodeAt(e) } }, vt = function (t) { 31 == t[0] && 139 == t[1] && 8 == t[2] || U(6, "invalid gzip data"); var n = t[3], r = 10; 4 & n && (r += t[10] | 2 + (t[11] << 8)); for (var e = (n >> 3 & 1) + (n >> 4 & 1); e > 0; e -= !t[r++]); return r + (2 & n) }, dt = function (t) { var n = t.length; return (t[n - 4] | t[n - 3] << 8 | t[n - 2] << 16 | t[n - 1] << 24) >>> 0 }, gt = function (t) { return 10 + (t.filename && t.filename.length + 1 || 0) }, yt = function (t, n) { var r = n.level, e = 0 == r ? 0 : r < 6 ? 1 : 9 == r ? 3 : 2; t[0] = 120, t[1] = e << 6 | (e ? 32 - 2 * e : 1) }, mt = function (t) { (8 != (15 & t[0]) || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31) && U(6, "invalid zlib data"), 32 & t[1] && U(6, "invalid zlib data: preset dictionaries not supported") }; function wt(t, n) { return n || "function" != typeof t || (n = t, t = {}), this.ondata = n, t } var xt = function () { function t(t, n) { n || "function" != typeof t || (n = t, t = {}), this.ondata = n, this.o = t || {} } return t.prototype.p = function (t, n) { this.ondata(K(t, this.o, 0, 0, !n), n) }, t.prototype.push = function (t, n) { this.ondata || U(5), this.d && U(4), this.d = n, this.p(t, n || !1) }, t }(); _e.Deflate = xt; var bt = function () { return function (t, n) { ut([_, function () { return [st, xt] }], this, wt.call(this, t, n), (function (t) { var n = new xt(t.data); onmessage = st(n) }), 6) } }(); function zt(t, n, r) { return r || (r = n, n = {}), "function" != typeof r && U(7), at(t, n, [_], (function (t) { return it(kt(t.data[0], t.data[1])) }), 0, r) } function kt(t, n) { return K(t, n || {}, 0, 0) } _e.AsyncDeflate = bt, _e.deflate = zt, _e.deflateSync = kt; var Mt = function () { function t(t) { this.s = {}, this.p = new n(0), this.ondata = t } return t.prototype.e = function (t) { this.ondata || U(5), this.d && U(4); var r = this.p.length, e = new n(r + t.length); e.set(this.p), e.set(t, r), this.p = e }, t.prototype.c = function (t) { this.d = this.s.i = t || !1; var n = this.s.b, r = I(this.p, this.o, this.s); this.ondata(D(r, n, this.s.b), this.d), this.o = D(r, this.s.b - 32768), this.s.b = this.o.length, this.p = D(this.p, this.s.p / 8 | 0), this.s.p &= 7 }, t.prototype.push = function (t, n) { this.e(t), this.c(n) }, t }(); _e.Inflate = Mt; var St = function () { return function (t) { this.ondata = t, ut([$, function () { return [st, Mt] }], this, 0, (function () { var t = new Mt; onmessage = st(t) }), 7) } }(); function At(t, n, r) { return r || (r = n, n = {}), "function" != typeof r && U(7), at(t, n, [$], (function (t) { return it(Tt(t.data[0], ot(t.data[1]))) }), 1, r) } function Tt(t, n) { return I(t, n) } _e.AsyncInflate = St, _e.inflate = At, _e.inflateSync = Tt; var Dt = function () { function t(t, n) { this.c = Y(), this.l = 0, this.v = 1, xt.call(this, t, n) } return t.prototype.push = function (t, n) { xt.prototype.push.call(this, t, n) }, t.prototype.p = function (t, n) { this.c.p(t), this.l += t.length; var r = K(t, this.o, this.v && gt(this.o), n && 8, !n); this.v && (pt(r, this.o), this.v = 0), n && (lt(r, r.length - 8, this.c.d()), lt(r, r.length - 4, this.l)), this.ondata(r, n) }, t }(); _e.Gzip = Dt, _e.Compress = Dt; var Ct = function () { return function (t, n) { ut([_, tt, function () { return [st, xt, Dt] }], this, wt.call(this, t, n), (function (t) { var n = new Dt(t.data); onmessage = st(n) }), 8) } }(); function Ut(t, n, r) { return r || (r = n, n = {}), "function" != typeof r && U(7), at(t, n, [_, tt, function () { return [It] }], (function (t) { return it(It(t.data[0], t.data[1])) }), 2, r) } function It(t, n) { n || (n = {}); var r = Y(), e = t.length; r.p(t); var i = K(t, n, gt(n), 8), o = i.length; return pt(i, n), lt(i, o - 8, r.d()), lt(i, o - 4, e), i } _e.AsyncGzip = Ct, _e.AsyncCompress = Ct, _e.gzip = Ut, _e.compress = Ut, _e.gzipSync = It, _e.compressSync = It; var Ft = function () { function t(t) { this.v = 1, Mt.call(this, t) } return t.prototype.push = function (t, n) { if (Mt.prototype.e.call(this, t), this.v) { var r = this.p.length > 3 ? vt(this.p) : 4; if (r >= this.p.length && !n) return; this.p = this.p.subarray(r), this.v = 0 } n && (this.p.length < 8 && U(6, "invalid gzip data"), this.p = this.p.subarray(0, -8)), Mt.prototype.c.call(this, n) }, t }(); _e.Gunzip = Ft; var Et = function () { return function (t) { this.ondata = t, ut([$, nt, function () { return [st, Mt, Ft] }], this, 0, (function () { var t = new Ft; onmessage = st(t) }), 9) } }(); function Zt(t, n, r) { return r || (r = n, n = {}), "function" != typeof r && U(7), at(t, n, [$, nt, function () { return [Ot] }], (function (t) { return it(Ot(t.data[0])) }), 3, r) } function Ot(t, r) { return I(t.subarray(vt(t), -8), r || new n(dt(t))) } _e.AsyncGunzip = Et, _e.gunzip = Zt, _e.gunzipSync = Ot; var Gt = function () { function t(t, n) { this.c = J(), this.v = 1, xt.call(this, t, n) } return t.prototype.push = function (t, n) { xt.prototype.push.call(this, t, n) }, t.prototype.p = function (t, n) { this.c.p(t); var r = K(t, this.o, this.v && 2, n && 4, !n); this.v && (yt(r, this.o), this.v = 0), n && lt(r, r.length - 4, this.c.d()), this.ondata(r, n) }, t }(); _e.Zlib = Gt; var Lt = function () { return function (t, n) { ut([_, rt, function () { return [st, xt, Gt] }], this, wt.call(this, t, n), (function (t) { var n = new Gt(t.data); onmessage = st(n) }), 10) } }(); function qt(t, n, r) { return r || (r = n, n = {}), "function" != typeof r && U(7), at(t, n, [_, rt, function () { return [Ht] }], (function (t) { return it(Ht(t.data[0], t.data[1])) }), 4, r) } function Ht(t, n) { n || (n = {}); var r = J(); r.p(t); var e = K(t, n, 2, 4); return yt(e, n), lt(e, e.length - 4, r.d()), e } _e.AsyncZlib = Lt, _e.zlib = qt, _e.zlibSync = Ht; var jt = function () { function t(t) { this.v = 1, Mt.call(this, t) } return t.prototype.push = function (t, n) { if (Mt.prototype.e.call(this, t), this.v) { if (this.p.length < 2 && !n) return; this.p = this.p.subarray(2), this.v = 0 } n && (this.p.length < 4 && U(6, "invalid zlib data"), this.p = this.p.subarray(0, -4)), Mt.prototype.c.call(this, n) }, t }(); _e.Unzlib = jt; var Nt = function () { return function (t) { this.ondata = t, ut([$, et, function () { return [st, Mt, jt] }], this, 0, (function () { var t = new jt; onmessage = st(t) }), 11) } }(); function Pt(t, n, r) { return r || (r = n, n = {}), "function" != typeof r && U(7), at(t, n, [$, et, function () { return [Bt] }], (function (t) { return it(Bt(t.data[0], ot(t.data[1]))) }), 5, r) } function Bt(t, n) { return I((mt(t), t.subarray(2, -4)), n) } _e.AsyncUnzlib = Nt, _e.unzlib = Pt, _e.unzlibSync = Bt; var Yt = function () { function t(t) { this.G = Ft, this.I = Mt, this.Z = jt, this.ondata = t } return t.prototype.push = function (t, r) { if (this.ondata || U(5), this.s) this.s.push(t, r); else { if (this.p && this.p.length) { var e = new n(this.p.length + t.length); e.set(this.p), e.set(t, this.p.length) } else this.p = t; if (this.p.length > 2) { var i = this, o = function () { i.ondata.apply(i, arguments) }; this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(o) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(o) : new this.Z(o), this.s.push(this.p, r), this.p = null } } }, t }(); _e.Decompress = Yt; var Jt = function () { function t(t) { this.G = Et, this.I = St, this.Z = Nt, this.ondata = t } return t.prototype.push = function (t, n) { Yt.prototype.push.call(this, t, n) }, t }(); function Kt(t, n, r) { return r || (r = n, n = {}), "function" != typeof r && U(7), 31 == t[0] && 139 == t[1] && 8 == t[2] ? Zt(t, n, r) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? At(t, n, r) : Pt(t, n, r) } function Qt(t, n) { return 31 == t[0] && 139 == t[1] && 8 == t[2] ? Ot(t, n) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? Tt(t, n) : Bt(t, n) } _e.AsyncDecompress = Jt, _e.decompress = Kt, _e.decompressSync = Qt; var Rt = function (t, r, e, i) { for (var o in t) { var a = t[o], s = r + o; a instanceof n ? e[s] = [a, i] : Array.isArray(a) ? e[s] = [a[0], Q(i, a[1])] : Rt(a, s + "/", e, i) } }, Vt = "undefined" != typeof TextEncoder && new TextEncoder, Wt = "undefined" != typeof TextDecoder && new TextDecoder, Xt = 0; try { Wt.decode(N, { stream: !0 }), Xt = 1 } catch (t) { } var $t = function (t) { for (var n = "", r = 0; ;) { var e = t[r++], i = (e > 127) + (e > 223) + (e > 239); if (r + i > t.length) return [n, D(t, r - 1)]; i ? 3 == i ? (e = ((15 & e) << 18 | (63 & t[r++]) << 12 | (63 & t[r++]) << 6 | 63 & t[r++]) - 65536, n += String.fromCharCode(55296 | e >> 10, 56320 | 1023 & e)) : n += String.fromCharCode(1 & i ? (31 & e) << 6 | 63 & t[r++] : (15 & e) << 12 | (63 & t[r++]) << 6 | 63 & t[r++]) : n += String.fromCharCode(e) } }, _t = function () { function t(t) { this.ondata = t, Xt ? this.t = new TextDecoder : this.p = N } return t.prototype.push = function (t, r) { if (this.ondata || U(5), r = !!r, this.t) return this.ondata(this.t.decode(t, { stream: !0 }), r), void (r && (this.t.decode().length && U(8), this.t = null)); this.p || U(4); var e = new n(this.p.length + t.length); e.set(this.p), e.set(t, this.p.length); var i = $t(e), o = i[0], a = i[1]; r ? (a.length && U(8), this.p = null) : this.p = a, this.ondata(o, r) }, t }(); _e.DecodeUTF8 = _t; var tn = function () { function t(t) { this.ondata = t } return t.prototype.push = function (t, n) { this.ondata || U(5), this.d && U(4), this.ondata(nn(t), this.d = n || !1) }, t }(); function nn(t, r) { if (r) { for (var e = new n(t.length), i = 0; i < t.length; ++i)e[i] = t.charCodeAt(i); return e } if (Vt) return Vt.encode(t); var o = t.length, a = new n(t.length + (t.length >> 1)), s = 0, u = function (t) { a[s++] = t }; for (i = 0; i < o; ++i) { if (s + 5 > a.length) { var f = new n(s + 8 + (o - i << 1)); f.set(a), a = f } var h = t.charCodeAt(i); h < 128 || r ? u(h) : h < 2048 ? (u(192 | h >> 6), u(128 | 63 & h)) : h > 55295 && h < 57344 ? (u(240 | (h = 65536 + (1047552 & h) | 1023 & t.charCodeAt(++i)) >> 18), u(128 | h >> 12 & 63), u(128 | h >> 6 & 63), u(128 | 63 & h)) : (u(224 | h >> 12), u(128 | h >> 6 & 63), u(128 | 63 & h)) } return D(a, 0, s) } function rn(t, n) { if (n) { for (var r = "", e = 0; e < t.length; e += 16384)r += String.fromCharCode.apply(null, t.subarray(e, e + 16384)); return r } if (Wt) return Wt.decode(t); var i = $t(t), o = i[0]; return i[1].length && U(8), o } _e.EncodeUTF8 = tn, _e.strToU8 = nn, _e.strFromU8 = rn; var en = function (t) { return 1 == t ? 3 : t < 6 ? 2 : 9 == t ? 1 : 0 }, on = function (t, n) { return n + 30 + ft(t, n + 26) + ft(t, n + 28) }, an = function (t, n, r) { var e = ft(t, n + 28), i = rn(t.subarray(n + 46, n + 46 + e), !(2048 & ft(t, n + 8))), o = n + 46 + e, a = ht(t, n + 20), s = r && 4294967295 == a ? sn(t, o) : [a, ht(t, n + 24), ht(t, n + 42)], u = s[0], f = s[1], h = s[2]; return [ft(t, n + 10), u, f, i, o + ft(t, n + 30) + ft(t, n + 32), h] }, sn = function (t, n) { for (; 1 != ft(t, n); n += 4 + ft(t, n + 2)); return [ct(t, n + 12), ct(t, n + 4), ct(t, n + 20)] }, un = function (t) { var n = 0; if (t) for (var r in t) { var e = t[r].length; e > 65535 && U(9), n += e + 4 } return n }, fn = function (t, n, r, e, i, o, a, s) { var u = e.length, f = r.extra, h = s && s.length, c = un(f); lt(t, n, null != a ? 33639248 : 67324752), n += 4, null != a && (t[n++] = 20, t[n++] = r.os), t[n] = 20, n += 2, t[n++] = r.flag << 1 | (null == o && 8), t[n++] = i && 8, t[n++] = 255 & r.compression, t[n++] = r.compression >> 8; var l = new Date(null == r.mtime ? Date.now() : r.mtime), p = l.getFullYear() - 1980; if ((p < 0 || p > 119) && U(10), lt(t, n, p << 25 | l.getMonth() + 1 << 21 | l.getDate() << 16 | l.getHours() << 11 | l.getMinutes() << 5 | l.getSeconds() >>> 1), n += 4, null != o && (lt(t, n, r.crc), lt(t, n + 4, o), lt(t, n + 8, r.size)), lt(t, n + 12, u), lt(t, n + 14, c), n += 16, null != a && (lt(t, n, h), lt(t, n + 6, r.attrs), lt(t, n + 10, a), n += 14), t.set(e, n), n += u, c) for (var v in f) { var d = f[v], g = d.length; lt(t, n, +v), lt(t, n + 2, g), t.set(d, n + 4), n += 4 + g } return h && (t.set(s, n), n += h), n }, hn = function (t, n, r, e, i) { lt(t, n, 101010256), lt(t, n + 8, r), lt(t, n + 10, r), lt(t, n + 12, e), lt(t, n + 16, i) }, cn = function () { function t(t) { this.filename = t, this.c = Y(), this.size = 0, this.compression = 0 } return t.prototype.process = function (t, n) { this.ondata(null, t, n) }, t.prototype.push = function (t, n) { this.ondata || U(5), this.c.p(t), this.size += t.length, n && (this.crc = this.c.d()), this.process(t, n || !1) }, t }(); _e.ZipPassThrough = cn; var ln = function () { function t(t, n) { var r = this; n || (n = {}), cn.call(this, t), this.d = new xt(n, (function (t, n) { r.ondata(null, t, n) })), this.compression = 8, this.flag = en(n.level) } return t.prototype.process = function (t, n) { try { this.d.push(t, n) } catch (t) { this.ondata(t, null, n) } }, t.prototype.push = function (t, n) { cn.prototype.push.call(this, t, n) }, t }(); _e.ZipDeflate = ln; var pn = function () { function t(t, n) { var r = this; n || (n = {}), cn.call(this, t), this.d = new bt(n, (function (t, n, e) { r.ondata(t, n, e) })), this.compression = 8, this.flag = en(n.level), this.terminate = this.d.terminate } return t.prototype.process = function (t, n) { this.d.push(t, n) }, t.prototype.push = function (t, n) { cn.prototype.push.call(this, t, n) }, t }(); _e.AsyncZipDeflate = pn; var vn = function () { function t(t) { this.ondata = t, this.u = [], this.d = 1 } return t.prototype.add = function (t) { var r = this; if (this.ondata || U(5), 2 & this.d) this.ondata(U(4 + 8 * (1 & this.d), 0, 1), null, !1); else { var e = nn(t.filename), i = e.length, o = t.comment, a = o && nn(o), s = i != t.filename.length || a && o.length != a.length, u = i + un(t.extra) + 30; i > 65535 && this.ondata(U(11, 0, 1), null, !1); var f = new n(u); fn(f, 0, t, e, s); var h = [f], c = function () { for (var t = 0, n = h; t < n.length; t++)r.ondata(null, n[t], !1); h = [] }, l = this.d; this.d = 0; var p = this.u.length, v = Q(t, { f: e, u: s, o: a, t: function () { t.terminate && t.terminate() }, r: function () { if (c(), l) { var t = r.u[p + 1]; t ? t.r() : r.d = 1 } l = 1 } }), d = 0; t.ondata = function (e, i, o) { if (e) r.ondata(e, i, o), r.terminate(); else if (d += i.length, h.push(i), o) { var a = new n(16); lt(a, 0, 134695760), lt(a, 4, t.crc), lt(a, 8, d), lt(a, 12, t.size), h.push(a), v.c = d, v.b = u + d + 16, v.crc = t.crc, v.size = t.size, l && v.r(), l = 1 } else l && c() }, this.u.push(v) } }, t.prototype.end = function () { var t = this; 2 & this.d ? this.ondata(U(4 + 8 * (1 & this.d), 0, 1), null, !0) : (this.d ? this.e() : this.u.push({ r: function () { 1 & t.d && (t.u.splice(-1, 1), t.e()) }, t: function () { } }), this.d = 3) }, t.prototype.e = function () { for (var t = 0, r = 0, e = 0, i = 0, o = this.u; i < o.length; i++)e += 46 + (f = o[i]).f.length + un(f.extra) + (f.o ? f.o.length : 0); for (var a = new n(e + 22), s = 0, u = this.u; s < u.length; s++) { var f; fn(a, t, f = u[s], f.f, f.u, f.c, r, f.o), t += 46 + f.f.length + un(f.extra) + (f.o ? f.o.length : 0), r += f.b } hn(a, t, this.u.length, e, r), this.ondata(null, a, !0), this.d = 2 }, t.prototype.terminate = function () { for (var t = 0, n = this.u; t < n.length; t++)n[t].t(); this.d = 2 }, t }(); function dn(t, r, e) { e || (e = r, r = {}), "function" != typeof e && U(7); var i = {}; Rt(t, "", i, r); var o = Object.keys(i), a = o.length, s = 0, u = 0, f = a, h = Array(a), c = [], l = function () { for (var t = 0; t < c.length; ++t)c[t]() }, p = function (t, n) { bn((function () { e(t, n) })) }; bn((function () { p = e })); var v = function () { var t = new n(u + 22), r = s, e = u - s; u = 0; for (var i = 0; i < f; ++i) { var o = h[i]; try { var a = o.c.length; fn(t, u, o, o.f, o.u, a); var c = 30 + o.f.length + un(o.extra), l = u + c; t.set(o.c, l), fn(t, s, o, o.f, o.u, a, u, o.m), s += 16 + c + (o.m ? o.m.length : 0), u = l + a } catch (t) { return p(t, null) } } hn(t, s, h.length, e, r), p(null, t) }; a || v(); for (var d = function (t) { var n = o[t], r = i[n], e = r[0], f = r[1], d = Y(), g = e.length; d.p(e); var y = nn(n), m = y.length, w = f.comment, x = w && nn(w), b = x && x.length, z = un(f.extra), k = 0 == f.level ? 0 : 8, M = function (r, e) { if (r) l(), p(r, null); else { var i = e.length; h[t] = Q(f, { size: g, crc: d.d(), c: e, f: y, m: x, u: m != n.length || x && w.length != b, compression: k }), s += 30 + m + z + i, u += 76 + 2 * (m + z) + (b || 0) + i, --a || v() } }; if (m > 65535 && M(U(11, 0, 1), null), k) if (g < 16e4) try { M(null, kt(e, f)) } catch (t) { M(t, null) } else c.push(zt(e, f, M)); else M(null, e) }, g = 0; g < f; ++g)d(g); return l } function gn(t, r) { r || (r = {}); var e = {}, i = []; Rt(t, "", e, r); var o = 0, a = 0; for (var s in e) { var u = e[s], f = u[0], h = u[1], c = 0 == h.level ? 0 : 8, l = (M = nn(s)).length, p = h.comment, v = p && nn(p), d = v && v.length, g = un(h.extra); l > 65535 && U(11); var y = c ? kt(f, h) : f, m = y.length, w = Y(); w.p(f), i.push(Q(h, { size: f.length, crc: w.d(), c: y, f: M, m: v, u: l != s.length || v && p.length != d, o: o, compression: c })), o += 30 + l + g + m, a += 76 + 2 * (l + g) + (d || 0) + m } for (var x = new n(a + 22), b = o, z = a - o, k = 0; k < i.length; ++k) { var M; fn(x, (M = i[k]).o, M, M.f, M.u, M.c.length); var S = 30 + M.f.length + un(M.extra); x.set(M.c, M.o + S), fn(x, o, M, M.f, M.u, M.c.length, M.o, M.m), o += 16 + S + (M.m ? M.m.length : 0) } return hn(x, o, i.length, z, b), x } _e.Zip = vn, _e.zip = dn, _e.zipSync = gn; var yn = function () { function t() { } return t.prototype.push = function (t, n) { this.ondata(null, t, n) }, t.compression = 0, t }(); _e.UnzipPassThrough = yn; var mn = function () { function t() { var t = this; this.i = new Mt((function (n, r) { t.ondata(null, n, r) })) } return t.prototype.push = function (t, n) { try { this.i.push(t, n) } catch (t) { this.ondata(t, null, n) } }, t.compression = 8, t }(); _e.UnzipInflate = mn; var wn = function () { function t(t, n) { var r = this; n < 32e4 ? this.i = new Mt((function (t, n) { r.ondata(null, t, n) })) : (this.i = new St((function (t, n, e) { r.ondata(t, n, e) })), this.terminate = this.i.terminate) } return t.prototype.push = function (t, n) { this.i.terminate && (t = D(t, 0)), this.i.push(t, n) }, t.compression = 8, t }(); _e.AsyncUnzipInflate = wn; var xn = function () { function t(t) { this.onfile = t, this.k = [], this.o = { 0: yn }, this.p = N } return t.prototype.push = function (t, r) { var e = this; if (this.onfile || U(5), this.p || U(4), this.c > 0) { var i = Math.min(this.c, t.length), o = t.subarray(0, i); if (this.c -= i, this.d ? this.d.push(o, !this.c) : this.k[0].push(o), (t = t.subarray(i)).length) return this.push(t, r) } else { var a = 0, s = 0, u = void 0, f = void 0; this.p.length ? t.length ? ((f = new n(this.p.length + t.length)).set(this.p), f.set(t, this.p.length)) : f = this.p : f = t; for (var h = f.length, c = this.c, l = c && this.d, p = function () { var t, n = ht(f, s); if (67324752 == n) { a = 1, u = s, v.d = null, v.c = 0; var r = ft(f, s + 6), i = ft(f, s + 8), o = 2048 & r, l = 8 & r, p = ft(f, s + 26), d = ft(f, s + 28); if (h > s + 30 + p + d) { var g = []; v.k.unshift(g), a = 2; var y, m = ht(f, s + 18), w = ht(f, s + 22), x = rn(f.subarray(s + 30, s += 30 + p), !o); 4294967295 == m ? (t = l ? [-2] : sn(f, s), m = t[0], w = t[1]) : l && (m = -1), s += d, v.c = m; var b = { name: x, compression: i, start: function () { if (b.ondata || U(5), m) { var t = e.o[i]; t || b.ondata(U(14, "unknown compression type " + i, 1), null, !1), (y = m < 0 ? new t(x) : new t(x, m, w)).ondata = function (t, n, r) { b.ondata(t, n, r) }; for (var n = 0, r = g; n < r.length; n++)y.push(r[n], !1); e.k[0] == g && e.c ? e.d = y : y.push(N, !0) } else b.ondata(null, N, !0) }, terminate: function () { y && y.terminate && y.terminate() } }; m >= 0 && (b.size = m, b.originalSize = w), v.onfile(b) } return "break" } if (c) { if (134695760 == n) return u = s += 12 + (-2 == c && 8), a = 3, v.c = 0, "break"; if (33639248 == n) return u = s -= 4, a = 3, v.c = 0, "break" } }, v = this; s < h - 4 && "break" !== p(); ++s); if (this.p = N, c < 0) { var d = f.subarray(0, a ? u - 12 - (-2 == c && 8) - (134695760 == ht(f, u - 16) && 4) : s); l ? l.push(d, !!a) : this.k[+(2 == a)].push(d) } if (2 & a) return this.push(f.subarray(s), r); this.p = f.subarray(s) } r && (this.c && U(13), this.p = null) }, t.prototype.register = function (t) { this.o[t.compression] = t }, t }(); _e.Unzip = xn; var bn = "function" == typeof queueMicrotask ? queueMicrotask : "function" == typeof setTimeout ? setTimeout : function (t) { t() }; function zn(t, r, e) { e || (e = r, r = {}), "function" != typeof e && U(7); var i = [], o = function () { for (var t = 0; t < i.length; ++t)i[t]() }, a = {}, s = function (t, n) { bn((function () { e(t, n) })) }; bn((function () { s = e })); for (var u = t.length - 22; 101010256 != ht(t, u); --u)if (!u || t.length - u > 65558) return s(U(13, 0, 1), null), o; var f = ft(t, u + 8); if (f) { var h = f, c = ht(t, u + 16), l = 4294967295 == c; if (l) { if (u = ht(t, u - 12), 101075792 != ht(t, u)) return s(U(13, 0, 1), null), o; h = f = ht(t, u + 32), c = ht(t, u + 48) } for (var p = r && r.filter, v = function (r) { var e = an(t, c, l), u = e[0], h = e[1], v = e[2], d = e[3], g = e[4], y = on(t, e[5]); c = g; var m = function (t, n) { t ? (o(), s(t, null)) : (n && (a[d] = n), --f || s(null, a)) }; if (!p || p({ name: d, size: h, originalSize: v, compression: u })) if (u) if (8 == u) { var w = t.subarray(y, y + h); if (h < 32e4) try { m(null, Tt(w, new n(v))) } catch (t) { m(t, null) } else i.push(At(w, { size: v }, m)) } else m(U(14, "unknown compression type " + u, 1), null); else m(null, D(t, y, y + h)); else m(null, null) }, d = 0; d < h; ++d)v() } else s(null, {}); return o } function kn(t, r) { for (var e = {}, i = t.length - 22; 101010256 != ht(t, i); --i)(!i || t.length - i > 65558) && U(13); var o = ft(t, i + 8); if (!o) return {}; var a = ht(t, i + 16), s = 4294967295 == a; s && (i = ht(t, i - 12), 101075792 != ht(t, i) && U(13), o = ht(t, i + 32), a = ht(t, i + 48)); for (var u = r && r.filter, f = 0; f < o; ++f) { var h = an(t, a, s), c = h[0], l = h[1], p = h[2], v = h[3], d = h[4], g = on(t, h[5]); a = d, u && !u({ name: v, size: l, originalSize: p, compression: c }) || (c ? 8 == c ? e[v] = Tt(t.subarray(g, g + l), new n(p)) : U(14, "unknown compression type " + c) : e[v] = D(t, g, g + l)) } return e } _e.unzip = zn, _e.unzipSync = kn; return _e })
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).THREE = {}) }(this, function (e) { "use strict"; const t = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, n = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, r = 0, i = 1, s = 2, a = 1, o = 2, l = 3, c = 0, h = 1, u = 2, d = 1, p = 0, m = 1, f = 2, g = 3, v = 4, y = 5, x = 100, _ = 101, b = 102, w = 103, M = 104, T = 200, E = 201, S = 202, A = 203, R = 204, L = 205, C = 206, P = 207, I = 208, N = 209, D = 210, F = 0, O = 1, U = 2, B = 3, H = 4, z = 5, G = 6, k = 7, V = 0, W = 1, j = 2, X = 0, q = 1, Y = 2, Z = 3, J = 4, K = 5, Q = 300, $ = 301, ee = 302, te = 303, ne = 304, re = 306, ie = 307, se = 1e3, ae = 1001, oe = 1002, le = 1003, ce = 1004, he = 1005, ue = 1006, de = 1007, pe = 1008, me = 1009, fe = 1010, ge = 1011, ve = 1012, ye = 1013, xe = 1014, _e = 1015, be = 1016, we = 1017, Me = 1018, Te = 1019, Ee = 1020, Se = 1021, Ae = 1022, Re = 1023, Le = 1024, Ce = 1025, Pe = Re, Ie = 1026, Ne = 1027, De = 1028, Fe = 1029, Oe = 1030, Ue = 1031, Be = 1032, He = 1033, ze = 33776, Ge = 33777, ke = 33778, Ve = 33779, We = 35840, je = 35841, Xe = 35842, qe = 35843, Ye = 36196, Ze = 37492, Je = 37496, Ke = 37808, Qe = 37809, $e = 37810, et = 37811, tt = 37812, nt = 37813, rt = 37814, it = 37815, st = 37816, at = 37817, ot = 37818, lt = 37819, ct = 37820, ht = 37821, ut = 36492, dt = 37840, pt = 37841, mt = 37842, ft = 37843, gt = 37844, vt = 37845, yt = 37846, xt = 37847, _t = 37848, bt = 37849, wt = 37850, Mt = 37851, Tt = 37852, Et = 37853, St = 2200, At = 2201, Rt = 2202, Lt = 2300, Ct = 2301, Pt = 2302, It = 2400, Nt = 2401, Dt = 2402, Ft = 2500, Ot = 2501, Ut = 1, Bt = 2, Ht = 3e3, zt = 3001, Gt = 3007, kt = 3002, Vt = 3003, Wt = 3004, jt = 3005, Xt = 3006, qt = 3200, Yt = 3201, Zt = 0, Jt = 1, Kt = 7680, Qt = 519, $t = 35044, en = 35048, tn = "300 es"; class nn { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) } removeEventListener(e, t) { if (void 0 === this._listeners) return; const n = this._listeners[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } dispatchEvent(e) { if (void 0 === this._listeners) return; const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const n = t.slice(0); for (let t = 0, r = n.length; t < r; t++)n[t].call(this, e); e.target = null } } } const rn = []; for (let e = 0; e < 256; e++)rn[e] = (e < 16 ? "0" : "") + e.toString(16); let sn = 1234567; const an = Math.PI / 180, on = 180 / Math.PI; function ln() { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (rn[255 & e] + rn[e >> 8 & 255] + rn[e >> 16 & 255] + rn[e >> 24 & 255] + "-" + rn[255 & t] + rn[t >> 8 & 255] + "-" + rn[t >> 16 & 15 | 64] + rn[t >> 24 & 255] + "-" + rn[63 & n | 128] + rn[n >> 8 & 255] + "-" + rn[n >> 16 & 255] + rn[n >> 24 & 255] + rn[255 & r] + rn[r >> 8 & 255] + rn[r >> 16 & 255] + rn[r >> 24 & 255]).toUpperCase() } function cn(e, t, n) { return Math.max(t, Math.min(n, e)) } function hn(e, t) { return (e % t + t) % t } function un(e, t, n) { return (1 - n) * e + n * t } function dn(e) { return 0 == (e & e - 1) && 0 !== e } function pn(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) } function mn(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } var fn = Object.freeze({ __proto__: null, DEG2RAD: an, RAD2DEG: on, generateUUID: ln, clamp: cn, euclideanModulo: hn, mapLinear: function (e, t, n, r, i) { return r + (e - t) * (i - r) / (n - t) }, inverseLerp: function (e, t, n) { return e !== t ? (n - e) / (t - e) : 0 }, lerp: un, damp: function (e, t, n, r) { return un(e, t, 1 - Math.exp(-n * r)) }, pingpong: function (e, t = 1) { return t - Math.abs(hn(e, 2 * t) - t) }, smoothstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { return void 0 !== e && (sn = e % 2147483647), ((sn = 16807 * sn % 2147483647) - 1) / 2147483646 }, degToRad: function (e) { return e * an }, radToDeg: function (e) { return e * on }, isPowerOfTwo: dn, ceilPowerOfTwo: pn, floorPowerOfTwo: mn, setQuaternionFromProperEuler: function (e, t, n, r, i) { const s = Math.cos, a = Math.sin, o = s(n / 2), l = a(n / 2), c = s((t + r) / 2), h = a((t + r) / 2), u = s((t - r) / 2), d = a((t - r) / 2), p = s((r - t) / 2), m = a((r - t) / 2); switch (i) { case "XYX": e.set(o * h, l * u, l * d, o * c); break; case "YZY": e.set(l * d, o * h, l * u, o * c); break; case "ZXZ": e.set(l * u, l * d, o * h, o * c); break; case "XZX": e.set(o * h, l * m, l * p, o * c); break; case "YXY": e.set(l * p, o * h, l * m, o * c); break; case "ZYZ": e.set(l * m, l * p, o * h, o * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } }); class gn { constructor(e = 0, t = 0) { this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, n = this.y, r = e.elements; return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y; return t * t + n * n } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const n = Math.cos(t), r = Math.sin(t), i = this.x - e.x, s = this.y - e.y; return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } gn.prototype.isVector2 = !0; class vn { constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, r, i, s, a, o, l) { const c = this.elements; return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = i, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } extractBasis(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, r = t.elements, i = this.elements, s = n[0], a = n[3], o = n[6], l = n[1], c = n[4], h = n[7], u = n[2], d = n[5], p = n[8], m = r[0], f = r[3], g = r[6], v = r[1], y = r[4], x = r[7], _ = r[2], b = r[5], w = r[8]; return i[0] = s * m + a * v + o * _, i[3] = s * f + a * y + o * b, i[6] = s * g + a * x + o * w, i[1] = l * m + c * v + h * _, i[4] = l * f + c * y + h * b, i[7] = l * g + c * x + h * w, i[2] = u * m + d * v + p * _, i[5] = u * f + d * y + p * b, i[8] = u * g + d * x + p * w, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8]; return t * s * c - t * a * l - n * i * c + n * a * o + r * i * l - r * s * o } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8], h = c * s - a * l, u = a * o - c * i, d = l * i - s * o, p = t * h + n * u + r * d; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const m = 1 / p; return e[0] = h * m, e[1] = (r * l - c * n) * m, e[2] = (a * n - r * s) * m, e[3] = u * m, e[4] = (c * t - r * o) * m, e[5] = (r * i - a * t) * m, e[6] = d * m, e[7] = (n * o - l * t) * m, e[8] = (s * t - n * i) * m, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, n, r, i, s, a) { const o = Math.cos(i), l = Math.sin(i); return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -r * l, r * o, -r * (-l * s + o * a) + a + t, 0, 0, 1), this } scale(e, t) { const n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this } rotate(e) { const t = Math.cos(e), n = Math.sin(e), r = this.elements, i = r[0], s = r[3], a = r[6], o = r[1], l = r[4], c = r[7]; return r[0] = t * i + n * o, r[3] = t * s + n * l, r[6] = t * a + n * c, r[1] = -n * i + t * o, r[4] = -n * s + t * l, r[7] = -n * a + t * c, this } translate(e, t) { const n = this.elements; return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 9; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } let yn; vn.prototype.isMatrix3 = !0; class xn { static getDataURL(e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === yn && (yn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), yn.width = e.width, yn.height = e.height; const n = yn.getContext("2d"); e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = yn } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } } let _n = 0; class bn extends nn { constructor(e = bn.DEFAULT_IMAGE, t = bn.DEFAULT_MAPPING, n = ae, r = ae, i = ue, s = pe, a = Re, o = me, l = 1, c = Ht) { super(), Object.defineProperty(this, "id", { value: _n++ }), this.uuid = ln(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new gn(0, 0), this.repeat = new gn(1, 1), this.center = new gn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new vn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1 } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const r = this.image; if (void 0 === r.uuid && (r.uuid = ln()), !t && void 0 === e.images[r.uuid]) { let t; if (Array.isArray(r)) { t = []; for (let e = 0, n = r.length; e < n; e++)r[e].isDataTexture ? t.push(En(r[e].image)) : t.push(En(r[e])) } else t = En(r); e.images[r.uuid] = { uuid: r.uuid, url: t } } n.image = r.uuid } return t || (e.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== Q) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case se: e.x = e.x - Math.floor(e.x); break; case ae: e.x = e.x < 0 ? 0 : 1; break; case oe: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case se: e.y = e.y - Math.floor(e.y); break; case ae: e.y = e.y < 0 ? 0 : 1; break; case oe: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && this.version++ } } const wn = { type: "change" }, Mn = { type: "start" }, Tn = { type: "end" }; function En(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? xn.getDataURL(e) : e.data ? { data: Array.prototype.slice.call(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } bn.DEFAULT_IMAGE = void 0, bn.DEFAULT_MAPPING = Q, bn.prototype.isTexture = !0; class Sn { constructor(e = 0, t = 0, n = 0, r = 1) { this.x = e, this.y = t, this.z = n, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, n, r) { return this.x = e, this.y = t, this.z = n, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, n = this.y, r = this.z, i = this.w, s = e.elements; return this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, n, r, i; const s = e.elements, a = s[0], o = s[4], l = s[8], c = s[1], h = s[5], u = s[9], d = s[2], p = s[6], m = s[10]; if (Math.abs(o - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) { if (Math.abs(o + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + h + m - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (a + 1) / 2, s = (h + 1) / 2, f = (m + 1) / 2, g = (o + c) / 4, v = (l + d) / 4, y = (u + p) / 4; return e > s && e > f ? e < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = g / (n = Math.sqrt(e)), i = v / n) : s > f ? s < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = g / (r = Math.sqrt(s)), i = y / r) : f < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = v / (i = Math.sqrt(f)), r = y / i), this.set(n, r, i, t), this } let f = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - o) * (c - o)); return Math.abs(f) < .001 && (f = 1), this.x = (p - u) / f, this.y = (l - d) / f, this.z = (c - o) / f, this.w = Math.acos((a + h + m - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } Sn.prototype.isVector4 = !0; class An extends nn { constructor(e, t, n = {}) { super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Sn(0, 0, e, t), this.scissorTest = !1, this.viewport = new Sn(0, 0, e, t), this.texture = new bn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = { width: e, height: t, depth: 1 }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ue, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } setTexture(e) { e.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = e } setSize(e, t, n = 1) { this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } An.prototype.isWebGLRenderTarget = !0; class Rn extends An { constructor(e, t, n) { super(e, t); const r = this.texture; this.texture = []; for (let e = 0; e < n; e++)this.texture[e] = r.clone() } setSize(e, t, n = 1) { if (this.width !== e || this.height !== t || this.depth !== n) { this.width = e, this.height = t, this.depth = n; for (let r = 0, i = this.texture.length; r < i; r++)this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n; this.dispose() } return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0; for (let t = 0, n = e.texture.length; t < n; t++)this.texture[t] = e.texture[t].clone(); return this } } Rn.prototype.isWebGLMultipleRenderTargets = !0; class Ln extends An { constructor(e, t, n) { super(e, t, n), this.samples = 4 } copy(e) { return super.copy.call(this, e), this.samples = e.samples, this } } Ln.prototype.isWebGLMultisampleRenderTarget = !0; class Cn { constructor(e = 0, t = 0, n = 0, r = 1) { this._x = e, this._y = t, this._z = n, this._w = r } static slerp(e, t, n, r) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, r) } static slerpFlat(e, t, n, r, i, s, a) { let o = n[r + 0], l = n[r + 1], c = n[r + 2], h = n[r + 3]; const u = i[s + 0], d = i[s + 1], p = i[s + 2], m = i[s + 3]; if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = h); if (1 === a) return e[t + 0] = u, e[t + 1] = d, e[t + 2] = p, void (e[t + 3] = m); if (h !== m || o !== u || l !== d || c !== p) { let e = 1 - a; const t = o * u + l * d + c * p + h * m, n = t >= 0 ? 1 : -1, r = 1 - t * t; if (r > Number.EPSILON) { const i = Math.sqrt(r), s = Math.atan2(i, t * n); e = Math.sin(e * s) / i, a = Math.sin(a * s) / i } const i = a * n; if (o = o * e + u * i, l = l * e + d * i, c = c * e + p * i, h = h * e + m * i, e === 1 - a) { const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h); o *= e, l *= e, c *= e, h *= e } } e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h } static multiplyQuaternionsFlat(e, t, n, r, i, s) { const a = n[r], o = n[r + 1], l = n[r + 2], c = n[r + 3], h = i[s], u = i[s + 1], d = i[s + 2], p = i[s + 3]; return e[t] = a * p + c * h + o * d - l * u, e[t + 1] = o * p + c * u + l * h - a * d, e[t + 2] = l * p + c * d + a * u - o * h, e[t + 3] = c * p - a * h - o * u - l * d, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = e._x, r = e._y, i = e._z, s = e._order, a = Math.cos, o = Math.sin, l = a(n / 2), c = a(r / 2), h = a(i / 2), u = o(n / 2), d = o(r / 2), p = o(i / 2); switch (s) { case "XYZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "YXZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "ZXY": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "ZYX": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "YZX": this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p; break; case "XZY": this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return !1 !== t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const n = t / 2, r = Math.sin(n); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, n = t[0], r = t[4], i = t[8], s = t[1], a = t[5], o = t[9], l = t[2], c = t[6], h = t[10], u = n + a + h; if (u > 0) { const e = .5 / Math.sqrt(u + 1); this._w = .25 / e, this._x = (c - o) * e, this._y = (i - l) * e, this._z = (s - r) * e } else if (n > a && n > h) { const e = 2 * Math.sqrt(1 + n - a - h); this._w = (c - o) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (i + l) / e } else if (a > h) { const e = 2 * Math.sqrt(1 + a - n - h); this._w = (i - l) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (o + c) / e } else { const e = 2 * Math.sqrt(1 + h - n - a); this._w = (s - r) / e, this._x = (i + l) / e, this._y = (o + c) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let n = e.dot(t) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(cn(this.dot(e), -1, 1))) } rotateTowards(e, t) { const n = this.angleTo(e); if (0 === n) return this; const r = Math.min(1, t / n); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const n = e._x, r = e._y, i = e._z, s = e._w, a = t._x, o = t._y, l = t._z, c = t._w; return this._x = n * c + s * a + r * l - i * o, this._y = r * c + s * o + i * a - n * l, this._z = i * c + s * l + n * o - r * a, this._w = s * c - n * a - r * o - i * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); const n = this._x, r = this._y, i = this._z, s = this._w; let a = s * e._w + n * e._x + r * e._y + i * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this; const o = 1 - a * a; if (o <= Number.EPSILON) { const e = 1 - t; return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this._onChangeCallback(), this } const l = Math.sqrt(o), c = Math.atan2(l, a), h = Math.sin((1 - t) * c) / l, u = Math.sin(t * c) / l; return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = r * h + this._y * u, this._z = i * h + this._z * u, this._onChangeCallback(), this } slerpQuaternions(e, t, n) { this.copy(e).slerp(t, n) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } Cn.prototype.isQuaternion = !0; class Pn { constructor(e = 0, t = 0, n = 0) { this.x = e, this.y = t, this.z = n } set(e, t, n) { return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Nn.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(Nn.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, n = this.y, r = this.z, i = e.elements, s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]); return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s, this } applyQuaternion(e) { const t = this.x, n = this.y, r = this.z, i = e.x, s = e.y, a = e.z, o = e.w, l = o * t + s * r - a * n, c = o * n + a * t - i * r, h = o * r + i * n - s * t, u = -i * t - s * n - a * r; return this.x = l * o + u * -i + c * -a - h * -s, this.y = c * o + u * -s + h * -i - l * -a, this.z = h * o + u * -a + l * -s - c * -i, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } cross(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) } crossVectors(e, t) { const n = e.x, r = e.y, i = e.z, s = t.x, a = t.y, o = t.z; return this.x = r * o - i * a, this.y = i * s - n * o, this.z = n * a - r * s, this } projectOnVector(e) { const t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); const n = e.dot(this) / t; return this.copy(e).multiplyScalar(n) } projectOnPlane(e) { return In.copy(this).projectOnVector(e), this.sub(In) } reflect(e) { return this.sub(In.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(cn(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z; return t * t + n * n + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, n) { const r = Math.sin(t) * e; return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } Pn.prototype.isVector3 = !0; const In = new Pn, Nn = new Cn; class Dn { constructor(e = new Pn(1 / 0, 1 / 0, 1 / 0), t = new Pn(-1 / 0, -1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { let t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0, a = -1 / 0; for (let o = 0, l = e.length; o < l; o += 3) { const l = e[o], c = e[o + 1], h = e[o + 2]; l < t && (t = l), c < n && (n = c), h < r && (r = h), l > i && (i = l), c > s && (s = c), h > a && (a = h) } return this.min.set(t, n, r), this.max.set(i, s, a), this } setFromBufferAttribute(e) { let t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0, a = -1 / 0; for (let o = 0, l = e.count; o < l; o++) { const l = e.getX(o), c = e.getY(o), h = e.getZ(o); l < t && (t = l), c < n && (n = c), h < r && (r = h), l > i && (i = l), c > s && (s = c), h > a && (a = h) } return this.min.set(t, n, r), this.max.set(i, s, a), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = On.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } setFromObject(e) { return this.makeEmpty(), this.expandByObject(e) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e) { e.updateWorldMatrix(!1, !1); const t = e.geometry; void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Un.copy(t.boundingBox), Un.applyMatrix4(e.matrixWorld), this.union(Un)); const n = e.children; for (let e = 0, t = n.length; e < t; e++)this.expandByObject(n[e]); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, On), On.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(Wn), jn.subVectors(this.max, Wn), Bn.subVectors(e.a, Wn), Hn.subVectors(e.b, Wn), zn.subVectors(e.c, Wn), Gn.subVectors(Hn, Bn), kn.subVectors(zn, Hn), Vn.subVectors(Bn, zn); let t = [0, -Gn.z, Gn.y, 0, -kn.z, kn.y, 0, -Vn.z, Vn.y, Gn.z, 0, -Gn.x, kn.z, 0, -kn.x, Vn.z, 0, -Vn.x, -Gn.y, Gn.x, 0, -kn.y, kn.x, 0, -Vn.y, Vn.x, 0]; return !!Yn(t, Bn, Hn, zn, jn) && (!!Yn(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], Bn, Hn, zn, jn) && (Xn.crossVectors(Gn, kn), Yn(t = [Xn.x, Xn.y, Xn.z], Bn, Hn, zn, jn))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return On.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return this.getCenter(e.center), e.radius = .5 * this.getSize(On).length(), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (Fn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Fn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Fn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Fn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Fn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Fn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Fn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Fn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Fn), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } Dn.prototype.isBox3 = !0; const Fn = [new Pn, new Pn, new Pn, new Pn, new Pn, new Pn, new Pn, new Pn], On = new Pn, Un = new Dn, Bn = new Pn, Hn = new Pn, zn = new Pn, Gn = new Pn, kn = new Pn, Vn = new Pn, Wn = new Pn, jn = new Pn, Xn = new Pn, qn = new Pn; function Yn(e, t, n, r, i) { for (let s = 0, a = e.length - 3; s <= a; s += 3) { qn.fromArray(e, s); const a = i.x * Math.abs(qn.x) + i.y * Math.abs(qn.y) + i.z * Math.abs(qn.z), o = t.dot(qn), l = n.dot(qn), c = r.dot(qn); if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1 } return !0 } const Zn = new Dn, Jn = new Pn, Kn = new Pn, Qn = new Pn; class $n { constructor(e = new Pn, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const n = this.center; void 0 !== t ? n.copy(t) : Zn.setFromPoints(e).getCenter(n); let r = 0; for (let t = 0, i = e.length; t < i; t++)r = Math.max(r, n.distanceToSquared(e[t])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const n = this.center.distanceToSquared(e); return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { Qn.subVectors(e, this.center); const t = Qn.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), n = .5 * (e - this.radius); this.center.add(Qn.multiplyScalar(n / e)), this.radius += n } return this } union(e) { return Kn.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Jn.copy(e.center).add(Kn)), this.expandByPoint(Jn.copy(e.center).sub(Kn)), this } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const er = new Pn, tr = new Pn, nr = new Pn, rr = new Pn, ir = new Pn, sr = new Pn, ar = new Pn; class or { constructor(e = new Pn, t = new Pn(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, er)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = er.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (er.copy(this.direction).multiplyScalar(t).add(this.origin), er.distanceToSquared(e)) } distanceSqToSegment(e, t, n, r) { tr.copy(e).add(t).multiplyScalar(.5), nr.copy(t).sub(e).normalize(), rr.copy(this.origin).sub(tr); const i = .5 * e.distanceTo(t), s = -this.direction.dot(nr), a = rr.dot(this.direction), o = -rr.dot(nr), l = rr.lengthSq(), c = Math.abs(1 - s * s); let h, u, d, p; if (c > 0) if (u = s * a - o, p = i * c, (h = s * o - a) >= 0) if (u >= -p) if (u <= p) { const e = 1 / c; d = (h *= e) * (h + s * (u *= e) + 2 * a) + u * (s * h + u + 2 * o) + l } else u = i, d = -(h = Math.max(0, -(s * u + a))) * h + u * (u + 2 * o) + l; else u = -i, d = -(h = Math.max(0, -(s * u + a))) * h + u * (u + 2 * o) + l; else u <= -p ? d = -(h = Math.max(0, -(-s * i + a))) * h + (u = h > 0 ? -i : Math.min(Math.max(-i, -o), i)) * (u + 2 * o) + l : u <= p ? (h = 0, d = (u = Math.min(Math.max(-i, -o), i)) * (u + 2 * o) + l) : d = -(h = Math.max(0, -(s * i + a))) * h + (u = h > 0 ? i : Math.min(Math.max(-i, -o), i)) * (u + 2 * o) + l; else u = s > 0 ? -i : i, d = -(h = Math.max(0, -(s * u + a))) * h + u * (u + 2 * o) + l; return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(nr).multiplyScalar(u).add(tr), d } intersectSphere(e, t) { er.subVectors(e.center, this.origin); const n = er.dot(this.direction), r = er.dot(er) - n * n, i = e.radius * e.radius; if (r > i) return null; const s = Math.sqrt(i - r), a = n - s, o = n + s; return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null } intersectPlane(e, t) { const n = this.distanceToPlane(e); return null === n ? null : this.at(n, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let n, r, i, s, a, o; const l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return l >= 0 ? (n = (e.min.x - u.x) * l, r = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l, r = (e.min.x - u.x) * l), c >= 0 ? (i = (e.min.y - u.y) * c, s = (e.max.y - u.y) * c) : (i = (e.max.y - u.y) * c, s = (e.min.y - u.y) * c), n > s || i > r ? null : ((i > n || n != n) && (n = i), (s < r || r != r) && (r = s), h >= 0 ? (a = (e.min.z - u.z) * h, o = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h, o = (e.min.z - u.z) * h), n > o || a > r ? null : ((a > n || n != n) && (n = a), (o < r || r != r) && (r = o), r < 0 ? null : this.at(n >= 0 ? n : r, t))) } intersectsBox(e) { return null !== this.intersectBox(e, er) } intersectTriangle(e, t, n, r, i) { ir.subVectors(t, e), sr.subVectors(n, e), ar.crossVectors(ir, sr); let s, a = this.direction.dot(ar); if (a > 0) { if (r) return null; s = 1 } else { if (!(a < 0)) return null; s = -1, a = -a } rr.subVectors(this.origin, e); const o = s * this.direction.dot(sr.crossVectors(rr, sr)); if (o < 0) return null; const l = s * this.direction.dot(ir.cross(rr)); if (l < 0) return null; if (o + l > a) return null; const c = -s * rr.dot(ar); return c < 0 ? null : this.at(c / a, i) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class lr { constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, r, i, s, a, o, l, c, h, u, d, p, m, f) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new lr).fromArray(this.elements) } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } copyPosition(e) { const t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, n = e.elements, r = 1 / cr.setFromMatrixColumn(e, 0).length(), i = 1 / cr.setFromMatrixColumn(e, 1).length(), s = 1 / cr.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const t = this.elements, n = e.x, r = e.y, i = e.z, s = Math.cos(n), a = Math.sin(n), o = Math.cos(r), l = Math.sin(r), c = Math.cos(i), h = Math.sin(i); if ("XYZ" === e.order) { const e = s * c, n = s * h, r = a * c, i = a * h; t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -a * o, t[2] = i - e * l, t[6] = r + n * l, t[10] = s * o } else if ("YXZ" === e.order) { const e = o * c, n = o * h, r = l * c, i = l * h; t[0] = e + i * a, t[4] = r * a - n, t[8] = s * l, t[1] = s * h, t[5] = s * c, t[9] = -a, t[2] = n * a - r, t[6] = i + e * a, t[10] = s * o } else if ("ZXY" === e.order) { const e = o * c, n = o * h, r = l * c, i = l * h; t[0] = e - i * a, t[4] = -s * h, t[8] = r + n * a, t[1] = n + r * a, t[5] = s * c, t[9] = i - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o } else if ("ZYX" === e.order) { const e = s * c, n = s * h, r = a * c, i = a * h; t[0] = o * c, t[4] = r * l - n, t[8] = e * l + i, t[1] = o * h, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = a * o, t[10] = s * o } else if ("YZX" === e.order) { const e = s * o, n = s * l, r = a * o, i = a * l; t[0] = o * c, t[4] = i - e * h, t[8] = r * h + n, t[1] = h, t[5] = s * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * h + r, t[10] = e - i * h } else if ("XZY" === e.order) { const e = s * o, n = s * l, r = a * o, i = a * l; t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = e * h + i, t[5] = s * c, t[9] = n * h - r, t[2] = r * h - n, t[6] = a * c, t[10] = i * h + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(ur, e, dr) } lookAt(e, t, n) { const r = this.elements; return fr.subVectors(e, t), 0 === fr.lengthSq() && (fr.z = 1), fr.normalize(), pr.crossVectors(n, fr), 0 === pr.lengthSq() && (1 === Math.abs(n.z) ? fr.x += 1e-4 : fr.z += 1e-4, fr.normalize(), pr.crossVectors(n, fr)), pr.normalize(), mr.crossVectors(fr, pr), r[0] = pr.x, r[4] = mr.x, r[8] = fr.x, r[1] = pr.y, r[5] = mr.y, r[9] = fr.y, r[2] = pr.z, r[6] = mr.z, r[10] = fr.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, r = t.elements, i = this.elements, s = n[0], a = n[4], o = n[8], l = n[12], c = n[1], h = n[5], u = n[9], d = n[13], p = n[2], m = n[6], f = n[10], g = n[14], v = n[3], y = n[7], x = n[11], _ = n[15], b = r[0], w = r[4], M = r[8], T = r[12], E = r[1], S = r[5], A = r[9], R = r[13], L = r[2], C = r[6], P = r[10], I = r[14], N = r[3], D = r[7], F = r[11], O = r[15]; return i[0] = s * b + a * E + o * L + l * N, i[4] = s * w + a * S + o * C + l * D, i[8] = s * M + a * A + o * P + l * F, i[12] = s * T + a * R + o * I + l * O, i[1] = c * b + h * E + u * L + d * N, i[5] = c * w + h * S + u * C + d * D, i[9] = c * M + h * A + u * P + d * F, i[13] = c * T + h * R + u * I + d * O, i[2] = p * b + m * E + f * L + g * N, i[6] = p * w + m * S + f * C + g * D, i[10] = p * M + m * A + f * P + g * F, i[14] = p * T + m * R + f * I + g * O, i[3] = v * b + y * E + x * L + _ * N, i[7] = v * w + y * S + x * C + _ * D, i[11] = v * M + y * A + x * P + _ * F, i[15] = v * T + y * R + x * I + _ * O, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[4], r = e[8], i = e[12], s = e[1], a = e[5], o = e[9], l = e[13], c = e[2], h = e[6], u = e[10], d = e[14]; return e[3] * (+i * o * h - r * l * h - i * a * u + n * l * u + r * a * d - n * o * d) + e[7] * (+t * o * d - t * l * u + i * s * u - r * s * d + r * l * c - i * o * c) + e[11] * (+t * l * h - t * a * d - i * s * h + n * s * d + i * a * c - n * l * c) + e[15] * (-r * a * c - t * o * h + t * a * u + r * s * h - n * s * u + n * o * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, n) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8], h = e[9], u = e[10], d = e[11], p = e[12], m = e[13], f = e[14], g = e[15], v = h * f * l - m * u * l + m * o * d - a * f * d - h * o * g + a * u * g, y = p * u * l - c * f * l - p * o * d + s * f * d + c * o * g - s * u * g, x = c * m * l - p * h * l + p * a * d - s * m * d - c * a * g + s * h * g, _ = p * h * o - c * m * o - p * a * u + s * m * u + c * a * f - s * h * f, b = t * v + n * y + r * x + i * _; if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const w = 1 / b; return e[0] = v * w, e[1] = (m * u * i - h * f * i - m * r * d + n * f * d + h * r * g - n * u * g) * w, e[2] = (a * f * i - m * o * i + m * r * l - n * f * l - a * r * g + n * o * g) * w, e[3] = (h * o * i - a * u * i - h * r * l + n * u * l + a * r * d - n * o * d) * w, e[4] = y * w, e[5] = (c * f * i - p * u * i + p * r * d - t * f * d - c * r * g + t * u * g) * w, e[6] = (p * o * i - s * f * i - p * r * l + t * f * l + s * r * g - t * o * g) * w, e[7] = (s * u * i - c * o * i + c * r * l - t * u * l - s * r * d + t * o * d) * w, e[8] = x * w, e[9] = (p * h * i - c * m * i - p * n * d + t * m * d + c * n * g - t * h * g) * w, e[10] = (s * m * i - p * a * i + p * n * l - t * m * l - s * n * g + t * a * g) * w, e[11] = (c * a * i - s * h * i - c * n * l + t * h * l + s * n * d - t * a * d) * w, e[12] = _ * w, e[13] = (c * m * r - p * h * r + p * n * u - t * m * u - c * n * f + t * h * f) * w, e[14] = (p * a * r - s * m * r - p * n * o + t * m * o + s * n * f - t * a * f) * w, e[15] = (s * h * r - c * a * r + c * n * o - t * h * o - s * n * u + t * a * u) * w, this } scale(e) { const t = this.elements, n = e.x, r = e.y, i = e.z; return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, r)) } makeTranslation(e, t, n) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const n = Math.cos(t), r = Math.sin(t), i = 1 - n, s = e.x, a = e.y, o = e.z, l = i * s, c = i * a; return this.set(l * s + n, l * a - r * o, l * o + r * a, 0, l * a + r * o, c * a + n, c * o - r * s, 0, l * o - r * a, c * o + r * s, i * o * o + n, 0, 0, 0, 0, 1), this } makeScale(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(e, t, n, r, i, s) { return this.set(1, n, i, 0, e, 1, s, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, n) { const r = this.elements, i = t._x, s = t._y, a = t._z, o = t._w, l = i + i, c = s + s, h = a + a, u = i * l, d = i * c, p = i * h, m = s * c, f = s * h, g = a * h, v = o * l, y = o * c, x = o * h, _ = n.x, b = n.y, w = n.z; return r[0] = (1 - (m + g)) * _, r[1] = (d + x) * _, r[2] = (p - y) * _, r[3] = 0, r[4] = (d - x) * b, r[5] = (1 - (u + g)) * b, r[6] = (f + v) * b, r[7] = 0, r[8] = (p + y) * w, r[9] = (f - v) * w, r[10] = (1 - (u + m)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, n) { const r = this.elements; let i = cr.set(r[0], r[1], r[2]).length(); const s = cr.set(r[4], r[5], r[6]).length(), a = cr.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], hr.copy(this); const o = 1 / i, l = 1 / s, c = 1 / a; return hr.elements[0] *= o, hr.elements[1] *= o, hr.elements[2] *= o, hr.elements[4] *= l, hr.elements[5] *= l, hr.elements[6] *= l, hr.elements[8] *= c, hr.elements[9] *= c, hr.elements[10] *= c, t.setFromRotationMatrix(hr), n.x = i, n.y = s, n.z = a, this } makePerspective(e, t, n, r, i, s) { void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const a = this.elements, o = 2 * i / (t - e), l = 2 * i / (n - r), c = (t + e) / (t - e), h = (n + r) / (n - r), u = -(s + i) / (s - i), d = -2 * s * i / (s - i); return a[0] = o, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this } makeOrthographic(e, t, n, r, i, s) { const a = this.elements, o = 1 / (t - e), l = 1 / (n - r), c = 1 / (s - i), h = (t + e) * o, u = (n + r) * l, d = (s + i) * c; return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 16; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } } lr.prototype.isMatrix4 = !0; const cr = new Pn, hr = new lr, ur = new Pn(0, 0, 0), dr = new Pn(1, 1, 1), pr = new Pn, mr = new Pn, fr = new Pn, gr = new lr, vr = new Cn; class yr { constructor(e = 0, t = 0, n = 0, r = yr.DefaultOrder) { this._x = e, this._y = t, this._z = n, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, n, r = this._order) { return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, n = !0) { const r = e.elements, i = r[0], s = r[4], a = r[8], o = r[1], l = r[5], c = r[9], h = r[2], u = r[6], d = r[10]; switch (t) { case "XYZ": this._y = Math.asin(cn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(u, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-cn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, i), this._z = 0); break; case "ZXY": this._x = Math.asin(cn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, i)); break; case "ZYX": this._y = Math.asin(-cn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, i)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(cn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, i)) : (this._x = 0, this._y = Math.atan2(a, d)); break; case "XZY": this._z = Math.asin(-cn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-c, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === n && this._onChangeCallback(), this } setFromQuaternion(e, t, n) { return gr.makeRotationFromQuaternion(e), this.setFromRotationMatrix(gr, t, n) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return vr.setFromEuler(this), this.setFromQuaternion(vr, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } toVector3(e) { return e ? e.set(this._x, this._y, this._z) : new Pn(this._x, this._y, this._z) } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } yr.prototype.isEuler = !0, yr.DefaultOrder = "XYZ", yr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class xr { constructor() { this.mask = 1 } set(e) { this.mask = 1 << e | 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return 0 != (this.mask & e.mask) } } let _r = 0; const br = new Pn, wr = new Cn, Mr = new lr, Tr = new Pn, Er = new Pn, Sr = new Pn, Ar = new Cn, Rr = new Pn(1, 0, 0), Lr = new Pn(0, 1, 0), Cr = new Pn(0, 0, 1), Pr = { type: "added" }, Ir = { type: "removed" }; class Nr extends nn { constructor() { super(), Object.defineProperty(this, "id", { value: _r++ }), this.uuid = ln(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Nr.DefaultUp.clone(); const e = new Pn, t = new yr, n = new Cn, r = new Pn(1, 1, 1); t._onChange(function () { n.setFromEuler(t, !1) }), n._onChange(function () { t.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new lr }, normalMatrix: { value: new vn } }), this.matrix = new lr, this.matrixWorld = new lr, this.matrixAutoUpdate = Nr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new xr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return wr.setFromAxisAngle(e, t), this.quaternion.multiply(wr), this } rotateOnWorldAxis(e, t) { return wr.setFromAxisAngle(e, t), this.quaternion.premultiply(wr), this } rotateX(e) { return this.rotateOnAxis(Rr, e) } rotateY(e) { return this.rotateOnAxis(Lr, e) } rotateZ(e) { return this.rotateOnAxis(Cr, e) } translateOnAxis(e, t) { return br.copy(e).applyQuaternion(this.quaternion), this.position.add(br.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(Rr, e) } translateY(e) { return this.translateOnAxis(Lr, e) } translateZ(e) { return this.translateOnAxis(Cr, e) } localToWorld(e) { return e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return e.applyMatrix4(Mr.copy(this.matrixWorld).invert()) } lookAt(e, t, n) { e.isVector3 ? Tr.copy(e) : Tr.set(e, t, n); const r = this.parent; this.updateWorldMatrix(!0, !1), Er.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Mr.lookAt(Er, Tr, this.up) : Mr.lookAt(Tr, Er, this.up), this.quaternion.setFromRotationMatrix(Mr), r && (Mr.extractRotation(r.matrixWorld), wr.setFromRotationMatrix(Mr), this.quaternion.premultiply(wr.invert())) } add(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Pr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } const t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Ir)), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(Ir) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), Mr.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Mr.multiply(e.parent.matrixWorld)), e.applyMatrix4(Mr), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let n = 0, r = this.children.length; n < r; n++) { const r = this.children[n].getObjectByProperty(e, t); if (void 0 !== r) return r } } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Er, e, Sr), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Er, Ar, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].traverse(e) } traverseVisible(e) { if (!1 === this.visible) return; e(this); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].updateMatrixWorld(e) } updateWorldMatrix(e, t) { const n = this.parent; if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) { const e = this.children; for (let t = 0, n = e.length; t < n; t++)e[t].updateWorldMatrix(!1, !0) } } toJSON(e) { const t = void 0 === e || "string" == typeof e, n = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const r = {}; function i(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = i(e.geometries, this.geometry); const t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { const n = t.shapes; if (Array.isArray(n)) for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; i(e.shapes, r) } else i(e.shapes, n) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const t = []; for (let n = 0, r = this.material.length; n < r; n++)t.push(i(e.materials, this.material[n])); r.material = t } else r.material = i(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (let t = 0; t < this.children.length; t++)r.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let t = 0; t < this.animations.length; t++) { const n = this.animations[t]; r.animations.push(i(e.animations, n)) } } if (t) { const t = s(e.geometries), r = s(e.materials), i = s(e.textures), a = s(e.images), o = s(e.shapes), l = s(e.skeletons), c = s(e.animations); t.length > 0 && (n.geometries = t), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c) } return n.object = r, n; function s(e) { const t = []; for (const n in e) { const r = e[n]; delete r.metadata, t.push(r) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { const n = e.children[t]; this.add(n.clone()) } return this } } Nr.DefaultUp = new Pn(0, 1, 0), Nr.DefaultMatrixAutoUpdate = !0, Nr.prototype.isObject3D = !0; const Dr = new Pn, Fr = new Pn, Or = new Pn, Ur = new Pn, Br = new Pn, Hr = new Pn, zr = new Pn, Gr = new Pn, kr = new Pn, Vr = new Pn; class Wr { constructor(e = new Pn, t = new Pn, n = new Pn) { this.a = e, this.b = t, this.c = n } static getNormal(e, t, n, r) { r.subVectors(n, t), Dr.subVectors(e, t), r.cross(Dr); const i = r.lengthSq(); return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0) } static getBarycoord(e, t, n, r, i) { Dr.subVectors(r, t), Fr.subVectors(n, t), Or.subVectors(e, t); const s = Dr.dot(Dr), a = Dr.dot(Fr), o = Dr.dot(Or), l = Fr.dot(Fr), c = Fr.dot(Or), h = s * l - a * a; if (0 === h) return i.set(-2, -1, -1); const u = 1 / h, d = (l * o - a * c) * u, p = (s * c - a * o) * u; return i.set(1 - d - p, p, d) } static containsPoint(e, t, n, r) { return this.getBarycoord(e, t, n, r, Ur), Ur.x >= 0 && Ur.y >= 0 && Ur.x + Ur.y <= 1 } static getUV(e, t, n, r, i, s, a, o) { return this.getBarycoord(e, t, n, r, Ur), o.set(0, 0), o.addScaledVector(i, Ur.x), o.addScaledVector(s, Ur.y), o.addScaledVector(a, Ur.z), o } static isFrontFacing(e, t, n, r) { return Dr.subVectors(n, t), Fr.subVectors(e, t), Dr.cross(Fr).dot(r) < 0 } set(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } setFromPointsAndIndices(e, t, n, r) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Dr.subVectors(this.c, this.b), Fr.subVectors(this.a, this.b), .5 * Dr.cross(Fr).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Wr.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return Wr.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, n, r, i) { return Wr.getUV(e, this.a, this.b, this.c, t, n, r, i) } containsPoint(e) { return Wr.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Wr.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const n = this.a, r = this.b, i = this.c; let s, a; Br.subVectors(r, n), Hr.subVectors(i, n), Gr.subVectors(e, n); const o = Br.dot(Gr), l = Hr.dot(Gr); if (o <= 0 && l <= 0) return t.copy(n); kr.subVectors(e, r); const c = Br.dot(kr), h = Hr.dot(kr); if (c >= 0 && h <= c) return t.copy(r); const u = o * h - c * l; if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), t.copy(n).addScaledVector(Br, s); Vr.subVectors(e, i); const d = Br.dot(Vr), p = Hr.dot(Vr); if (p >= 0 && d <= p) return t.copy(i); const m = d * l - o * p; if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(Hr, a); const f = c * p - d * h; if (f <= 0 && h - c >= 0 && d - p >= 0) return zr.subVectors(i, r), a = (h - c) / (h - c + (d - p)), t.copy(r).addScaledVector(zr, a); const g = 1 / (f + m + u); return s = m * g, a = u * g, t.copy(n).addScaledVector(Br, s).addScaledVector(Hr, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let jr = 0; class Xr extends nn { constructor() { super(), Object.defineProperty(this, "id", { value: jr++ }), this.uuid = ln(), this.name = "", this.type = "Material", this.fog = !0, this.blending = m, this.side = c, this.vertexColors = !1, this.opacity = 1, this.format = Re, this.transparent = !1, this.blendSrc = R, this.blendDst = L, this.blendEquation = x, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = B, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Qt, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Kt, this.stencilZFail = Kt, this.stencilZPass = Kt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const t in e) { const n = e[t]; if (void 0 === n) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } if ("shading" === t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === d; continue } const r = this[t]; void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") } } toJSON(e) { const t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function r(e) { const t = []; for (const n in e) { const r = e[n]; delete r.metadata, t.push(r) } return t } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== m && (n.blending = this.blending), this.side !== c && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== Re && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) { const t = r(e.textures), i = r(e.images); t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i) } return n } clone() { return (new this.constructor).copy(this) } copy(e) { this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let n = null; if (null !== t) { const e = t.length; n = new Array(e); for (let r = 0; r !== e; ++r)n[r] = t[r].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } } Xr.prototype.isMaterial = !0; const qr = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Yr = { h: 0, s: 0, l: 0 }, Zr = { h: 0, s: 0, l: 0 }; function Jr(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } function Kr(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function Qr(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } class $r { constructor(e, t, n) { return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n) } set(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this } setRGB(e, t, n) { return this.r = e, this.g = t, this.b = n, this } setHSL(e, t, n) { if (e = hn(e, 1), t = cn(t, 0, 1), n = cn(n, 0, 1), 0 === t) this.r = this.g = this.b = n; else { const r = n <= .5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r; this.r = Jr(i, r, e + 1 / 3), this.g = Jr(i, r, e), this.b = Jr(i, r, e - 1 / 3) } return this } setStyle(e) { function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let n; if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) { let e; const r = n[1], i = n[2]; switch (r) { case "rgb": case "rgba": if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this; if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this; break; case "hsl": case "hsla": if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) { const n = parseFloat(e[1]) / 360, r = parseInt(e[2], 10) / 100, i = parseInt(e[3], 10) / 100; return t(e[4]), this.setHSL(n, r, i) } } } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) { const e = n[1], t = e.length; if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this; if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this } return e && e.length > 0 ? this.setColorName(e) : this } setColorName(e) { const t = qr[e.toLowerCase()]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copyGammaToLinear(e, t = 2) { return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } copyLinearToGamma(e, t = 2) { const n = t > 0 ? 1 / t : 1; return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this } convertGammaToLinear(e) { return this.copyGammaToLinear(this, e), this } convertLinearToGamma(e) { return this.copyLinearToGamma(this, e), this } copySRGBToLinear(e) { return this.r = Kr(e.r), this.g = Kr(e.g), this.b = Kr(e.b), this } copyLinearToSRGB(e) { return this.r = Qr(e.r), this.g = Qr(e.g), this.b = Qr(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(e) { const t = this.r, n = this.g, r = this.b, i = Math.max(t, n, r), s = Math.min(t, n, r); let a, o; const l = (s + i) / 2; if (s === i) a = 0, o = 0; else { const e = i - s; switch (o = l <= .5 ? e / (i + s) : e / (2 - i - s), i) { case t: a = (n - r) / e + (n < r ? 6 : 0); break; case n: a = (r - t) / e + 2; break; case r: a = (t - n) / e + 4 }a /= 6 } return e.h = a, e.s = o, e.l = l, e } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(e, t, n) { return this.getHSL(Yr), Yr.h += e, Yr.s += t, Yr.l += n, this.setHSL(Yr.h, Yr.s, Yr.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, n) { return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this } lerpHSL(e, t) { this.getHSL(Yr), e.getHSL(Zr); const n = un(Yr.h, Zr.h, t), r = un(Yr.s, Zr.s, t), i = un(Yr.l, Zr.l, t); return this.setHSL(n, r, i), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } $r.NAMES = qr, $r.prototype.isColor = !0, $r.prototype.r = 1, $r.prototype.g = 1, $r.prototype.b = 1; class ei extends Xr { constructor(e) { super(), this.type = "MeshBasicMaterial", this.color = new $r(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } ei.prototype.isMeshBasicMaterial = !0; const ti = new Pn, ni = new gn; class ri { constructor(e, t, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = $t, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (let r = 0, i = this.itemSize; r < i; r++)this.array[e + r] = t.array[n + r]; return this } copyArray(e) { return this.array.set(e), this } copyColorsArray(e) { const t = this.array; let n = 0; for (let r = 0, i = e.length; r < i; r++) { let i = e[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new $r), t[n++] = i.r, t[n++] = i.g, t[n++] = i.b } return this } copyVector2sArray(e) { const t = this.array; let n = 0; for (let r = 0, i = e.length; r < i; r++) { let i = e[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new gn), t[n++] = i.x, t[n++] = i.y } return this } copyVector3sArray(e) { const t = this.array; let n = 0; for (let r = 0, i = e.length; r < i; r++) { let i = e[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new Pn), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z } return this } copyVector4sArray(e) { const t = this.array; let n = 0; for (let r = 0, i = e.length; r < i; r++) { let i = e[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new Sn), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z, t[n++] = i.w } return this } applyMatrix3(e) { if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)ni.fromBufferAttribute(this, t), ni.applyMatrix3(e), this.setXY(t, ni.x, ni.y); else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)ti.fromBufferAttribute(this, t), ti.applyMatrix3(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } applyMatrix4(e) { for (let t = 0, n = this.count; t < n; t++)ti.x = this.getX(t), ti.y = this.getY(t), ti.z = this.getZ(t), ti.applyMatrix4(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)ti.x = this.getX(t), ti.y = this.getY(t), ti.z = this.getZ(t), ti.applyNormalMatrix(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)ti.x = this.getX(t), ti.y = this.getY(t), ti.z = this.getZ(t), ti.transformDirection(e), this.setXYZ(t, ti.x, ti.y, ti.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { return this.array[e * this.itemSize] } setX(e, t) { return this.array[e * this.itemSize] = t, this } getY(e) { return this.array[e * this.itemSize + 1] } setY(e, t) { return this.array[e * this.itemSize + 1] = t, this } getZ(e) { return this.array[e * this.itemSize + 2] } setZ(e, t) { return this.array[e * this.itemSize + 2] = t, this } getW(e) { return this.array[e * this.itemSize + 3] } setW(e, t) { return this.array[e * this.itemSize + 3] = t, this } setXY(e, t, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this } setXYZW(e, t, n, r, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== $t && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e } } ri.prototype.isBufferAttribute = !0; class ii extends ri { constructor(e, t, n) { super(new Int8Array(e), t, n) } } class si extends ri { constructor(e, t, n) { super(new Uint8Array(e), t, n) } } class ai extends ri { constructor(e, t, n) { super(new Uint8ClampedArray(e), t, n) } } class oi extends ri { constructor(e, t, n) { super(new Int16Array(e), t, n) } } class li extends ri { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } class ci extends ri { constructor(e, t, n) { super(new Int32Array(e), t, n) } } class hi extends ri { constructor(e, t, n) { super(new Uint32Array(e), t, n) } } class ui extends ri { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } ui.prototype.isFloat16BufferAttribute = !0; class di extends ri { constructor(e, t, n) { super(new Float32Array(e), t, n) } } class pi extends ri { constructor(e, t, n) { super(new Float64Array(e), t, n) } } function mi(e) { if (0 === e.length) return -1 / 0; let t = e[0]; for (let n = 1, r = e.length; n < r; ++n)e[n] > t && (t = e[n]); return t } const fi = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function gi(e, t) { return new fi[e](t) } let vi = 0; const yi = new lr, xi = new Nr, _i = new Pn, bi = new Dn, wi = new Dn, Mi = new Pn; class Ti extends nn { constructor() { super(), Object.defineProperty(this, "id", { value: vi++ }), this.uuid = ln(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (mi(e) > 65535 ? hi : li)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, n = 0) { this.groups.push({ start: e, count: t, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const t = (new vn).getNormalMatrix(e); n.applyNormalMatrix(t), n.needsUpdate = !0 } const r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return yi.makeRotationFromQuaternion(e), this.applyMatrix4(yi), this } rotateX(e) { return yi.makeRotationX(e), this.applyMatrix4(yi), this } rotateY(e) { return yi.makeRotationY(e), this.applyMatrix4(yi), this } rotateZ(e) { return yi.makeRotationZ(e), this.applyMatrix4(yi), this } translate(e, t, n) { return yi.makeTranslation(e, t, n), this.applyMatrix4(yi), this } scale(e, t, n) { return yi.makeScale(e, t, n), this.applyMatrix4(yi), this } lookAt(e) { return xi.lookAt(e), xi.updateMatrix(), this.applyMatrix4(xi.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(_i).negate(), this.translate(_i.x, _i.y, _i.z), this } setFromPoints(e) { const t = []; for (let n = 0, r = e.length; n < r; n++) { const r = e[n]; t.push(r.x, r.y, r.z || 0) } return this.setAttribute("position", new di(t, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new Dn); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Pn(-1 / 0, -1 / 0, -1 / 0), new Pn(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; bi.setFromBufferAttribute(n), this.morphTargetsRelative ? (Mi.addVectors(this.boundingBox.min, bi.min), this.boundingBox.expandByPoint(Mi), Mi.addVectors(this.boundingBox.max, bi.max), this.boundingBox.expandByPoint(Mi)) : (this.boundingBox.expandByPoint(bi.min), this.boundingBox.expandByPoint(bi.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new $n); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Pn, 1 / 0); if (e) { const n = this.boundingSphere.center; if (bi.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; wi.setFromBufferAttribute(n), this.morphTargetsRelative ? (Mi.addVectors(bi.min, wi.min), bi.expandByPoint(Mi), Mi.addVectors(bi.max, wi.max), bi.expandByPoint(Mi)) : (bi.expandByPoint(wi.min), bi.expandByPoint(wi.max)) } bi.getCenter(n); let r = 0; for (let t = 0, i = e.count; t < i; t++)Mi.fromBufferAttribute(e, t), r = Math.max(r, n.distanceToSquared(Mi)); if (t) for (let i = 0, s = t.length; i < s; i++) { const s = t[i], a = this.morphTargetsRelative; for (let t = 0, i = s.count; t < i; t++)Mi.fromBufferAttribute(s, t), a && (_i.fromBufferAttribute(e, t), Mi.add(_i)), r = Math.max(r, n.distanceToSquared(Mi)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = e.array, r = t.position.array, i = t.normal.array, s = t.uv.array, a = r.length / 3; void 0 === t.tangent && this.setAttribute("tangent", new ri(new Float32Array(4 * a), 4)); const o = t.tangent.array, l = [], c = []; for (let e = 0; e < a; e++)l[e] = new Pn, c[e] = new Pn; const h = new Pn, u = new Pn, d = new Pn, p = new gn, m = new gn, f = new gn, g = new Pn, v = new Pn; function y(e, t, n) { h.fromArray(r, 3 * e), u.fromArray(r, 3 * t), d.fromArray(r, 3 * n), p.fromArray(s, 2 * e), m.fromArray(s, 2 * t), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p); const i = 1 / (m.x * f.y - f.x * m.y); isFinite(i) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(i), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(i), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v)) } let x = this.groups; 0 === x.length && (x = [{ start: 0, count: n.length }]); for (let e = 0, t = x.length; e < t; ++e) { const t = x[e], r = t.start; for (let e = r, i = r + t.count; e < i; e += 3)y(n[e + 0], n[e + 1], n[e + 2]) } const _ = new Pn, b = new Pn, w = new Pn, M = new Pn; function T(e) { w.fromArray(i, 3 * e), M.copy(w); const t = l[e]; _.copy(t), _.sub(w.multiplyScalar(w.dot(t))).normalize(), b.crossVectors(M, t); const n = b.dot(c[e]) < 0 ? -1 : 1; o[4 * e] = _.x, o[4 * e + 1] = _.y, o[4 * e + 2] = _.z, o[4 * e + 3] = n } for (let e = 0, t = x.length; e < t; ++e) { const t = x[e], r = t.start; for (let e = r, i = r + t.count; e < i; e += 3)T(n[e + 0]), T(n[e + 1]), T(n[e + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let n = this.getAttribute("normal"); if (void 0 === n) n = new ri(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n); else for (let e = 0, t = n.count; e < t; e++)n.setXYZ(e, 0, 0, 0); const r = new Pn, i = new Pn, s = new Pn, a = new Pn, o = new Pn, l = new Pn, c = new Pn, h = new Pn; if (e) for (let u = 0, d = e.count; u < d; u += 3) { const d = e.getX(u + 0), p = e.getX(u + 1), m = e.getX(u + 2); r.fromBufferAttribute(t, d), i.fromBufferAttribute(t, p), s.fromBufferAttribute(t, m), c.subVectors(s, i), h.subVectors(r, i), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(m, l.x, l.y, l.z) } else for (let e = 0, a = t.count; e < a; e += 3)r.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, i), h.subVectors(r, i), c.cross(h), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge(e, t) { if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e); void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const r in n) { if (void 0 === e.attributes[r]) continue; const i = n[r].array, s = e.attributes[r], a = s.array, o = s.itemSize * t, l = Math.min(a.length, i.length - o); for (let e = 0, t = o; e < l; e++, t++)i[t] = a[e] } return this } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, n = e.count; t < n; t++)Mi.fromBufferAttribute(e, t), Mi.normalize(), e.setXYZ(t, Mi.x, Mi.y, Mi.z) } toNonIndexed() { function e(e, t) { const n = e.array, r = e.itemSize, i = e.normalized, s = new n.constructor(t.length * r); let a = 0, o = 0; for (let i = 0, l = t.length; i < l; i++) { a = e.isInterleavedBufferAttribute ? t[i] * e.data.stride + e.offset : t[i] * r; for (let e = 0; e < r; e++)s[o++] = n[a++] } return new ri(s, r, i) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new Ti, n = this.index.array, r = this.attributes; for (const i in r) { const s = e(r[i], n); t.setAttribute(i, s) } const i = this.morphAttributes; for (const r in i) { const s = [], a = i[r]; for (let t = 0, r = a.length; t < r; t++) { const r = e(a[t], n); s.push(r) } t.morphAttributes[r] = s } t.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let e = 0, n = s.length; e < n; e++) { const n = s[e]; t.addGroup(n.start, n.count, n.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { const t = this.parameters; for (const n in t) void 0 !== t[n] && (e[n] = t[n]); return e } e.data = { attributes: {} }; const t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const n = this.attributes; for (const t in n) { const r = n[t]; e.data.attributes[t] = r.toJSON(e.data) } const r = {}; let i = !1; for (const t in this.morphAttributes) { const n = this.morphAttributes[t], s = []; for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; s.push(r.toJSON(e.data)) } s.length > 0 && (r[t] = s, i = !0) } i && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s))); const a = this.boundingSphere; return null !== a && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return (new Ti).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const n = e.index; null !== n && this.setIndex(n.clone(t)); const r = e.attributes; for (const e in r) { const n = r[e]; this.setAttribute(e, n.clone(t)) } const i = e.morphAttributes; for (const e in i) { const n = [], r = i[e]; for (let e = 0, i = r.length; e < i; e++)n.push(r[e].clone(t)); this.morphAttributes[e] = n } this.morphTargetsRelative = e.morphTargetsRelative; const s = e.groups; for (let e = 0, t = s.length; e < t; e++) { const t = s[e]; this.addGroup(t.start, t.count, t.materialIndex) } const a = e.boundingBox; null !== a && (this.boundingBox = a.clone()); const o = e.boundingSphere; return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } Ti.prototype.isBufferGeometry = !0; const Ei = new lr, Si = new or, Ai = new $n, Ri = new Pn, Li = new Pn, Ci = new Pn, Pi = new Pn, Ii = new Pn, Ni = new Pn, Di = new Pn, Fi = new Pn, Oi = new Pn, Ui = new gn, Bi = new gn, Hi = new gn, zi = new Pn, Gi = new Pn; class ki extends Nr { constructor(e = new Ti, t = new ei) { super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } raycast(e, t) { const n = this.geometry, r = this.material, i = this.matrixWorld; if (void 0 === r) return; if (null === n.boundingSphere && n.computeBoundingSphere(), Ai.copy(n.boundingSphere), Ai.applyMatrix4(i), !1 === e.ray.intersectsSphere(Ai)) return; if (Ei.copy(i).invert(), Si.copy(e.ray).applyMatrix4(Ei), null !== n.boundingBox && !1 === Si.intersectsBox(n.boundingBox)) return; let s; if (n.isBufferGeometry) { const i = n.index, a = n.attributes.position, o = n.morphAttributes.position, l = n.morphTargetsRelative, c = n.attributes.uv, h = n.attributes.uv2, u = n.groups, d = n.drawRange; if (null !== i) if (Array.isArray(r)) for (let n = 0, p = u.length; n < p; n++) { const p = u[n], m = r[p.materialIndex]; for (let n = Math.max(p.start, d.start), r = Math.min(p.start + p.count, d.start + d.count); n < r; n += 3) { const r = i.getX(n), u = i.getX(n + 1), d = i.getX(n + 2); (s = Vi(this, m, e, Si, a, o, l, c, h, r, u, d)) && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, t.push(s)) } } else { for (let n = Math.max(0, d.start), u = Math.min(i.count, d.start + d.count); n < u; n += 3) { const u = i.getX(n), d = i.getX(n + 1), p = i.getX(n + 2); (s = Vi(this, r, e, Si, a, o, l, c, h, u, d, p)) && (s.faceIndex = Math.floor(n / 3), t.push(s)) } } else if (void 0 !== a) if (Array.isArray(r)) for (let n = 0, i = u.length; n < i; n++) { const i = u[n], p = r[i.materialIndex]; for (let n = Math.max(i.start, d.start), r = Math.min(i.start + i.count, d.start + d.count); n < r; n += 3) { (s = Vi(this, p, e, Si, a, o, l, c, h, n, n + 1, n + 2)) && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, t.push(s)) } } else { for (let n = Math.max(0, d.start), i = Math.min(a.count, d.start + d.count); n < i; n += 3) { (s = Vi(this, r, e, Si, a, o, l, c, h, n, n + 1, n + 2)) && (s.faceIndex = Math.floor(n / 3), t.push(s)) } } } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } function Vi(e, t, n, r, i, s, a, o, l, c, d, p) { Ri.fromBufferAttribute(i, c), Li.fromBufferAttribute(i, d), Ci.fromBufferAttribute(i, p); const m = e.morphTargetInfluences; if (s && m) { Di.set(0, 0, 0), Fi.set(0, 0, 0), Oi.set(0, 0, 0); for (let e = 0, t = s.length; e < t; e++) { const t = m[e], n = s[e]; 0 !== t && (Pi.fromBufferAttribute(n, c), Ii.fromBufferAttribute(n, d), Ni.fromBufferAttribute(n, p), a ? (Di.addScaledVector(Pi, t), Fi.addScaledVector(Ii, t), Oi.addScaledVector(Ni, t)) : (Di.addScaledVector(Pi.sub(Ri), t), Fi.addScaledVector(Ii.sub(Li), t), Oi.addScaledVector(Ni.sub(Ci), t))) } Ri.add(Di), Li.add(Fi), Ci.add(Oi) } e.isSkinnedMesh && (e.boneTransform(c, Ri), e.boneTransform(d, Li), e.boneTransform(p, Ci)); const f = function (e, t, n, r, i, s, a, o) { let l; if (null === (l = t.side === h ? r.intersectTriangle(a, s, i, !0, o) : r.intersectTriangle(i, s, a, t.side !== u, o))) return null; Gi.copy(o), Gi.applyMatrix4(e.matrixWorld); const c = n.ray.origin.distanceTo(Gi); return c < n.near || c > n.far ? null : { distance: c, point: Gi.clone(), object: e } }(e, t, n, r, Ri, Li, Ci, zi); if (f) { o && (Ui.fromBufferAttribute(o, c), Bi.fromBufferAttribute(o, d), Hi.fromBufferAttribute(o, p), f.uv = Wr.getUV(zi, Ri, Li, Ci, Ui, Bi, Hi, new gn)), l && (Ui.fromBufferAttribute(l, c), Bi.fromBufferAttribute(l, d), Hi.fromBufferAttribute(l, p), f.uv2 = Wr.getUV(zi, Ri, Li, Ci, Ui, Bi, Hi, new gn)); const e = { a: c, b: d, c: p, normal: new Pn, materialIndex: 0 }; Wr.getNormal(Ri, Li, Ci, e.normal), f.face = e } return f } ki.prototype.isMesh = !0; class Wi extends Ti { constructor(e = 1, t = 1, n = 1, r = 1, i = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: s }; const a = this; r = Math.floor(r), i = Math.floor(i), s = Math.floor(s); const o = [], l = [], c = [], h = []; let u = 0, d = 0; function p(e, t, n, r, i, s, p, m, f, g, v) { const y = s / f, x = p / g, _ = s / 2, b = p / 2, w = m / 2, M = f + 1, T = g + 1; let E = 0, S = 0; const A = new Pn; for (let s = 0; s < T; s++) { const a = s * x - b; for (let o = 0; o < M; o++) { const u = o * y - _; A[e] = u * r, A[t] = a * i, A[n] = w, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(o / f), h.push(1 - s / g), E += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < f; t++) { const n = u + t + M * e, r = u + t + M * (e + 1), i = u + (t + 1) + M * (e + 1), s = u + (t + 1) + M * e; o.push(n, r, s), o.push(r, i, s), S += 6 } a.addGroup(d, S, v), d += S, u += E } p("z", "y", "x", -1, -1, n, t, e, s, i, 0), p("z", "y", "x", 1, -1, n, t, -e, s, i, 1), p("x", "z", "y", 1, 1, e, n, t, r, s, 2), p("x", "z", "y", 1, -1, e, n, -t, r, s, 3), p("x", "y", "z", 1, -1, e, t, n, r, i, 4), p("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(o), this.setAttribute("position", new di(l, 3)), this.setAttribute("normal", new di(c, 3)), this.setAttribute("uv", new di(h, 2)) } static fromJSON(e) { return new Wi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function ji(e) { const t = {}; for (const n in e) { t[n] = {}; for (const r in e[n]) { const i = e[n][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i } } return t } function Xi(e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = ji(e[n]); for (const e in r) t[e] = r[e] } return t } const qi = { clone: ji, merge: Xi }; var Yi = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", Zi = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; class Ji extends Xr { constructor(e) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Yi, this.fragmentShader = Zi, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ji(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const n in this.uniforms) { const r = this.uniforms[n].value; r && r.isTexture ? t.uniforms[n] = { type: "t", value: r.toJSON(e).uuid } : r && r.isColor ? t.uniforms[n] = { type: "c", value: r.getHex() } : r && r.isVector2 ? t.uniforms[n] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? t.uniforms[n] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? t.uniforms[n] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[n] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[n] = { type: "m4", value: r.toArray() } : t.uniforms[n] = { value: r } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const n = {}; for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0); return Object.keys(n).length > 0 && (t.extensions = n), t } } Ji.prototype.isShaderMaterial = !0; class Ki extends Nr { constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new lr, this.projectionMatrix = new lr, this.projectionMatrixInverse = new lr } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } Ki.prototype.isCamera = !0; class Qi extends Ki { constructor(e = 50, t = 1, n = .1, r = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = 2 * on * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(.5 * an * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * on * Math.atan(Math.tan(.5 * an * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, n, r, i, s) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * an * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, i = -.5 * r; const s = this.view; if (null !== this.view && this.view.enabled) { const e = s.fullWidth, a = s.fullHeight; i += s.offsetX * r / e, t -= s.offsetY * n / a, r *= s.width / e, n *= s.height / a } const a = this.filmOffset; 0 !== a && (i += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } Qi.prototype.isPerspectiveCamera = !0; const $i = 90, es = 1; class ts extends Nr { constructor(e, t, n) { if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const r = new Qi($i, es, e, t); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Pn(1, 0, 0)), this.add(r); const i = new Qi($i, es, e, t); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Pn(-1, 0, 0)), this.add(i); const s = new Qi($i, es, e, t); s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Pn(0, 1, 0)), this.add(s); const a = new Qi($i, es, e, t); a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Pn(0, -1, 0)), this.add(a); const o = new Qi($i, es, e, t); o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Pn(0, 0, 1)), this.add(o); const l = new Qi($i, es, e, t); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Pn(0, 0, -1)), this.add(l) } update(e, t) { null === this.parent && this.updateMatrixWorld(); const n = this.renderTarget, [r, i, s, a, o, l] = this.children, c = e.xr.enabled, h = e.getRenderTarget(); e.xr.enabled = !1; const u = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, i), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = u, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(h), e.xr.enabled = c } } class ns extends bn { constructor(e, t, n, r, i, s, a, o, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : $, n, r, i, s, a = void 0 !== a ? a : Ae, o, l, c), this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } ns.prototype.isCubeTexture = !0; class rs extends An { constructor(e, t, n) { Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), super(e, e, t), t = t || {}, this.texture = new ns(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : ue, this.texture._needsFlipEnvMap = !1 } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.format = Re, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t" }, r = new Wi(5, 5, 5), i = new Ji({ name: "CubemapFromEquirect", uniforms: ji(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: h, blending: p }); i.uniforms.tEquirect.value = t; const s = new ki(r, i), a = t.minFilter; return t.minFilter === pe && (t.minFilter = ue), new ts(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this } clear(e, t, n, r) { const i = e.getRenderTarget(); for (let i = 0; i < 6; i++)e.setRenderTarget(this, i), e.clear(t, n, r); e.setRenderTarget(i) } } rs.prototype.isWebGLCubeRenderTarget = !0; const is = new Pn, ss = new Pn, as = new vn; class os { constructor(e = new Pn(1, 0, 0), t = 0) { this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, n, r) { return this.normal.set(e, t, n), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, n) { const r = is.subVectors(n, t).cross(ss.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { const n = e.delta(is), r = this.normal.dot(n); if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; const i = -(e.start.dot(this.normal) + this.constant) / r; return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start) } intersectsLine(e) { const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const n = t || as.getNormalMatrix(e), r = this.coplanarPoint(is).applyMatrix4(e), i = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(i), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } os.prototype.isPlane = !0; const ls = new $n, cs = new Pn; class hs { constructor(e = new os, t = new os, n = new os, r = new os, i = new os, s = new os) { this.planes = [e, t, n, r, i, s] } set(e, t, n, r, i, s) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(s), this } copy(e) { const t = this.planes; for (let n = 0; n < 6; n++)t[n].copy(e.planes[n]); return this } setFromProjectionMatrix(e) { const t = this.planes, n = e.elements, r = n[0], i = n[1], s = n[2], a = n[3], o = n[4], l = n[5], c = n[6], h = n[7], u = n[8], d = n[9], p = n[10], m = n[11], f = n[12], g = n[13], v = n[14], y = n[15]; return t[0].setComponents(a - r, h - o, m - u, y - f).normalize(), t[1].setComponents(a + r, h + o, m + u, y + f).normalize(), t[2].setComponents(a + i, h + l, m + d, y + g).normalize(), t[3].setComponents(a - i, h - l, m - d, y - g).normalize(), t[4].setComponents(a - s, h - c, m - p, y - v).normalize(), t[5].setComponents(a + s, h + c, m + p, y + v).normalize(), this } intersectsObject(e) { const t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), ls.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(ls) } intersectsSprite(e) { return ls.center.set(0, 0, 0), ls.radius = .7071067811865476, ls.applyMatrix4(e.matrixWorld), this.intersectsSphere(ls) } intersectsSphere(e) { const t = this.planes, n = e.center, r = -e.radius; for (let e = 0; e < 6; e++) { if (t[e].distanceToPoint(n) < r) return !1 } return !0 } intersectsBox(e) { const t = this.planes; for (let n = 0; n < 6; n++) { const r = t[n]; if (cs.x = r.normal.x > 0 ? e.max.x : e.min.x, cs.y = r.normal.y > 0 ? e.max.y : e.min.y, cs.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(cs) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function us() { let e = null, t = !1, n = null, r = null; function i(t, s) { n(t, s), r = e.requestAnimationFrame(i) } return { start: function () { !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0) }, stop: function () { e.cancelAnimationFrame(r), t = !1 }, setAnimationLoop: function (e) { n = e }, setContext: function (t) { e = t } } } function ds(e, t) { const n = t.isWebGL2, r = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), r.get(e) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); const n = r.get(t); n && (e.deleteBuffer(n.buffer), r.delete(t)) }, update: function (t, i) { if (t.isGLBufferAttribute) { const e = r.get(t); return void ((!e || e.version < t.version) && r.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version })) } t.isInterleavedBufferAttribute && (t = t.data); const s = r.get(t); void 0 === s ? r.set(t, function (t, r) { const i = t.array, s = t.usage, a = e.createBuffer(); e.bindBuffer(r, a), e.bufferData(r, i, s), t.onUploadCallback(); let o = e.FLOAT; return i instanceof Float32Array ? o = e.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? o = e.HALF_FLOAT : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = e.UNSIGNED_SHORT : i instanceof Int16Array ? o = e.SHORT : i instanceof Uint32Array ? o = e.UNSIGNED_INT : i instanceof Int32Array ? o = e.INT : i instanceof Int8Array ? o = e.BYTE : i instanceof Uint8Array ? o = e.UNSIGNED_BYTE : i instanceof Uint8ClampedArray && (o = e.UNSIGNED_BYTE), { buffer: a, type: o, bytesPerElement: i.BYTES_PER_ELEMENT, version: t.version } }(t, i)) : s.version < t.version && (function (t, r, i) { const s = r.array, a = r.updateRange; e.bindBuffer(i, t), -1 === a.count ? e.bufferSubData(i, 0, s) : (n ? e.bufferSubData(i, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(i, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1) }(s.buffer, t, i), s.version = t.version) } } } class ps extends Ti { constructor(e = 1, t = 1, n = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r }; const i = e / 2, s = t / 2, a = Math.floor(n), o = Math.floor(r), l = a + 1, c = o + 1, h = e / a, u = t / o, d = [], p = [], m = [], f = []; for (let e = 0; e < c; e++) { const t = e * u - s; for (let n = 0; n < l; n++) { const r = n * h - i; p.push(r, -t, 0), m.push(0, 0, 1), f.push(n / a), f.push(1 - e / o) } } for (let e = 0; e < o; e++)for (let t = 0; t < a; t++) { const n = t + l * e, r = t + l * (e + 1), i = t + 1 + l * (e + 1), s = t + 1 + l * e; d.push(n, r, s), d.push(r, i, s) } this.setIndex(d), this.setAttribute("position", new di(p, 3)), this.setAttribute("normal", new di(m, 3)), this.setAttribute("uv", new di(f, 2)) } static fromJSON(e) { return new ps(e.width, e.height, e.widthSegments, e.heightSegments) } } const ms = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in GeometricContext geometry ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = transmission.a;\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, fs = { common: { diffuse: { value: new $r(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new vn }, uv2Transform: { value: new vn }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new gn(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new $r(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new $r(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new vn } }, sprite: { diffuse: { value: new $r(16777215) }, opacity: { value: 1 }, center: { value: new gn(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new vn } } }, gs = { basic: { uniforms: Xi([fs.common, fs.specularmap, fs.envmap, fs.aomap, fs.lightmap, fs.fog]), vertexShader: ms.meshbasic_vert, fragmentShader: ms.meshbasic_frag }, lambert: { uniforms: Xi([fs.common, fs.specularmap, fs.envmap, fs.aomap, fs.lightmap, fs.emissivemap, fs.fog, fs.lights, { emissive: { value: new $r(0) } }]), vertexShader: ms.meshlambert_vert, fragmentShader: ms.meshlambert_frag }, phong: { uniforms: Xi([fs.common, fs.specularmap, fs.envmap, fs.aomap, fs.lightmap, fs.emissivemap, fs.bumpmap, fs.normalmap, fs.displacementmap, fs.fog, fs.lights, { emissive: { value: new $r(0) }, specular: { value: new $r(1118481) }, shininess: { value: 30 } }]), vertexShader: ms.meshphong_vert, fragmentShader: ms.meshphong_frag }, standard: { uniforms: Xi([fs.common, fs.envmap, fs.aomap, fs.lightmap, fs.emissivemap, fs.bumpmap, fs.normalmap, fs.displacementmap, fs.roughnessmap, fs.metalnessmap, fs.fog, fs.lights, { emissive: { value: new $r(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ms.meshphysical_vert, fragmentShader: ms.meshphysical_frag }, toon: { uniforms: Xi([fs.common, fs.aomap, fs.lightmap, fs.emissivemap, fs.bumpmap, fs.normalmap, fs.displacementmap, fs.gradientmap, fs.fog, fs.lights, { emissive: { value: new $r(0) } }]), vertexShader: ms.meshtoon_vert, fragmentShader: ms.meshtoon_frag }, matcap: { uniforms: Xi([fs.common, fs.bumpmap, fs.normalmap, fs.displacementmap, fs.fog, { matcap: { value: null } }]), vertexShader: ms.meshmatcap_vert, fragmentShader: ms.meshmatcap_frag }, points: { uniforms: Xi([fs.points, fs.fog]), vertexShader: ms.points_vert, fragmentShader: ms.points_frag }, dashed: { uniforms: Xi([fs.common, fs.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ms.linedashed_vert, fragmentShader: ms.linedashed_frag }, depth: { uniforms: Xi([fs.common, fs.displacementmap]), vertexShader: ms.depth_vert, fragmentShader: ms.depth_frag }, normal: { uniforms: Xi([fs.common, fs.bumpmap, fs.normalmap, fs.displacementmap, { opacity: { value: 1 } }]), vertexShader: ms.meshnormal_vert, fragmentShader: ms.meshnormal_frag }, sprite: { uniforms: Xi([fs.sprite, fs.fog]), vertexShader: ms.sprite_vert, fragmentShader: ms.sprite_frag }, background: { uniforms: { uvTransform: { value: new vn }, t2D: { value: null } }, vertexShader: ms.background_vert, fragmentShader: ms.background_frag }, cube: { uniforms: Xi([fs.envmap, { opacity: { value: 1 } }]), vertexShader: ms.cube_vert, fragmentShader: ms.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ms.equirect_vert, fragmentShader: ms.equirect_frag }, distanceRGBA: { uniforms: Xi([fs.common, fs.displacementmap, { referencePosition: { value: new Pn }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ms.distanceRGBA_vert, fragmentShader: ms.distanceRGBA_frag }, shadow: { uniforms: Xi([fs.lights, fs.fog, { color: { value: new $r(0) }, opacity: { value: 1 } }]), vertexShader: ms.shadow_vert, fragmentShader: ms.shadow_frag } }; function vs(e, t, n, r, i) { const s = new $r(0); let a, o, l = 0, u = null, d = 0, p = null; function m(e, t) { n.buffers.color.setClear(e.r, e.g, e.b, t, i) } return { getClearColor: function () { return s }, setClearColor: function (e, t = 1) { s.set(e), m(s, l = t) }, getClearAlpha: function () { return l }, setClearAlpha: function (e) { m(s, l = e) }, render: function (n, i) { let f = !1, g = !0 === i.isScene ? i.background : null; g && g.isTexture && (g = t.get(g)); const v = e.xr, y = v.getSession && v.getSession(); y && "additive" === y.environmentBlendMode && (g = null), null === g ? m(s, l) : g && g.isColor && (m(g, 1), f = !0), (e.autoClear || f) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), g && (g.isCubeTexture || g.mapping === re) ? (void 0 === o && ((o = new ki(new Wi(1, 1, 1), new Ji({ name: "BackgroundCubeMaterial", uniforms: ji(gs.cube.uniforms), vertexShader: gs.cube.vertexShader, fragmentShader: gs.cube.fragmentShader, side: h, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(o.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(o)), o.material.uniforms.envMap.value = g, o.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, u === g && d === g.version && p === e.toneMapping || (o.material.needsUpdate = !0, u = g, d = g.version, p = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : g && g.isTexture && (void 0 === a && ((a = new ki(new ps(2, 2), new Ji({ name: "BackgroundMaterial", uniforms: ji(gs.background.uniforms), vertexShader: gs.background.vertexShader, fragmentShader: gs.background.fragmentShader, side: c, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(a)), a.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), a.material.uniforms.uvTransform.value.copy(g.matrix), u === g && d === g.version && p === e.toneMapping || (a.material.needsUpdate = !0, u = g, d = g.version, p = e.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) } } } function ys(e, t, n, r) { const i = e.getParameter(e.MAX_VERTEX_ATTRIBS), s = r.isWebGL2 ? null : t.get("OES_vertex_array_object"), a = r.isWebGL2 || null !== s, o = {}, l = d(null); let c = l; function h(t) { return r.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t) } function u(t) { return r.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t) } function d(e) { const t = [], n = [], r = []; for (let e = 0; e < i; e++)t[e] = 0, n[e] = 0, r[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: r, object: e, attributes: {}, index: null } } function p() { const e = c.newAttributes; for (let t = 0, n = e.length; t < n; t++)e[t] = 0 } function m(e) { f(e, 0) } function f(n, i) { const s = c.newAttributes, a = c.enabledAttributes, o = c.attributeDivisors; if (s[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), o[n] !== i) { (r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), o[n] = i } } function g() { const t = c.newAttributes, n = c.enabledAttributes; for (let r = 0, i = n.length; r < i; r++)n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0) } function v(t, n, i, s, a, o) { !0 !== r.isWebGL2 || i !== e.INT && i !== e.UNSIGNED_INT ? e.vertexAttribPointer(t, n, i, s, a, o) : e.vertexAttribIPointer(t, n, i, a, o) } function y() { x(), c !== l && h((c = l).object) } function x() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (i, l, u, y, x) { let _ = !1; if (a) { const t = function (t, n, i) { const a = !0 === i.wireframe; let l = o[t.id]; void 0 === l && (l = {}, o[t.id] = l); let c = l[n.id]; void 0 === c && (c = {}, l[n.id] = c); let h = c[a]; return void 0 === h && (h = d(r.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[a] = h), h }(y, u, l); c !== t && h((c = t).object), (_ = function (e, t) { const n = c.attributes, r = e.attributes; let i = 0; for (const e in r) { const t = n[e], s = r[e]; if (void 0 === t) return !0; if (t.attribute !== s) return !0; if (t.data !== s.data) return !0; i++ } return c.attributesNum !== i || c.index !== t }(y, x)) && function (e, t) { const n = {}, r = e.attributes; let i = 0; for (const e in r) { const t = r[e], s = {}; s.attribute = t, t.data && (s.data = t.data), n[e] = s, i++ } c.attributes = n, c.attributesNum = i, c.index = t }(y, x) } else { const e = !0 === l.wireframe; c.geometry === y.id && c.program === u.id && c.wireframe === e || (c.geometry = y.id, c.program = u.id, c.wireframe = e, _ = !0) } !0 === i.isInstancedMesh && (_ = !0), null !== x && n.update(x, e.ELEMENT_ARRAY_BUFFER), _ && (function (i, s, a, o) { if (!1 === r.isWebGL2 && (i.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return; p(); const l = o.attributes, c = a.getAttributes(), h = s.defaultAttributeValues; for (const t in c) { const r = c[t]; if (r.location >= 0) { let s = l[t]; if (void 0 === s && ("instanceMatrix" === t && i.instanceMatrix && (s = i.instanceMatrix), "instanceColor" === t && i.instanceColor && (s = i.instanceColor)), void 0 !== s) { const t = s.normalized, a = s.itemSize, l = n.get(s); if (void 0 === l) continue; const c = l.buffer, h = l.type, u = l.bytesPerElement; if (s.isInterleavedBufferAttribute) { const n = s.data, l = n.stride, d = s.offset; if (n && n.isInstancedInterleavedBuffer) { for (let e = 0; e < r.locationSize; e++)f(r.location + e, n.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count) } else for (let e = 0; e < r.locationSize; e++)m(r.location + e); e.bindBuffer(e.ARRAY_BUFFER, c); for (let e = 0; e < r.locationSize; e++)v(r.location + e, a / r.locationSize, h, t, l * u, (d + a / r.locationSize * e) * u) } else { if (s.isInstancedBufferAttribute) { for (let e = 0; e < r.locationSize; e++)f(r.location + e, s.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count) } else for (let e = 0; e < r.locationSize; e++)m(r.location + e); e.bindBuffer(e.ARRAY_BUFFER, c); for (let e = 0; e < r.locationSize; e++)v(r.location + e, a / r.locationSize, h, t, a * u, a / r.locationSize * e * u) } } else if (void 0 !== h) { const n = h[t]; if (void 0 !== n) switch (n.length) { case 2: e.vertexAttrib2fv(r.location, n); break; case 3: e.vertexAttrib3fv(r.location, n); break; case 4: e.vertexAttrib4fv(r.location, n); break; default: e.vertexAttrib1fv(r.location, n) } } } } g() }(i, l, u, y), null !== x && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(x).buffer)) }, reset: y, resetDefaultState: x, dispose: function () { y(); for (const e in o) { const t = o[e]; for (const e in t) { const n = t[e]; for (const e in n) u(n[e].object), delete n[e]; delete t[e] } delete o[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === o[e.id]) return; const t = o[e.id]; for (const e in t) { const n = t[e]; for (const e in n) u(n[e].object), delete n[e]; delete t[e] } delete o[e.id] }, releaseStatesOfProgram: function (e) { for (const t in o) { const n = o[t]; if (void 0 === n[e.id]) continue; const r = n[e.id]; for (const e in r) u(r[e].object), delete r[e]; delete n[e.id] } }, initAttributes: p, enableAttribute: m, disableUnusedAttributes: g } } function xs(e, t, n, r) { const i = r.isWebGL2; let s; this.setMode = function (e) { s = e }, this.render = function (t, r) { e.drawArrays(s, t, r), n.update(r, s, 1) }, this.renderInstances = function (r, a, o) { if (0 === o) return; let l, c; if (i) l = e, c = "drawArraysInstanced"; else if (c = "drawArraysInstancedANGLE", null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](s, r, a, o), n.update(a, s, o) } } function _s(e, t, n) { let r; function i(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext; let a = void 0 !== n.precision ? n.precision : "highp"; const o = i(a); o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o); const l = s || t.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), u = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), d = e.getParameter(e.MAX_TEXTURE_SIZE), p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), m = e.getParameter(e.MAX_VERTEX_ATTRIBS), f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), g = e.getParameter(e.MAX_VARYING_VECTORS), v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), y = u > 0, x = s || t.has("OES_texture_float"); return { isWebGL2: s, drawBuffers: l, getMaxAnisotropy: function () { if (void 0 !== r) return r; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const n = t.get("EXT_texture_filter_anisotropic"); r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r }, getMaxPrecision: i, precision: a, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: u, maxTextureSize: d, maxCubemapSize: p, maxAttributes: m, maxVertexUniforms: f, maxVaryings: g, maxFragmentUniforms: v, vertexTextures: y, floatFragmentTextures: x, floatVertexTextures: y && x, maxSamples: s ? e.getParameter(e.MAX_SAMPLES) : 0 } } function bs(e) { const t = this; let n = null, r = 0, i = !1, s = !1; const a = new os, o = new vn, l = { value: null, needsUpdate: !1 }; function c() { l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0 } function h(e, n, r, i) { const s = null !== e ? e.length : 0; let c = null; if (0 !== s) { if (c = l.value, !0 !== i || null === c) { const t = r + 4 * s, i = n.matrixWorldInverse; o.getNormalMatrix(i), (null === c || c.length < t) && (c = new Float32Array(t)); for (let t = 0, n = r; t !== s; ++t, n += 4)a.copy(e[t]).applyMatrix4(i, o), a.normal.toArray(c, n), c[n + 3] = a.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = s, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, s) { const a = 0 !== e.length || t || 0 !== r || i; return i = t, n = h(e, s, 0), r = e.length, a }, this.beginShadows = function () { s = !0, h(null) }, this.endShadows = function () { s = !1, c() }, this.setState = function (t, a, o) { const u = t.clippingPlanes, d = t.clipIntersection, p = t.clipShadows, m = e.get(t); if (!i || null === u || 0 === u.length || s && !p) s ? h(null) : c(); else { const e = s ? 0 : r, t = 4 * e; let i = m.clippingState || null; l.value = i, i = h(u, a, t, o); for (let e = 0; e !== t; ++e)i[e] = n[e]; m.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e } } } function ws(e) { let t = new WeakMap; function n(e, t) { return t === te ? e.mapping = $ : t === ne && (e.mapping = ee), e } function r(e) { const n = e.target; n.removeEventListener("dispose", r); const i = t.get(n); void 0 !== i && (t.delete(n), i.dispose()) } return { get: function (i) { if (i && i.isTexture && !1 === i.isRenderTargetTexture) { const s = i.mapping; if (s === te || s === ne) { if (t.has(i)) return n(t.get(i).texture, i.mapping); { const s = i.image; if (s && s.height > 0) { const a = e.getRenderTarget(), o = new rs(s.height / 2); return o.fromEquirectangularTexture(e, i), t.set(i, o), e.setRenderTarget(a), i.addEventListener("dispose", r), n(o.texture, i.mapping) } return null } } } return i }, dispose: function () { t = new WeakMap } } } gs.physical = { uniforms: Xi([gs.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new gn(1, 1) }, clearcoatNormalMap: { value: null }, sheenTint: { value: new $r(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new gn }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationTint: { value: new $r(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularTint: { value: new $r(1, 1, 1) }, specularTintMap: { value: null } }]), vertexShader: ms.meshphysical_vert, fragmentShader: ms.meshphysical_frag }; class Ms extends Ki { constructor(e = -1, t = 1, n = 1, r = -1, i = .1, s = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, n, r, i, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let i = n - e, s = n + e, a = r + t, o = r - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; s = (i += e * this.view.offsetX) + e * this.view.width, o = (a -= t * this.view.offsetY) - t * this.view.height } this.projectionMatrix.makeOrthographic(i, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } Ms.prototype.isOrthographicCamera = !0; class Ts extends Ji { constructor(e) { super(e), this.type = "RawShaderMaterial" } } Ts.prototype.isRawShaderMaterial = !0; const Es = 4, Ss = 8, As = Math.pow(2, Ss), Rs = [.125, .215, .35, .446, .526, .582], Ls = Ss - Es + 1 + Rs.length, Cs = 20, Ps = { [Ht]: 0, [zt]: 1, [kt]: 2, [Wt]: 3, [jt]: 4, [Xt]: 5, [Gt]: 6 }, Is = new Ms, { _lodPlanes: Ns, _sizeLods: Ds, _sigmas: Fs } = Vs(), Os = new $r; let Us = null; const Bs = (1 + Math.sqrt(5)) / 2, Hs = 1 / Bs, zs = [new Pn(1, 1, 1), new Pn(-1, 1, 1), new Pn(1, 1, -1), new Pn(-1, 1, -1), new Pn(0, Bs, Hs), new Pn(0, Bs, -Hs), new Pn(Hs, 0, Bs), new Pn(-Hs, 0, Bs), new Pn(Bs, Hs, 0), new Pn(-Bs, Hs, 0)]; class Gs { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function (e) { const t = new Float32Array(e), n = new Pn(0, 1, 0); return new Ts({ name: "SphericalGaussianBlur", defines: { n: e }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: t }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n }, inputEncoding: { value: Ps[Ht] }, outputEncoding: { value: Ps[Ht] } }, vertexShader: Ys(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Zs()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: p, depthTest: !1, depthWrite: !1 }) }(Cs), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, n = .1, r = 100) { Us = this._renderer.getRenderTarget(); const i = this._allocateTargets(); return this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i } fromEquirectangular(e) { return this._fromTexture(e) } fromCubemap(e) { return this._fromTexture(e) } compileCubemapShader() { null === this._cubemapShader && (this._cubemapShader = qs(), this._compileMaterial(this._cubemapShader)) } compileEquirectangularShader() { null === this._equirectShader && (this._equirectShader = Xs(), this._compileMaterial(this._equirectShader)) } dispose() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let e = 0; e < Ns.length; e++)Ns[e].dispose() } _cleanup(e) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Us), e.scissorTest = !1, js(e, 0, 0, e.width, e.height) } _fromTexture(e) { Us = this._renderer.getRenderTarget(); const t = this._allocateTargets(e); return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t } _allocateTargets(e) { const t = { magFilter: le, minFilter: le, generateMipmaps: !1, type: me, format: Pe, encoding: ks(e) ? e.encoding : kt, depthBuffer: !1 }, n = Ws(t); return n.depthBuffer = !e, this._pingPongRenderTarget = Ws(t), n } _compileMaterial(e) { const t = new ki(Ns[0], e); this._renderer.compile(t, Is) } _sceneToCubeUV(e, t, n, r) { const i = new Qi(90, 1, t, n), s = [1, -1, 1, 1, 1, 1], a = [1, 1, 1, -1, -1, -1], o = this._renderer, l = o.autoClear, c = o.outputEncoding, u = o.toneMapping; o.getClearColor(Os), o.toneMapping = X, o.outputEncoding = Ht, o.autoClear = !1; const d = new ei({ name: "PMREM.Background", side: h, depthWrite: !1, depthTest: !1 }), p = new ki(new Wi, d); let m = !1; const f = e.background; f ? f.isColor && (d.color.copy(f), e.background = null, m = !0) : (d.color.copy(Os), m = !0); for (let t = 0; t < 6; t++) { const n = t % 3; 0 == n ? (i.up.set(0, s[t], 0), i.lookAt(a[t], 0, 0)) : 1 == n ? (i.up.set(0, 0, s[t]), i.lookAt(0, a[t], 0)) : (i.up.set(0, s[t], 0), i.lookAt(0, 0, a[t])), js(r, n * As, t > 2 ? As : 0, As, As), o.setRenderTarget(r), m && o.render(p, i), o.render(e, i) } p.geometry.dispose(), p.material.dispose(), o.toneMapping = u, o.outputEncoding = c, o.autoClear = l, e.background = f } _textureToCubeUV(e, t) { const n = this._renderer; e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = qs()) : null == this._equirectShader && (this._equirectShader = Xs()); const r = e.isCubeTexture ? this._cubemapShader : this._equirectShader, i = new ki(Ns[0], r), s = r.uniforms; s.envMap.value = e, e.isCubeTexture || s.texelSize.value.set(1 / e.image.width, 1 / e.image.height), s.inputEncoding.value = Ps[e.encoding], s.outputEncoding.value = Ps[t.texture.encoding], js(t, 0, 0, 3 * As, 2 * As), n.setRenderTarget(t), n.render(i, Is) } _applyPMREM(e) { const t = this._renderer, n = t.autoClear; t.autoClear = !1; for (let t = 1; t < Ls; t++) { const n = Math.sqrt(Fs[t] * Fs[t] - Fs[t - 1] * Fs[t - 1]), r = zs[(t - 1) % zs.length]; this._blur(e, t - 1, t, n, r) } t.autoClear = n } _blur(e, t, n, r, i) { const s = this._pingPongRenderTarget; this._halfBlur(e, s, t, n, r, "latitudinal", i), this._halfBlur(s, e, n, n, r, "longitudinal", i) } _halfBlur(e, t, n, r, i, s, a) { const o = this._renderer, l = this._blurMaterial; "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!"); const c = new ki(Ns[r], l), h = l.uniforms, u = Ds[n] - 1, d = isFinite(i) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * Cs - 1), p = i / d, m = isFinite(i) ? 1 + Math.floor(3 * p) : Cs; m > Cs && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Cs}`); const f = []; let g = 0; for (let e = 0; e < Cs; ++e) { const t = e / p, n = Math.exp(-t * t / 2); f.push(n), 0 == e ? g += n : e < m && (g += 2 * n) } for (let e = 0; e < f.length; e++)f[e] = f[e] / g; h.envMap.value = e.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a), h.dTheta.value = d, h.mipInt.value = Ss - n, h.inputEncoding.value = Ps[e.texture.encoding], h.outputEncoding.value = Ps[e.texture.encoding]; const v = Ds[r]; js(t, 3 * Math.max(0, As - 2 * v), (0 === r ? 0 : 2 * As) + 2 * v * (r > Ss - Es ? r - Ss + Es : 0), 3 * v, 2 * v), o.setRenderTarget(t), o.render(c, Is) } } function ks(e) { return void 0 !== e && e.type === me && (e.encoding === Ht || e.encoding === zt || e.encoding === Gt) } function Vs() { const e = [], t = [], n = []; let r = Ss; for (let i = 0; i < Ls; i++) { const s = Math.pow(2, r); t.push(s); let a = 1 / s; i > Ss - Es ? a = Rs[i - Ss + Es - 1] : 0 == i && (a = 0), n.push(a); const o = 1 / (s - 1), l = -o / 2, c = 1 + o / 2, h = [l, l, c, l, c, c, l, l, c, c, l, c], u = 6, d = 6, p = 3, m = 2, f = 1, g = new Float32Array(p * d * u), v = new Float32Array(m * d * u), y = new Float32Array(f * d * u); for (let e = 0; e < u; e++) { const t = e % 3 * 2 / 3 - 1, n = e > 2 ? 0 : -1, r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0]; g.set(r, p * d * e), v.set(h, m * d * e); const i = [e, e, e, e, e, e]; y.set(i, f * d * e) } const x = new Ti; x.setAttribute("position", new ri(g, p)), x.setAttribute("uv", new ri(v, m)), x.setAttribute("faceIndex", new ri(y, f)), e.push(x), r > Es && r-- } return { _lodPlanes: e, _sizeLods: t, _sigmas: n } } function Ws(e) { const t = new An(3 * As, 3 * As, e); return t.texture.mapping = re, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t } function js(e, t, n, r, i) { e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i) } function Xs() { const e = new gn(1, 1); return new Ts({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: e }, inputEncoding: { value: Ps[Ht] }, outputEncoding: { value: Ps[Ht] } }, vertexShader: Ys(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Zs()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: p, depthTest: !1, depthWrite: !1 }) } function qs() { return new Ts({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Ps[Ht] }, outputEncoding: { value: Ps[Ht] } }, vertexShader: Ys(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Zs()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: p, depthTest: !1, depthWrite: !1 }) } function Ys() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function Zs() { return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t" } function Js(e) { let t = new WeakMap, n = null; function r(e) { const n = e.target; n.removeEventListener("dispose", r); const i = t.get(n); void 0 !== i && (t.delete(n), i.dispose()) } return { get: function (i) { if (i && i.isTexture && !1 === i.isRenderTargetTexture) { const s = i.mapping, a = s === te || s === ne, o = s === $ || s === ee; if (a || o) { if (t.has(i)) return t.get(i).texture; { const s = i.image; if (a && s && s.height > 0 || o && s && function (e) { let t = 0; for (let n = 0; n < 6; n++)void 0 !== e[n] && t++; return 6 === t }(s)) { const s = e.getRenderTarget(); null === n && (n = new Gs(e)); const o = a ? n.fromEquirectangular(i) : n.fromCubemap(i); return t.set(i, o), e.setRenderTarget(s), i.addEventListener("dispose", r), o.texture } return null } } } return i }, dispose: function () { t = new WeakMap, null !== n && (n.dispose(), n = null) } } } function Ks(e) { const t = {}; function n(n) { if (void 0 !== t[n]) return t[n]; let r; switch (n) { case "WEBGL_depth_texture": r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = e.getExtension(n) }return t[n] = r, r } return { has: function (e) { return null !== n(e) }, init: function (e) { e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function (e) { const t = n(e); return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function Qs(e, t, n, r) { const i = {}, s = new WeakMap; function a(e) { const o = e.target; null !== o.index && t.remove(o.index); for (const e in o.attributes) t.remove(o.attributes[e]); o.removeEventListener("dispose", a), delete i[o.id]; const l = s.get(o); l && (t.remove(l), s.delete(o)), r.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries-- } function o(e) { const n = [], r = e.index, i = e.attributes.position; let a = 0; if (null !== r) { const e = r.array; a = r.version; for (let t = 0, r = e.length; t < r; t += 3) { const r = e[t + 0], i = e[t + 1], s = e[t + 2]; n.push(r, i, i, s, s, r) } } else { const e = i.array; a = i.version; for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) { const e = t + 0, r = t + 1, i = t + 2; n.push(e, r, r, i, i, e) } } const o = new (mi(n) > 65535 ? hi : li)(n, 1); o.version = a; const l = s.get(e); l && t.remove(l), s.set(e, o) } return { get: function (e, t) { return !0 === i[t.id] ? t : (t.addEventListener("dispose", a), i[t.id] = !0, n.memory.geometries++, t) }, update: function (n) { const r = n.attributes; for (const n in r) t.update(r[n], e.ARRAY_BUFFER); const i = n.morphAttributes; for (const n in i) { const r = i[n]; for (let n = 0, i = r.length; n < i; n++)t.update(r[n], e.ARRAY_BUFFER) } }, getWireframeAttribute: function (e) { const t = s.get(e); if (t) { const n = e.index; null !== n && t.version < n.version && o(e) } else o(e); return s.get(e) } } } function $s(e, t, n, r) { const i = r.isWebGL2; let s, a, o; this.setMode = function (e) { s = e }, this.setIndex = function (e) { a = e.type, o = e.bytesPerElement }, this.render = function (t, r) { e.drawElements(s, r, a, t * o), n.update(r, s, 1) }, this.renderInstances = function (r, l, c) { if (0 === c) return; let h, u; if (i) h = e, u = "drawElementsInstanced"; else if (u = "drawElementsInstancedANGLE", null === (h = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); h[u](s, l, a, r * o, c), n.update(l, s, c) } } function ea(e) { const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (n, r, i) { switch (t.calls++, r) { case e.TRIANGLES: t.triangles += i * (n / 3); break; case e.LINES: t.lines += i * (n / 2); break; case e.LINE_STRIP: t.lines += i * (n - 1); break; case e.LINE_LOOP: t.lines += i * n; break; case e.POINTS: t.points += i * n; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", r) } } } } function ta(e, t) { return e[0] - t[0] } function na(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function ra(e) { const t = {}, n = new Float32Array(8), r = []; for (let e = 0; e < 8; e++)r[e] = [e, 0]; return { update: function (i, s, a, o) { const l = i.morphTargetInfluences, c = void 0 === l ? 0 : l.length; let h = t[s.id]; if (void 0 === h || h.length !== c) { h = []; for (let e = 0; e < c; e++)h[e] = [e, 0]; t[s.id] = h } for (let e = 0; e < c; e++) { const t = h[e]; t[0] = e, t[1] = l[e] } h.sort(na); for (let e = 0; e < 8; e++)e < c && h[e][1] ? (r[e][0] = h[e][0], r[e][1] = h[e][1]) : (r[e][0] = Number.MAX_SAFE_INTEGER, r[e][1] = 0); r.sort(ta); const u = s.morphAttributes.position, d = s.morphAttributes.normal; let p = 0; for (let e = 0; e < 8; e++) { const t = r[e], i = t[0], a = t[1]; i !== Number.MAX_SAFE_INTEGER && a ? (u && s.getAttribute("morphTarget" + e) !== u[i] && s.setAttribute("morphTarget" + e, u[i]), d && s.getAttribute("morphNormal" + e) !== d[i] && s.setAttribute("morphNormal" + e, d[i]), n[e] = a, p += a) : (u && !0 === s.hasAttribute("morphTarget" + e) && s.deleteAttribute("morphTarget" + e), d && !0 === s.hasAttribute("morphNormal" + e) && s.deleteAttribute("morphNormal" + e), n[e] = 0) } const m = s.morphTargetsRelative ? 1 : 1 - p; o.getUniforms().setValue(e, "morphTargetBaseInfluence", m), o.getUniforms().setValue(e, "morphTargetInfluences", n) } } } function ia(e, t, n, r) { let i = new WeakMap; function s(e) { const t = e.target; t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor) } return { update: function (a) { const o = r.render.frame, l = a.geometry, c = t.get(a, l); return i.get(c) !== o && (t.update(c), i.set(c, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), n.update(a.instanceMatrix, e.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, e.ARRAY_BUFFER)), c }, dispose: function () { i = new WeakMap } } } class sa extends bn { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = le, this.minFilter = le, this.wrapR = ae, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } sa.prototype.isDataTexture2DArray = !0; class aa extends bn { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = le, this.minFilter = le, this.wrapR = ae, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } aa.prototype.isDataTexture3D = !0; const oa = new bn, la = new sa, ca = new aa, ha = new ns, ua = [], da = [], pa = new Float32Array(16), ma = new Float32Array(9), fa = new Float32Array(4); function ga(e, t, n) { const r = e[0]; if (r <= 0 || r > 0) return e; const i = t * n; let s = ua[i]; if (void 0 === s && (s = new Float32Array(i), ua[i] = s), 0 !== t) { r.toArray(s, 0); for (let r = 1, i = 0; r !== t; ++r)i += n, e[r].toArray(s, i) } return s } function va(e, t) { if (e.length !== t.length) return !1; for (let n = 0, r = e.length; n < r; n++)if (e[n] !== t[n]) return !1; return !0 } function ya(e, t) { for (let n = 0, r = t.length; n < r; n++)e[n] = t[n] } function xa(e, t) { let n = da[t]; void 0 === n && (n = new Int32Array(t), da[t] = n); for (let r = 0; r !== t; ++r)n[r] = e.allocateTextureUnit(); return n } function _a(e, t) { const n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function ba(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (va(n, t)) return; e.uniform2fv(this.addr, t), ya(n, t) } } function wa(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else { if (va(n, t)) return; e.uniform3fv(this.addr, t), ya(n, t) } } function Ma(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (va(n, t)) return; e.uniform4fv(this.addr, t), ya(n, t) } } function Ta(e, t) { const n = this.cache, r = t.elements; if (void 0 === r) { if (va(n, t)) return; e.uniformMatrix2fv(this.addr, !1, t), ya(n, t) } else { if (va(n, r)) return; fa.set(r), e.uniformMatrix2fv(this.addr, !1, fa), ya(n, r) } } function Ea(e, t) { const n = this.cache, r = t.elements; if (void 0 === r) { if (va(n, t)) return; e.uniformMatrix3fv(this.addr, !1, t), ya(n, t) } else { if (va(n, r)) return; ma.set(r), e.uniformMatrix3fv(this.addr, !1, ma), ya(n, r) } } function Sa(e, t) { const n = this.cache, r = t.elements; if (void 0 === r) { if (va(n, t)) return; e.uniformMatrix4fv(this.addr, !1, t), ya(n, t) } else { if (va(n, r)) return; pa.set(r), e.uniformMatrix4fv(this.addr, !1, pa), ya(n, r) } } function Aa(e, t) { const n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function Ra(e, t) { const n = this.cache; va(n, t) || (e.uniform2iv(this.addr, t), ya(n, t)) } function La(e, t) { const n = this.cache; va(n, t) || (e.uniform3iv(this.addr, t), ya(n, t)) } function Ca(e, t) { const n = this.cache; va(n, t) || (e.uniform4iv(this.addr, t), ya(n, t)) } function Pa(e, t) { const n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function Ia(e, t) { const n = this.cache; va(n, t) || (e.uniform2uiv(this.addr, t), ya(n, t)) } function Na(e, t) { const n = this.cache; va(n, t) || (e.uniform3uiv(this.addr, t), ya(n, t)) } function Da(e, t) { const n = this.cache; va(n, t) || (e.uniform4uiv(this.addr, t), ya(n, t)) } function Fa(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || oa, i) } function Oa(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || ca, i) } function Ua(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || ha, i) } function Ba(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || la, i) } function Ha(e, t) { e.uniform1fv(this.addr, t) } function za(e, t) { const n = ga(t, this.size, 2); e.uniform2fv(this.addr, n) } function Ga(e, t) { const n = ga(t, this.size, 3); e.uniform3fv(this.addr, n) } function ka(e, t) { const n = ga(t, this.size, 4); e.uniform4fv(this.addr, n) } function Va(e, t) { const n = ga(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, n) } function Wa(e, t) { const n = ga(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, n) } function ja(e, t) { const n = ga(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, n) } function Xa(e, t) { e.uniform1iv(this.addr, t) } function qa(e, t) { e.uniform2iv(this.addr, t) } function Ya(e, t) { e.uniform3iv(this.addr, t) } function Za(e, t) { e.uniform4iv(this.addr, t) } function Ja(e, t) { e.uniform1uiv(this.addr, t) } function Ka(e, t) { e.uniform2uiv(this.addr, t) } function Qa(e, t) { e.uniform3uiv(this.addr, t) } function $a(e, t) { e.uniform4uiv(this.addr, t) } function eo(e, t, n) { const r = t.length, i = xa(n, r); e.uniform1iv(this.addr, i); for (let e = 0; e !== r; ++e)n.safeSetTexture2D(t[e] || oa, i[e]) } function to(e, t, n) { const r = t.length, i = xa(n, r); e.uniform1iv(this.addr, i); for (let e = 0; e !== r; ++e)n.safeSetTextureCube(t[e] || ha, i[e]) } function no(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) { switch (e) { case 5126: return _a; case 35664: return ba; case 35665: return wa; case 35666: return Ma; case 35674: return Ta; case 35675: return Ea; case 35676: return Sa; case 5124: case 35670: return Aa; case 35667: case 35671: return Ra; case 35668: case 35672: return La; case 35669: case 35673: return Ca; case 5125: return Pa; case 36294: return Ia; case 36295: return Na; case 36296: return Da; case 35678: case 36198: case 36298: case 36306: case 35682: return Fa; case 35679: case 36299: case 36307: return Oa; case 35680: case 36300: case 36308: case 36293: return Ua; case 36289: case 36303: case 36311: case 36292: return Ba } }(t.type) } function ro(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return Ha; case 35664: return za; case 35665: return Ga; case 35666: return ka; case 35674: return Va; case 35675: return Wa; case 35676: return ja; case 5124: case 35670: return Xa; case 35667: case 35671: return qa; case 35668: case 35672: return Ya; case 35669: case 35673: return Za; case 5125: return Ja; case 36294: return Ka; case 36295: return Qa; case 36296: return $a; case 35678: case 36198: case 36298: case 36306: case 35682: return eo; case 35680: case 36300: case 36308: case 36293: return to } }(t.type) } function io(e) { this.id = e, this.seq = [], this.map = {} } ro.prototype.updateCache = function (e) { const t = this.cache; e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), ya(t, e) }, io.prototype.setValue = function (e, t, n) { const r = this.seq; for (let i = 0, s = r.length; i !== s; ++i) { const s = r[i]; s.setValue(e, t[s.id], n) } }; const so = /(\w+)(\])?(\[|\.)?/g; function ao(e, t) { e.seq.push(t), e.map[t.id] = t } function oo(e, t, n) { const r = e.name, i = r.length; for (so.lastIndex = 0; ;) { const s = so.exec(r), a = so.lastIndex; let o = s[1]; const l = "]" === s[2], c = s[3]; if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === i) { ao(n, void 0 === c ? new no(o, e, t) : new ro(o, e, t)); break } { let e = n.map[o]; void 0 === e && ao(n, e = new io(o)), n = e } } } function lo(e, t) { this.seq = [], this.map = {}; const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let r = 0; r < n; ++r) { const n = e.getActiveUniform(t, r); oo(n, e.getUniformLocation(t, n.name), this) } } function co(e, t, n) { const r = e.createShader(t); return e.shaderSource(r, n), e.compileShader(r), r } lo.prototype.setValue = function (e, t, n, r) { const i = this.map[t]; void 0 !== i && i.setValue(e, n, r) }, lo.prototype.setOptional = function (e, t, n) { const r = t[n]; void 0 !== r && this.setValue(e, n, r) }, lo.upload = function (e, t, n, r) { for (let i = 0, s = t.length; i !== s; ++i) { const s = t[i], a = n[s.id]; !1 !== a.needsUpdate && s.setValue(e, a.value, r) } }, lo.seqWithValue = function (e, t) { const n = []; for (let r = 0, i = e.length; r !== i; ++r) { const i = e[r]; i.id in t && n.push(i) } return n }; let ho = 0; function uo(e) { switch (e) { case Ht: return ["Linear", "( value )"]; case zt: return ["sRGB", "( value )"]; case kt: return ["RGBE", "( value )"]; case Wt: return ["RGBM", "( value, 7.0 )"]; case jt: return ["RGBM", "( value, 16.0 )"]; case Xt: return ["RGBD", "( value, 256.0 )"]; case Gt: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case Vt: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } } function po(e, t, n) { const r = e.getShaderParameter(t, e.COMPILE_STATUS), i = e.getShaderInfoLog(t).trim(); return r && "" === i ? "" : n.toUpperCase() + "\n\n" + i + "\n\n" + function (e) { const t = e.split("\n"); for (let e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") }(e.getShaderSource(t)) } function mo(e, t) { const n = uo(t); return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function fo(e, t) { const n = uo(t); return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function go(e, t) { let n; switch (t) { case q: n = "Linear"; break; case Y: n = "Reinhard"; break; case Z: n = "OptimizedCineon"; break; case J: n = "ACESFilmic"; break; case K: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function vo(e) { return "" !== e } function yo(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function xo(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const _o = /^[ \t]*#include +<([\w\d./]+)>/gm; function bo(e) { return e.replace(_o, wo) } function wo(e, t) { const n = ms[t]; if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">"); return bo(n) } const Mo = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, To = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Eo(e) { return e.replace(To, Ao).replace(Mo, So) } function So(e, t, n, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ao(e, t, n, r) } function Ao(e, t, n, r) { let i = ""; for (let e = parseInt(t); e < parseInt(n); e++)i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return i } function Ro(e) { let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Lo(e, t, n, r) { const i = e.getContext(), s = n.defines; let c = n.vertexShader, h = n.fragmentShader; const u = function (e) { let t = "SHADOWMAP_TYPE_BASIC"; return e.shadowMapType === a ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === o ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === l && (t = "SHADOWMAP_TYPE_VSM"), t }(n), d = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case $: case ee: t = "ENVMAP_TYPE_CUBE"; break; case re: case ie: t = "ENVMAP_TYPE_CUBE_UV" }return t }(n), p = function (e) { let t = "ENVMAP_MODE_REFLECTION"; if (e.envMap) switch (e.envMapMode) { case ee: case ie: t = "ENVMAP_MODE_REFRACTION" }return t }(n), m = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case V: t = "ENVMAP_BLENDING_MULTIPLY"; break; case W: t = "ENVMAP_BLENDING_MIX"; break; case j: t = "ENVMAP_BLENDING_ADD" }return t }(n), f = e.gammaFactor > 0 ? e.gammaFactor : 1, g = n.isWebGL2 ? "" : function (e) { return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(vo).join("\n") }(n), v = function (e) { const t = []; for (const n in e) { const r = e[n]; !1 !== r && t.push("#define " + n + " " + r) } return t.join("\n") }(s), y = i.createProgram(); let x, _, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? ((x = [v].filter(vo).join("\n")).length > 0 && (x += "\n"), (_ = [g, v].filter(vo).join("\n")).length > 0 && (_ += "\n")) : (x = [Ro(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(vo).join("\n"), _ = [g, Ro(n), "#define SHADER_NAME " + n.shaderName, v, "#define GAMMA_FACTOR " + f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheenTint ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== X ? "#define TONE_MAPPING" : "", n.toneMapping !== X ? ms.tonemapping_pars_fragment : "", n.toneMapping !== X ? go("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === Ae ? "#define OPAQUE" : "", ms.encodings_pars_fragment, n.map ? mo("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? mo("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? mo("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? mo("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularTintMap ? mo("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "", n.lightMap ? mo("lightMapTexelToLinear", n.lightMapEncoding) : "", fo("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(vo).join("\n")), c = xo(c = yo(c = bo(c), n), n), h = xo(h = yo(h = bo(h), n), n), c = Eo(c), h = Eo(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", x = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, _ = ["#define varying in", n.glslVersion === tn ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === tn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _); const w = b + x + c, M = b + _ + h, T = co(i, i.VERTEX_SHADER, w), E = co(i, i.FRAGMENT_SHADER, M); if (i.attachShader(y, T), i.attachShader(y, E), void 0 !== n.index0AttributeName ? i.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y), e.debug.checkShaderErrors) { const e = i.getProgramInfoLog(y).trim(), t = i.getShaderInfoLog(T).trim(), n = i.getShaderInfoLog(E).trim(); let r = !0, s = !0; if (!1 === i.getProgramParameter(y, i.LINK_STATUS)) { r = !1; const t = po(i, T, "vertex"), n = po(i, E, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, i.VALIDATE_STATUS) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n) } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (s = !1); s && (this.diagnostics = { runnable: r, programLog: e, vertexShader: { log: t, prefix: x }, fragmentShader: { log: n, prefix: _ } }) } let S, A; return i.deleteShader(T), i.deleteShader(E), this.getUniforms = function () { return void 0 === S && (S = new lo(i, y)), S }, this.getAttributes = function () { return void 0 === A && (A = function (e, t) { const n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES); for (let i = 0; i < r; i++) { const r = e.getActiveAttrib(t, i), s = r.name; let a = 1; r.type === e.FLOAT_MAT2 && (a = 2), r.type === e.FLOAT_MAT3 && (a = 3), r.type === e.FLOAT_MAT4 && (a = 4), n[s] = { type: r.type, location: e.getAttribLocation(t, s), locationSize: a } } return n }(i, y)), A }, this.destroy = function () { r.releaseStatesOfProgram(this), i.deleteProgram(y), this.program = void 0 }, this.name = n.shaderName, this.id = ho++, this.cacheKey = t, this.usedTimes = 1, this.program = y, this.vertexShader = T, this.fragmentShader = E, this } function Co(e, t, n, r, i, s, a) { const o = [], l = i.isWebGL2, c = i.logarithmicDepthBuffer, d = i.floatVertexTextures, p = i.maxVertexUniforms, m = i.vertexTextures; let f = i.precision; const g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, v = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheenTint", "transmission", "transmissionMap", "thicknessMap"]; function y(e) { let t; return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = Ht, t } return { getParameters: function (s, o, v, x, _) { const b = x.fog, w = s.isMeshStandardMaterial ? x.environment : null, M = (s.isMeshStandardMaterial ? n : t).get(s.envMap || w), T = g[s.type], E = _.isSkinnedMesh ? function (e) { const t = e.skeleton.bones; if (d) return 1024; { const e = p, n = Math.floor((e - 20) / 4), r = Math.min(n, t.length); return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r } }(_) : 0; let S, A; if (null !== s.precision && (f = i.getMaxPrecision(s.precision)) !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", f, "instead."), T) { const e = gs[T]; S = e.vertexShader, A = e.fragmentShader } else S = s.vertexShader, A = s.fragmentShader; const R = e.getRenderTarget(), L = s.alphaTest > 0, C = s.clearcoat > 0; return { isWebGL2: l, shaderID: T, shaderName: s.type, vertexShader: S, fragmentShader: A, defines: s.defines, isRawShaderMaterial: !0 === s.isRawShaderMaterial, glslVersion: s.glslVersion, precision: f, instancing: !0 === _.isInstancedMesh, instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor, supportsVertexTextures: m, outputEncoding: null !== R ? y(R.texture) : e.outputEncoding, map: !!s.map, mapEncoding: y(s.map), matcap: !!s.matcap, matcapEncoding: y(s.matcap), envMap: !!M, envMapMode: M && M.mapping, envMapEncoding: y(M), envMapCubeUV: !!M && (M.mapping === re || M.mapping === ie), lightMap: !!s.lightMap, lightMapEncoding: y(s.lightMap), aoMap: !!s.aoMap, emissiveMap: !!s.emissiveMap, emissiveMapEncoding: y(s.emissiveMap), bumpMap: !!s.bumpMap, normalMap: !!s.normalMap, objectSpaceNormalMap: s.normalMapType === Jt, tangentSpaceNormalMap: s.normalMapType === Zt, clearcoat: C, clearcoatMap: C && !!s.clearcoatMap, clearcoatRoughnessMap: C && !!s.clearcoatRoughnessMap, clearcoatNormalMap: C && !!s.clearcoatNormalMap, displacementMap: !!s.displacementMap, roughnessMap: !!s.roughnessMap, metalnessMap: !!s.metalnessMap, specularMap: !!s.specularMap, specularIntensityMap: !!s.specularIntensityMap, specularTintMap: !!s.specularTintMap, specularTintMapEncoding: y(s.specularTintMap), alphaMap: !!s.alphaMap, alphaTest: L, gradientMap: !!s.gradientMap, sheenTint: !!s.sheenTint && (s.sheenTint.r > 0 || s.sheenTint.g > 0 || s.sheenTint.b > 0), transmission: s.transmission > 0, transmissionMap: !!s.transmissionMap, thicknessMap: !!s.thicknessMap, combine: s.combine, vertexTangents: !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent, vertexColors: s.vertexColors, vertexAlphas: !0 === s.vertexColors && !!_.geometry && !!_.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize, vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap), uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap || !s.displacementMap), fog: !!b, useFog: s.fog, fogExp2: b && b.isFogExp2, flatShading: !!s.flatShading, sizeAttenuation: s.sizeAttenuation, logarithmicDepthBuffer: c, skinning: !0 === _.isSkinnedMesh && E > 0, maxBones: E, useVertexTexture: d, morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position, morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, format: s.format, dithering: s.dithering, shadowMapEnabled: e.shadowMap.enabled && v.length > 0, shadowMapType: e.shadowMap.type, toneMapping: s.toneMapped ? e.toneMapping : X, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: s.premultipliedAlpha, doubleSided: s.side === u, flipSided: s.side === h, depthPacking: void 0 !== s.depthPacking && s.depthPacking, index0AttributeName: s.index0AttributeName, extensionDerivatives: s.extensions && s.extensions.derivatives, extensionFragDepth: s.extensions && s.extensions.fragDepth, extensionDrawBuffers: s.extensions && s.extensions.drawBuffers, extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD, rendererExtensionFragDepth: l || r.has("EXT_frag_depth"), rendererExtensionDrawBuffers: l || r.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: l || r.has("EXT_shader_texture_lod"), customProgramCacheKey: s.customProgramCacheKey() } }, getProgramCacheKey: function (t) { const n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]); if (!1 === t.isRawShaderMaterial) { for (let e = 0; e < v.length; e++)n.push(t[v[e]]); n.push(e.outputEncoding), n.push(e.gammaFactor) } return n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { const t = g[e.type]; let n; if (t) { const e = gs[t]; n = qi.clone(e.uniforms) } else n = e.uniforms; return n }, acquireProgram: function (t, n) { let r; for (let e = 0, t = o.length; e < t; e++) { const t = o[e]; if (t.cacheKey === n) { ++(r = t).usedTimes; break } } return void 0 === r && (r = new Lo(e, n, t, s), o.push(r)), r }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = o.indexOf(e); o[t] = o[o.length - 1], o.pop(), e.destroy() } }, programs: o } } function Po() { let e = new WeakMap; return { get: function (t) { let n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function (t) { e.delete(t) }, update: function (t, n, r) { e.get(t)[n] = r }, dispose: function () { e = new WeakMap } } } function Io(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function No(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function Do(e) { const t = []; let n = 0; const r = [], i = [], s = [], a = { id: -1 }; function o(r, i, s, o, l, c) { let h = t[n]; const u = e.get(s); return void 0 === h ? (h = { id: r.id, object: r, geometry: i, material: s, program: u.program || a, groupOrder: o, renderOrder: r.renderOrder, z: l, group: c }, t[n] = h) : (h.id = r.id, h.object = r, h.geometry = i, h.material = s, h.program = u.program || a, h.groupOrder = o, h.renderOrder = r.renderOrder, h.z = l, h.group = c), n++, h } return { opaque: r, transmissive: i, transparent: s, init: function () { n = 0, r.length = 0, i.length = 0, s.length = 0 }, push: function (e, t, n, a, l, c) { const h = o(e, t, n, a, l, c); n.transmission > 0 ? i.push(h) : !0 === n.transparent ? s.push(h) : r.push(h) }, unshift: function (e, t, n, a, l, c) { const h = o(e, t, n, a, l, c); n.transmission > 0 ? i.unshift(h) : !0 === n.transparent ? s.unshift(h) : r.unshift(h) }, finish: function () { for (let e = n, r = t.length; e < r; e++) { const n = t[e]; if (null === n.id) break; n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null } }, sort: function (e, t) { r.length > 1 && r.sort(e || Io), i.length > 1 && i.sort(t || No), s.length > 1 && s.sort(t || No) } } } function Fo(e) { let t = new WeakMap; return { get: function (n, r) { let i; return !1 === t.has(n) ? (i = new Do(e), t.set(n, [i])) : r >= t.get(n).length ? (i = new Do(e), t.get(n).push(i)) : i = t.get(n)[r], i }, dispose: function () { t = new WeakMap } } } function Oo() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": n = { direction: new Pn, color: new $r }; break; case "SpotLight": n = { position: new Pn, direction: new Pn, color: new $r, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new Pn, color: new $r, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new Pn, skyColor: new $r, groundColor: new $r }; break; case "RectAreaLight": n = { color: new $r, position: new Pn, halfWidth: new Pn, halfHeight: new Pn } }return e[t.id] = n, n } } } let Uo = 0; function Bo(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function Ho(e, t) { const n = new Oo, r = function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new gn }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new gn, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = n, n } } }(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let e = 0; e < 9; e++)i.probe.push(new Pn); const s = new Pn, a = new lr, o = new lr; return { setup: function (s, a) { let o = 0, l = 0, c = 0; for (let e = 0; e < 9; e++)i.probe[e].set(0, 0, 0); let h = 0, u = 0, d = 0, p = 0, m = 0, f = 0, g = 0, v = 0; s.sort(Bo); const y = !0 !== a ? Math.PI : 1; for (let e = 0, t = s.length; e < t; e++) { const t = s[e], a = t.color, x = t.intensity, _ = t.distance, b = t.shadow && t.shadow.map ? t.shadow.map.texture : null; if (t.isAmbientLight) o += a.r * x * y, l += a.g * x * y, c += a.b * x * y; else if (t.isLightProbe) for (let e = 0; e < 9; e++)i.probe[e].addScaledVector(t.sh.coefficients[e], x); else if (t.isDirectionalLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity * y), t.castShadow) { const e = t.shadow, n = r.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.directionalShadow[h] = n, i.directionalShadowMap[h] = b, i.directionalShadowMatrix[h] = t.shadow.matrix, f++ } i.directional[h] = e, h++ } else if (t.isSpotLight) { const e = n.get(t); if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(x * y), e.distance = _, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) { const e = t.shadow, n = r.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.spotShadow[d] = n, i.spotShadowMap[d] = b, i.spotShadowMatrix[d] = t.shadow.matrix, v++ } i.spot[d] = e, d++ } else if (t.isRectAreaLight) { const e = n.get(t); e.color.copy(a).multiplyScalar(x), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), i.rectArea[p] = e, p++ } else if (t.isPointLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity * y), e.distance = t.distance, e.decay = t.decay, t.castShadow) { const e = t.shadow, n = r.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, i.pointShadow[u] = n, i.pointShadowMap[u] = b, i.pointShadowMatrix[u] = t.shadow.matrix, g++ } i.point[u] = e, u++ } else if (t.isHemisphereLight) { const e = n.get(t); e.skyColor.copy(t.color).multiplyScalar(x * y), e.groundColor.copy(t.groundColor).multiplyScalar(x * y), i.hemi[m] = e, m++ } } p > 0 && (t.isWebGL2 ? (i.rectAreaLTC1 = fs.LTC_FLOAT_1, i.rectAreaLTC2 = fs.LTC_FLOAT_2) : !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = fs.LTC_FLOAT_1, i.rectAreaLTC2 = fs.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = fs.LTC_HALF_1, i.rectAreaLTC2 = fs.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = o, i.ambient[1] = l, i.ambient[2] = c; const x = i.hash; x.directionalLength === h && x.pointLength === u && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === m && x.numDirectionalShadows === f && x.numPointShadows === g && x.numSpotShadows === v || (i.directional.length = h, i.spot.length = d, i.rectArea.length = p, i.point.length = u, i.hemi.length = m, i.directionalShadow.length = f, i.directionalShadowMap.length = f, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = f, i.pointShadowMatrix.length = g, i.spotShadowMatrix.length = v, x.directionalLength = h, x.pointLength = u, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = m, x.numDirectionalShadows = f, x.numPointShadows = g, x.numSpotShadows = v, i.version = Uo++) }, setupView: function (e, t) { let n = 0, r = 0, l = 0, c = 0, h = 0; const u = t.matrixWorldInverse; for (let t = 0, d = e.length; t < d; t++) { const d = e[t]; if (d.isDirectionalLight) { const e = i.directional[n]; e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), n++ } else if (d.isSpotLight) { const e = i.spot[l]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), l++ } else if (d.isRectAreaLight) { const e = i.rectArea[c]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), o.identity(), a.copy(d.matrixWorld), a.premultiply(u), o.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++ } else if (d.isPointLight) { const e = i.point[r]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), r++ } else if (d.isHemisphereLight) { const e = i.hemi[h]; e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), e.direction.normalize(), h++ } } }, state: i } } function zo(e, t) { const n = new Ho(e, t), r = [], i = []; return { init: function () { r.length = 0, i.length = 0 }, state: { lightsArray: r, shadowsArray: i, lights: n }, setupLights: function (e) { n.setup(r, e) }, setupLightsView: function (e) { n.setupView(r, e) }, pushLight: function (e) { r.push(e) }, pushShadow: function (e) { i.push(e) } } } function Go(e, t) { let n = new WeakMap; return { get: function (r, i = 0) { let s; return !1 === n.has(r) ? (s = new zo(e, t), n.set(r, [s])) : i >= n.get(r).length ? (s = new zo(e, t), n.get(r).push(s)) : s = n.get(r)[i], s }, dispose: function () { n = new WeakMap } } } class ko extends Xr { constructor(e) { super(), this.type = "MeshDepthMaterial", this.depthPacking = qt, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } ko.prototype.isMeshDepthMaterial = !0; class Vo extends Xr { constructor(e) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Pn, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } Vo.prototype.isMeshDistanceMaterial = !0; var Wo = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", jo = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"; function Xo(e, t, n) { let r = new hs; const i = new gn, s = new gn, o = new Sn, d = new ko({ depthPacking: Yt }), m = new Vo, f = {}, g = n.maxTextureSize, v = { 0: h, 1: c, 2: u }, y = new Ji({ uniforms: { shadow_pass: { value: null }, resolution: { value: new gn }, radius: { value: 4 }, samples: { value: 8 } }, vertexShader: jo, fragmentShader: Wo }), x = y.clone(); x.defines.HORIZONTAL_PASS = 1; const _ = new Ti; _.setAttribute("position", new ri(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const b = new ki(_, y), w = this; function M(n, r) { const i = t.update(b); y.uniforms.shadow_pass.value = n.map.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, y.uniforms.samples.value = n.blurSamples, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, i, y, b, null), x.uniforms.shadow_pass.value = n.mapPass.texture, x.uniforms.resolution.value = n.mapSize, x.uniforms.radius.value = n.radius, x.uniforms.samples.value = n.blurSamples, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, i, x, b, null) } function T(t, n, r, i, s, a, o) { let c = null; const h = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial; if (c = void 0 !== h ? h : !0 === i.isPointLight ? m : d, e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length || r.displacementMap && 0 !== r.displacementScale || r.alphaMap && r.alphaTest > 0) { const e = c.uuid, t = r.uuid; let n = f[e]; void 0 === n && (n = {}, f[e] = n); let i = n[t]; void 0 === i && (i = c.clone(), n[t] = i), c = i } return c.visible = r.visible, c.wireframe = r.wireframe, c.side = o === l ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : v[r.side], c.alphaMap = r.alphaMap, c.alphaTest = r.alphaTest, c.clipShadows = r.clipShadows, c.clippingPlanes = r.clippingPlanes, c.clipIntersection = r.clipIntersection, c.displacementMap = r.displacementMap, c.displacementScale = r.displacementScale, c.displacementBias = r.displacementBias, c.wireframeLinewidth = r.wireframeLinewidth, c.linewidth = r.linewidth, !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), c.nearDistance = s, c.farDistance = a), c } function E(n, i, s, a, o) { if (!1 === n.visible) return; if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && o === l) && (!n.frustumCulled || r.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld); const r = t.update(n), i = n.material; if (Array.isArray(i)) { const t = r.groups; for (let l = 0, c = t.length; l < c; l++) { const c = t[l], h = i[c.materialIndex]; if (h && h.visible) { const t = T(n, 0, h, a, s.near, s.far, o); e.renderBufferDirect(s, null, r, t, n, c) } } } else if (i.visible) { const t = T(n, 0, i, a, s.near, s.far, o); e.renderBufferDirect(s, null, r, t, n, null) } } const c = n.children; for (let e = 0, t = c.length; e < t; e++)E(c[e], i, s, a, o) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = a, this.render = function (t, n, a) { if (!1 === w.enabled) return; if (!1 === w.autoUpdate && !1 === w.needsUpdate) return; if (0 === t.length) return; const c = e.getRenderTarget(), h = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), d = e.state; d.setBlending(p), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (let c = 0, h = t.length; c < h; c++) { const h = t[c], u = h.shadow; if (void 0 === u) { console.warn("THREE.WebGLShadowMap:", h, "has no shadow."); continue } if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue; i.copy(u.mapSize); const p = u.getFrameExtents(); if (i.multiply(p), s.copy(u.mapSize), (i.x > g || i.y > g) && (i.x > g && (s.x = Math.floor(g / p.x), i.x = s.x * p.x, u.mapSize.x = s.x), i.y > g && (s.y = Math.floor(g / p.y), i.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === l) { const e = { minFilter: ue, magFilter: ue, format: Re }; u.map = new An(i.x, i.y, e), u.map.texture.name = h.name + ".shadowMap", u.mapPass = new An(i.x, i.y, e), u.camera.updateProjectionMatrix() } if (null === u.map) { const e = { minFilter: le, magFilter: le, format: Re }; u.map = new An(i.x, i.y, e), u.map.texture.name = h.name + ".shadowMap", u.camera.updateProjectionMatrix() } e.setRenderTarget(u.map), e.clear(); const m = u.getViewportCount(); for (let e = 0; e < m; e++) { const t = u.getViewport(e); o.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(o), u.updateMatrices(h, e), r = u.getFrustum(), E(n, a, u.camera, h, this.type) } u.isPointLightShadow || this.type !== l || M(u, a), u.needsUpdate = !1 } w.needsUpdate = !1, e.setRenderTarget(c, h, u) } } function qo(e, t, n) { const a = n.isWebGL2; const o = new function () { let t = !1; const n = new Sn; let r = null; const i = new Sn(0, 0, 0, 0); return { setMask: function (n) { r === n || t || (e.colorMask(n, n, n, n), r = n) }, setLocked: function (e) { t = e }, setClear: function (t, r, s, a, o) { !0 === o && (t *= a, r *= a, s *= a), n.set(t, r, s, a), !1 === i.equals(n) && (e.clearColor(t, r, s, a), i.copy(n)) }, reset: function () { t = !1, r = null, i.set(-1, 0, 0, 0) } } }, l = new function () { let t = !1, n = null, r = null, i = null; return { setTest: function (t) { t ? ye(e.DEPTH_TEST) : xe(e.DEPTH_TEST) }, setMask: function (r) { n === r || t || (e.depthMask(r), n = r) }, setFunc: function (t) { if (r !== t) { if (t) switch (t) { case F: e.depthFunc(e.NEVER); break; case O: e.depthFunc(e.ALWAYS); break; case U: e.depthFunc(e.LESS); break; case B: e.depthFunc(e.LEQUAL); break; case H: e.depthFunc(e.EQUAL); break; case z: e.depthFunc(e.GEQUAL); break; case G: e.depthFunc(e.GREATER); break; case k: e.depthFunc(e.NOTEQUAL); break; default: e.depthFunc(e.LEQUAL) } else e.depthFunc(e.LEQUAL); r = t } }, setLocked: function (e) { t = e }, setClear: function (t) { i !== t && (e.clearDepth(t), i = t) }, reset: function () { t = !1, n = null, r = null, i = null } } }, c = new function () { let t = !1, n = null, r = null, i = null, s = null, a = null, o = null, l = null, c = null; return { setTest: function (n) { t || (n ? ye(e.STENCIL_TEST) : xe(e.STENCIL_TEST)) }, setMask: function (r) { n === r || t || (e.stencilMask(r), n = r) }, setFunc: function (t, n, a) { r === t && i === n && s === a || (e.stencilFunc(t, n, a), r = t, i = n, s = a) }, setOp: function (t, n, r) { a === t && o === n && l === r || (e.stencilOp(t, n, r), a = t, o = n, l = r) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, n = null, r = null, i = null, s = null, a = null, o = null, l = null, c = null } } }; let d = {}, V = null, W = {}, j = null, X = !1, q = null, Y = null, Z = null, J = null, K = null, Q = null, $ = null, ee = !1, te = null, ne = null, re = null, ie = null, se = null; const ae = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let oe = !1, le = 0; const ce = e.getParameter(e.VERSION); -1 !== ce.indexOf("WebGL") ? (le = parseFloat(/^WebGL (\d)/.exec(ce)[1]), oe = le >= 1) : -1 !== ce.indexOf("OpenGL ES") && (le = parseFloat(/^OpenGL ES (\d)/.exec(ce)[1]), oe = le >= 2); let he = null, ue = {}; const de = e.getParameter(e.SCISSOR_BOX), pe = e.getParameter(e.VIEWPORT), me = (new Sn).fromArray(de), fe = (new Sn).fromArray(pe); function ge(t, n, r) { const i = new Uint8Array(4), s = e.createTexture(); e.bindTexture(t, s), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST); for (let t = 0; t < r; t++)e.texImage2D(n + t, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, i); return s } const ve = {}; function ye(t) { !0 !== d[t] && (e.enable(t), d[t] = !0) } function xe(t) { !1 !== d[t] && (e.disable(t), d[t] = !1) } ve[e.TEXTURE_2D] = ge(e.TEXTURE_2D, e.TEXTURE_2D, 1), ve[e.TEXTURE_CUBE_MAP] = ge(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), ye(e.DEPTH_TEST), l.setFunc(B), Me(!1), Te(i), ye(e.CULL_FACE), we(p); const _e = { [x]: e.FUNC_ADD, [_]: e.FUNC_SUBTRACT, [b]: e.FUNC_REVERSE_SUBTRACT }; if (a) _e[w] = e.MIN, _e[M] = e.MAX; else { const e = t.get("EXT_blend_minmax"); null !== e && (_e[w] = e.MIN_EXT, _e[M] = e.MAX_EXT) } const be = { [T]: e.ZERO, [E]: e.ONE, [S]: e.SRC_COLOR, [R]: e.SRC_ALPHA, [D]: e.SRC_ALPHA_SATURATE, [I]: e.DST_COLOR, [C]: e.DST_ALPHA, [A]: e.ONE_MINUS_SRC_COLOR, [L]: e.ONE_MINUS_SRC_ALPHA, [N]: e.ONE_MINUS_DST_COLOR, [P]: e.ONE_MINUS_DST_ALPHA }; function we(t, n, r, i, s, a, o, l) { if (t !== p) { if (!1 === X && (ye(e.BLEND), X = !0), t === y) s = s || n, a = a || r, o = o || i, n === Y && s === K || (e.blendEquationSeparate(_e[n], _e[s]), Y = n, K = s), r === Z && i === J && a === Q && o === $ || (e.blendFuncSeparate(be[r], be[i], be[a], be[o]), Z = r, J = i, Q = a, $ = o), q = t, ee = null; else if (t !== q || l !== ee) { if (Y === x && K === x || (e.blendEquation(e.FUNC_ADD), Y = x, K = x), l) switch (t) { case m: e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case f: e.blendFunc(e.ONE, e.ONE); break; case g: e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA); break; case v: e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case m: e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case f: e.blendFunc(e.SRC_ALPHA, e.ONE); break; case g: e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR); break; case v: e.blendFunc(e.ZERO, e.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }Z = null, J = null, Q = null, $ = null, q = t, ee = l } } else !0 === X && (xe(e.BLEND), X = !1) } function Me(t) { te !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), te = t) } function Te(t) { t !== r ? (ye(e.CULL_FACE), t !== ne && (t === i ? e.cullFace(e.BACK) : t === s ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : xe(e.CULL_FACE), ne = t } function Ee(t, n, r) { t ? (ye(e.POLYGON_OFFSET_FILL), ie === n && se === r || (e.polygonOffset(n, r), ie = n, se = r)) : xe(e.POLYGON_OFFSET_FILL) } function Se(t) { void 0 === t && (t = e.TEXTURE0 + ae - 1), he !== t && (e.activeTexture(t), he = t) } return { buffers: { color: o, depth: l, stencil: c }, enable: ye, disable: xe, bindFramebuffer: function (t, n) { return null === n && null !== V && (n = V), W[t] !== n && (e.bindFramebuffer(t, n), W[t] = n, a && (t === e.DRAW_FRAMEBUFFER && (W[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (W[e.DRAW_FRAMEBUFFER] = n)), !0) }, bindXRFramebuffer: function (t) { t !== V && (e.bindFramebuffer(e.FRAMEBUFFER, t), V = t) }, useProgram: function (t) { return j !== t && (e.useProgram(t), j = t, !0) }, setBlending: we, setMaterial: function (t, n) { t.side === u ? xe(e.CULL_FACE) : ye(e.CULL_FACE); let r = t.side === h; n && (r = !r), Me(r), t.blending === m && !1 === t.transparent ? we(p) : we(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), l.setFunc(t.depthFunc), l.setTest(t.depthTest), l.setMask(t.depthWrite), o.setMask(t.colorWrite); const i = t.stencilWrite; c.setTest(i), i && (c.setMask(t.stencilWriteMask), c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Ee(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? ye(e.SAMPLE_ALPHA_TO_COVERAGE) : xe(e.SAMPLE_ALPHA_TO_COVERAGE) }, setFlipSided: Me, setCullFace: Te, setLineWidth: function (t) { t !== re && (oe && e.lineWidth(t), re = t) }, setPolygonOffset: Ee, setScissorTest: function (t) { t ? ye(e.SCISSOR_TEST) : xe(e.SCISSOR_TEST) }, activeTexture: Se, bindTexture: function (t, n) { null === he && Se(); let r = ue[he]; void 0 === r && (r = { type: void 0, texture: void 0 }, ue[he] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || ve[t]), r.type = t, r.texture = n) }, unbindTexture: function () { const t = ue[he]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === me.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), me.copy(t)) }, viewport: function (t) { !1 === fe.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), fe.copy(t)) }, reset: function () { e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), !0 === a && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), d = {}, he = null, ue = {}, V = null, W = {}, j = null, X = !1, q = null, Y = null, Z = null, J = null, K = null, Q = null, $ = null, ee = !1, te = null, ne = null, re = null, ie = null, se = null, me.set(0, 0, e.canvas.width, e.canvas.height), fe.set(0, 0, e.canvas.width, e.canvas.height), o.reset(), l.reset(), c.reset() } } } function Yo(e, t, n, r, i, s, a) { const o = i.isWebGL2, l = i.maxTextures, c = i.maxCubemapSize, h = i.maxTextureSize, u = i.maxSamples, d = new WeakMap; let p, m = !1; try { m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function f(e, t) { return m ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function g(e, t, n, r) { let i = 1; if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const r = t ? mn : Math.floor, s = r(i * e.width), a = r(i * e.height); void 0 === p && (p = f(s, a)); const o = n ? f(s, a) : p; return o.width = s, o.height = a, o.getContext("2d").drawImage(e, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."), o } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function v(e) { return dn(e.width) && dn(e.height) } function y(e, t) { return e.generateMipmaps && t && e.minFilter !== le && e.minFilter !== ue } function x(t, n, i, s, a = 1) { e.generateMipmap(t), r.get(n).__maxMipLevel = Math.log2(Math.max(i, s, a)) } function _(n, r, i) { if (!1 === o) return r; if (null !== n) { if (void 0 !== e[n]) return e[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let s = r; return r === e.RED && (i === e.FLOAT && (s = e.R32F), i === e.HALF_FLOAT && (s = e.R16F), i === e.UNSIGNED_BYTE && (s = e.R8)), r === e.RGB && (i === e.FLOAT && (s = e.RGB32F), i === e.HALF_FLOAT && (s = e.RGB16F), i === e.UNSIGNED_BYTE && (s = e.RGB8)), r === e.RGBA && (i === e.FLOAT && (s = e.RGBA32F), i === e.HALF_FLOAT && (s = e.RGBA16F), i === e.UNSIGNED_BYTE && (s = e.RGBA8)), s !== e.R16F && s !== e.R32F && s !== e.RGBA16F && s !== e.RGBA32F || t.get("EXT_color_buffer_float"), s } function b(t) { return t === le || t === ce || t === he ? e.NEAREST : e.LINEAR } function w(t) { const n = t.target; n.removeEventListener("dispose", w), function (t) { const n = r.get(t); if (void 0 === n.__webglInit) return; e.deleteTexture(n.__webglTexture), r.remove(t) }(n), n.isVideoTexture && d.delete(n), a.memory.textures-- } function M(t) { const n = t.target; n.removeEventListener("dispose", M), function (t) { const n = t.texture, i = r.get(t), s = r.get(n); if (!t) return; void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--); t.depthTexture && t.depthTexture.dispose(); if (t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++)e.deleteFramebuffer(i.__webglFramebuffer[t]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t]); else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && e.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer); if (t.isWebGLMultipleRenderTargets) for (let t = 0, i = n.length; t < i; t++) { const i = r.get(n[t]); i.__webglTexture && (e.deleteTexture(i.__webglTexture), a.memory.textures--), r.remove(n[t]) } r.remove(n), r.remove(t) }(n) } let T = 0; function E(t, i) { const s = r.get(t); if (t.isVideoTexture && function (e) { const t = a.render.frame; d.get(e) !== t && (d.set(e, t), e.update()) }(t), t.version > 0 && s.__version !== t.version) { const e = t.image; if (void 0 === e) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== e.complete) return void P(s, t, i); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_2D, s.__webglTexture) } function S(t, i) { const a = r.get(t); t.version > 0 && a.__version !== t.version ? function (t, r, i) { if (6 !== r.image.length) return; C(t, r), n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, r.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, r.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE); const a = r && (r.isCompressedTexture || r.image[0].isCompressedTexture), l = r.image[0] && r.image[0].isDataTexture, h = []; for (let e = 0; e < 6; e++)h[e] = a || l ? l ? r.image[e].image : r.image[e] : g(r.image[e], !1, !0, c); const u = h[0], d = v(u) || o, p = s.convert(r.format), m = s.convert(r.type), f = _(r.internalFormat, p, m); let b; if (L(e.TEXTURE_CUBE_MAP, r, d), a) { for (let t = 0; t < 6; t++) { b = h[t].mipmaps; for (let i = 0; i < b.length; i++) { const s = b[i]; r.format !== Re && r.format !== Ae ? null !== p ? n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, f, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, f, s.width, s.height, 0, p, m, s.data) } } t.__maxMipLevel = b.length - 1 } else { b = r.mipmaps; for (let t = 0; t < 6; t++)if (l) { n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data); for (let r = 0; r < b.length; r++) { const i = b[r], s = i.image[t].image; n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, f, s.width, s.height, 0, p, m, s.data) } } else { n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, f, p, m, h[t]); for (let r = 0; r < b.length; r++) { const i = b[r]; n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, f, p, m, i.image[t]) } } t.__maxMipLevel = b.length } y(r, d) && x(e.TEXTURE_CUBE_MAP, r, u.width, u.height); t.__version = r.version, r.onUpdate && r.onUpdate(r) }(a, t, i) : (n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_CUBE_MAP, a.__webglTexture)) } const A = { [se]: e.REPEAT, [ae]: e.CLAMP_TO_EDGE, [oe]: e.MIRRORED_REPEAT }, R = { [le]: e.NEAREST, [ce]: e.NEAREST_MIPMAP_NEAREST, [he]: e.NEAREST_MIPMAP_LINEAR, [ue]: e.LINEAR, [de]: e.LINEAR_MIPMAP_NEAREST, [pe]: e.LINEAR_MIPMAP_LINEAR }; function L(n, s, a) { if (a ? (e.texParameteri(n, e.TEXTURE_WRAP_S, A[s.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, A[s.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, A[s.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, R[s.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, R[s.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE), s.wrapS === ae && s.wrapT === ae || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, e.TEXTURE_MAG_FILTER, b(s.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, b(s.minFilter)), s.minFilter !== le && s.minFilter !== ue && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) { const a = t.get("EXT_texture_filter_anisotropic"); if (s.type === _e && !1 === t.has("OES_texture_float_linear")) return; if (!1 === o && s.type === be && !1 === t.has("OES_texture_half_float_linear")) return; (s.anisotropy > 1 || r.get(s).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy) } } function C(t, n) { void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", w), t.__webglTexture = e.createTexture(), a.memory.textures++) } function P(t, r, i) { let a = e.TEXTURE_2D; r.isDataTexture2DArray && (a = e.TEXTURE_2D_ARRAY), r.isDataTexture3D && (a = e.TEXTURE_3D), C(t, r), n.activeTexture(e.TEXTURE0 + i), n.bindTexture(a, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, r.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, r.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE); const l = function (e) { return !o && (e.wrapS !== ae || e.wrapT !== ae || e.minFilter !== le && e.minFilter !== ue) }(r) && !1 === v(r.image), c = g(r.image, l, !1, h), u = v(c) || o, d = s.convert(r.format); let p, m = s.convert(r.type), f = _(r.internalFormat, d, m); L(a, r, u); const b = r.mipmaps; if (r.isDepthTexture) f = e.DEPTH_COMPONENT, o ? f = r.type === _e ? e.DEPTH_COMPONENT32F : r.type === xe ? e.DEPTH_COMPONENT24 : r.type === Ee ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : r.type === _e && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Ie && f === e.DEPTH_COMPONENT && r.type !== ve && r.type !== xe && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = ve, m = s.convert(r.type)), r.format === Ne && f === e.DEPTH_COMPONENT && (f = e.DEPTH_STENCIL, r.type !== Ee && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Ee, m = s.convert(r.type))), n.texImage2D(e.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, null); else if (r.isDataTexture) if (b.length > 0 && u) { for (let t = 0, r = b.length; t < r; t++)p = b[t], n.texImage2D(e.TEXTURE_2D, t, f, p.width, p.height, 0, d, m, p.data); r.generateMipmaps = !1, t.__maxMipLevel = b.length - 1 } else n.texImage2D(e.TEXTURE_2D, 0, f, c.width, c.height, 0, d, m, c.data), t.__maxMipLevel = 0; else if (r.isCompressedTexture) { for (let t = 0, i = b.length; t < i; t++)p = b[t], r.format !== Re && r.format !== Ae ? null !== d ? n.compressedTexImage2D(e.TEXTURE_2D, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(e.TEXTURE_2D, t, f, p.width, p.height, 0, d, m, p.data); t.__maxMipLevel = b.length - 1 } else if (r.isDataTexture2DArray) n.texImage3D(e.TEXTURE_2D_ARRAY, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), t.__maxMipLevel = 0; else if (r.isDataTexture3D) n.texImage3D(e.TEXTURE_3D, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), t.__maxMipLevel = 0; else if (b.length > 0 && u) { for (let t = 0, r = b.length; t < r; t++)p = b[t], n.texImage2D(e.TEXTURE_2D, t, f, d, m, p); r.generateMipmaps = !1, t.__maxMipLevel = b.length - 1 } else n.texImage2D(e.TEXTURE_2D, 0, f, d, m, c), t.__maxMipLevel = 0; y(r, u) && x(a, r, c.width, c.height), t.__version = r.version, r.onUpdate && r.onUpdate(r) } function I(t, i, a, o, l) { const c = s.convert(a.format), h = s.convert(a.type), u = _(a.internalFormat, c, h); l === e.TEXTURE_3D || l === e.TEXTURE_2D_ARRAY ? n.texImage3D(l, 0, u, i.width, i.height, i.depth, 0, c, h, null) : n.texImage2D(l, 0, u, i.width, i.height, 0, c, h, null), n.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, o, l, r.get(a).__webglTexture, 0), n.bindFramebuffer(e.FRAMEBUFFER, null) } function N(t, n, r) { if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer) { let i = e.DEPTH_COMPONENT16; if (r) { const t = n.depthTexture; t && t.isDepthTexture && (t.type === _e ? i = e.DEPTH_COMPONENT32F : t.type === xe && (i = e.DEPTH_COMPONENT24)); const r = F(n); e.renderbufferStorageMultisample(e.RENDERBUFFER, r, i, n.width, n.height) } else e.renderbufferStorage(e.RENDERBUFFER, i, n.width, n.height); e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t) } else if (n.depthBuffer && n.stencilBuffer) { if (r) { const t = F(n); e.renderbufferStorageMultisample(e.RENDERBUFFER, t, e.DEPTH24_STENCIL8, n.width, n.height) } else e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height); e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t) } else { const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture, i = s.convert(t.format), a = s.convert(t.type), o = _(t.internalFormat, i, a); if (r) { const t = F(n); e.renderbufferStorageMultisample(e.RENDERBUFFER, t, o, n.width, n.height) } else e.renderbufferStorage(e.RENDERBUFFER, o, n.width, n.height) } e.bindRenderbuffer(e.RENDERBUFFER, null) } function D(t) { const i = r.get(t), s = !0 === t.isWebGLCubeRenderTarget; if (t.depthTexture) { if (s) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, i) { if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(e.FRAMEBUFFER, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), E(i.depthTexture, 0); const s = r.get(i.depthTexture).__webglTexture; if (i.depthTexture.format === Ie) e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0); else { if (i.depthTexture.format !== Ne) throw new Error("Unknown depthTexture format"); e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0) } }(i.__webglFramebuffer, t) } else if (s) { i.__webglDepthbuffer = []; for (let r = 0; r < 6; r++)n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = e.createRenderbuffer(), N(i.__webglDepthbuffer[r], t, !1) } else n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), N(i.__webglDepthbuffer, t, !1); n.bindFramebuffer(e.FRAMEBUFFER, null) } function F(e) { return o && e.isWebGLMultisampleRenderTarget ? Math.min(u, e.samples) : 0 } let O = !1, U = !1; this.allocateTextureUnit = function () { const e = T; return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), T += 1, e }, this.resetTextureUnits = function () { T = 0 }, this.setTexture2D = E, this.setTexture2DArray = function (t, i) { const s = r.get(t); t.version > 0 && s.__version !== t.version ? P(s, t, i) : (n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture)) }, this.setTexture3D = function (t, i) { const s = r.get(t); t.version > 0 && s.__version !== t.version ? P(s, t, i) : (n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_3D, s.__webglTexture)) }, this.setTextureCube = S, this.setupRenderTarget = function (t) { const l = t.texture, c = r.get(t), h = r.get(l); t.addEventListener("dispose", M), !0 !== t.isWebGLMultipleRenderTargets && (h.__webglTexture = e.createTexture(), h.__version = l.version, a.memory.textures++); const u = !0 === t.isWebGLCubeRenderTarget, d = !0 === t.isWebGLMultipleRenderTargets, p = !0 === t.isWebGLMultisampleRenderTarget, m = l.isDataTexture3D || l.isDataTexture2DArray, f = v(t) || o; if (!o || l.format !== Ae || l.type !== _e && l.type !== be || (l.format = Re, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) { c.__webglFramebuffer = []; for (let t = 0; t < 6; t++)c.__webglFramebuffer[t] = e.createFramebuffer() } else if (c.__webglFramebuffer = e.createFramebuffer(), d) if (i.drawBuffers) { const n = t.texture; for (let t = 0, i = n.length; t < i; t++) { const i = r.get(n[t]); void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), a.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (p) if (o) { c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, c.__webglColorRenderbuffer); const r = s.convert(l.format), i = s.convert(l.type), a = _(l.internalFormat, r, i), o = F(t); e.renderbufferStorageMultisample(e.RENDERBUFFER, o, a, t.width, t.height), n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, c.__webglColorRenderbuffer), e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), N(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (u) { n.bindTexture(e.TEXTURE_CUBE_MAP, h.__webglTexture), L(e.TEXTURE_CUBE_MAP, l, f); for (let n = 0; n < 6; n++)I(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n); y(l, f) && x(e.TEXTURE_CUBE_MAP, l, t.width, t.height), n.unbindTexture() } else if (d) { const i = t.texture; for (let s = 0, a = i.length; s < a; s++) { const a = i[s], o = r.get(a); n.bindTexture(e.TEXTURE_2D, o.__webglTexture), L(e.TEXTURE_2D, a, f), I(c.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + s, e.TEXTURE_2D), y(a, f) && x(e.TEXTURE_2D, a, t.width, t.height) } n.unbindTexture() } else { let r = e.TEXTURE_2D; m && (o ? r = l.isDataTexture3D ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(r, h.__webglTexture), L(r, l, f), I(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, r), y(l, f) && x(r, l, t.width, t.height, t.depth), n.unbindTexture() } t.depthBuffer && D(t) }, this.updateRenderTargetMipmap = function (t) { const i = v(t) || o, s = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]; for (let a = 0, o = s.length; a < o; a++) { const o = s[a]; if (y(o, i)) { const i = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, s = r.get(o).__webglTexture; n.bindTexture(i, s), x(i, o, t.width, t.height), n.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (o) { const i = t.width, s = t.height; let a = e.COLOR_BUFFER_BIT; t.depthBuffer && (a |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && (a |= e.STENCIL_BUFFER_BIT); const o = r.get(t); n.bindFramebuffer(e.READ_FRAMEBUFFER, o.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, o.__webglFramebuffer), e.blitFramebuffer(0, 0, i, s, 0, 0, i, s, a, e.NEAREST), n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, o.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), O = !0), e = e.texture), E(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLCubeRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), U = !0), e = e.texture), S(e, t) } } function Zo(e, t, n) { const r = n.isWebGL2; return { convert: function (n) { let i; if (n === me) return e.UNSIGNED_BYTE; if (n === we) return e.UNSIGNED_SHORT_4_4_4_4; if (n === Me) return e.UNSIGNED_SHORT_5_5_5_1; if (n === Te) return e.UNSIGNED_SHORT_5_6_5; if (n === fe) return e.BYTE; if (n === ge) return e.SHORT; if (n === ve) return e.UNSIGNED_SHORT; if (n === ye) return e.INT; if (n === xe) return e.UNSIGNED_INT; if (n === _e) return e.FLOAT; if (n === be) return r ? e.HALF_FLOAT : null !== (i = t.get("OES_texture_half_float")) ? i.HALF_FLOAT_OES : null; if (n === Se) return e.ALPHA; if (n === Ae) return e.RGB; if (n === Re) return e.RGBA; if (n === Le) return e.LUMINANCE; if (n === Ce) return e.LUMINANCE_ALPHA; if (n === Ie) return e.DEPTH_COMPONENT; if (n === Ne) return e.DEPTH_STENCIL; if (n === De) return e.RED; if (n === Fe) return e.RED_INTEGER; if (n === Oe) return e.RG; if (n === Ue) return e.RG_INTEGER; if (n === Be) return e.RGB_INTEGER; if (n === He) return e.RGBA_INTEGER; if (n === ze || n === Ge || n === ke || n === Ve) { if (null === (i = t.get("WEBGL_compressed_texture_s3tc"))) return null; if (n === ze) return i.COMPRESSED_RGB_S3TC_DXT1_EXT; if (n === Ge) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (n === ke) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (n === Ve) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (n === We || n === je || n === Xe || n === qe) { if (null === (i = t.get("WEBGL_compressed_texture_pvrtc"))) return null; if (n === We) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (n === je) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (n === Xe) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (n === qe) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (n === Ye) return null !== (i = t.get("WEBGL_compressed_texture_etc1")) ? i.COMPRESSED_RGB_ETC1_WEBGL : null; if ((n === Ze || n === Je) && null !== (i = t.get("WEBGL_compressed_texture_etc"))) { if (n === Ze) return i.COMPRESSED_RGB8_ETC2; if (n === Je) return i.COMPRESSED_RGBA8_ETC2_EAC } return n === Ke || n === Qe || n === $e || n === et || n === tt || n === nt || n === rt || n === it || n === st || n === at || n === ot || n === lt || n === ct || n === ht || n === dt || n === pt || n === mt || n === ft || n === gt || n === vt || n === yt || n === xt || n === _t || n === bt || n === wt || n === Mt || n === Tt || n === Et ? null !== (i = t.get("WEBGL_compressed_texture_astc")) ? n : null : n === ut ? null !== (i = t.get("EXT_texture_compression_bptc")) ? n : null : n === Ee ? r ? e.UNSIGNED_INT_24_8 : null !== (i = t.get("WEBGL_depth_texture")) ? i.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } class Jo extends Qi { constructor(e = []) { super(), this.cameras = e } } Jo.prototype.isArrayCamera = !0; class Ko extends Nr { constructor() { super(), this.type = "Group" } } Ko.prototype.isGroup = !0; const Qo = { type: "move" }; class $o { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new Ko, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new Ko, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Pn, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Pn), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new Ko, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Pn, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Pn), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, n) { let r = null, i = null, s = null; const a = this._targetRay, o = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) if (null !== a && null !== (r = t.getPose(e.targetRaySpace, n)) && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Qo)), l && e.hand) { s = !0; for (const r of e.hand.values()) { const e = t.getJointPose(r, n); if (void 0 === l.joints[r.jointName]) { const e = new Ko; e.matrixAutoUpdate = !1, e.visible = !1, l.joints[r.jointName] = e, l.add(e) } const i = l.joints[r.jointName]; null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = e.radius), i.visible = null !== e } const r = l.joints["index-finger-tip"], i = l.joints["thumb-tip"], a = r.position.distanceTo(i.position), o = .02, c = .005; l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== o && e.gripSpace && null !== (i = t.getPose(e.gripSpace, n)) && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1); return null !== a && (a.visible = null !== r), null !== o && (o.visible = null !== i), null !== l && (l.visible = null !== s), this } } class el extends nn { constructor(e, t) { super(); const n = this, r = e.state; let i = null, s = 1, a = null, o = "local-floor", l = null, c = null, h = null, u = null, d = null, p = !1, m = null, f = null, g = null, v = null, y = null, x = null; const _ = [], b = new Map, w = new Qi; w.layers.enable(1), w.viewport = new Sn; const M = new Qi; M.layers.enable(2), M.viewport = new Sn; const T = [w, M], E = new Jo; E.layers.enable(1), E.layers.enable(2); let S = null, A = null; function R(e) { const t = b.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function L() { b.forEach(function (e, t) { e.disconnect(t) }), b.clear(), S = null, A = null, r.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), h && t.deleteFramebuffer(h), m && t.deleteFramebuffer(m), f && t.deleteRenderbuffer(f), g && t.deleteRenderbuffer(g), h = null, m = null, f = null, g = null, d = null, u = null, c = null, i = null, F.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function C(e) { const t = i.inputSources; for (let e = 0; e < _.length; e++)b.set(t[e], _[e]); for (let t = 0; t < e.removed.length; t++) { const n = e.removed[t], r = b.get(n); r && (r.dispatchEvent({ type: "disconnected", data: n }), b.delete(n)) } for (let t = 0; t < e.added.length; t++) { const n = e.added[t], r = b.get(n); r && r.dispatchEvent({ type: "connected", data: n }) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = _[e]; return void 0 === t && (t = new $o, _[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = _[e]; return void 0 === t && (t = new $o, _[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = _[e]; return void 0 === t && (t = new $o, _[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { s = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { o = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return a }, this.getBaseLayer = function () { return null !== u ? u : d }, this.getBinding = function () { return c }, this.getFrame = function () { return v }, this.getSession = function () { return i }, this.setSession = async function (e) { if (null !== (i = e)) { i.addEventListener("select", R), i.addEventListener("selectstart", R), i.addEventListener("selectend", R), i.addEventListener("squeeze", R), i.addEventListener("squeezestart", R), i.addEventListener("squeezeend", R), i.addEventListener("end", L), i.addEventListener("inputsourceschange", C); const e = t.getContextAttributes(); if (!0 !== e.xrCompatible && await t.makeXRCompatible(), void 0 === i.renderState.layers) { const n = { antialias: e.antialias, alpha: e.alpha, depth: e.depth, stencil: e.stencil, framebufferScaleFactor: s }; d = new XRWebGLLayer(i, t, n), i.updateRenderState({ baseLayer: d }) } else if (t instanceof WebGLRenderingContext) { const n = { antialias: !0, alpha: e.alpha, depth: e.depth, stencil: e.stencil, framebufferScaleFactor: s }; d = new XRWebGLLayer(i, t, n), i.updateRenderState({ layers: [d] }) } else { p = e.antialias; let n = null; e.depth && (x = t.DEPTH_BUFFER_BIT, e.stencil && (x |= t.STENCIL_BUFFER_BIT), y = e.stencil ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT, n = e.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24); const a = { colorFormat: e.alpha ? t.RGBA8 : t.RGB8, depthFormat: n, scaleFactor: s }; c = new XRWebGLBinding(i, t), u = c.createProjectionLayer(a), h = t.createFramebuffer(), i.updateRenderState({ layers: [u] }), p && (m = t.createFramebuffer(), f = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, f), t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, t.RGBA8, u.textureWidth, u.textureHeight), r.bindFramebuffer(t.FRAMEBUFFER, m), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, f), t.bindRenderbuffer(t.RENDERBUFFER, null), null !== n && (g = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, g), t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, n, u.textureWidth, u.textureHeight), t.framebufferRenderbuffer(t.FRAMEBUFFER, y, t.RENDERBUFFER, g), t.bindRenderbuffer(t.RENDERBUFFER, null)), r.bindFramebuffer(t.FRAMEBUFFER, null)) } a = await i.requestReferenceSpace(o), F.setContext(i), F.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; const P = new Pn, I = new Pn; function N(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null === i) return; E.near = M.near = w.near = e.near, E.far = M.far = w.far = e.far, S === E.near && A === E.far || (i.updateRenderState({ depthNear: E.near, depthFar: E.far }), S = E.near, A = E.far); const t = e.parent, n = E.cameras; N(E, t); for (let e = 0; e < n.length; e++)N(n[e], t); E.matrixWorld.decompose(E.position, E.quaternion, E.scale), e.position.copy(E.position), e.quaternion.copy(E.quaternion), e.scale.copy(E.scale), e.matrix.copy(E.matrix), e.matrixWorld.copy(E.matrixWorld); const r = e.children; for (let e = 0, t = r.length; e < t; e++)r[e].updateMatrixWorld(!0); 2 === n.length ? function (e, t, n) { P.setFromMatrixPosition(t.matrixWorld), I.setFromMatrixPosition(n.matrixWorld); const r = P.distanceTo(I), i = t.projectionMatrix.elements, s = n.projectionMatrix.elements, a = i[14] / (i[10] - 1), o = i[14] / (i[10] + 1), l = (i[9] + 1) / i[5], c = (i[9] - 1) / i[5], h = (i[8] - 1) / i[0], u = (s[8] + 1) / s[0], d = a * h, p = a * u, m = r / (-h + u), f = m * -h; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(m), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(); const g = a + m, v = o + m, y = d - f, x = p + (r - f), _ = l * o / v * g, b = c * o / v * g; e.projectionMatrix.makePerspective(y, x, _, b, g, v) }(E, w, M) : E.projectionMatrix.copy(w.projectionMatrix) }, this.getCamera = function () { return E }, this.getFoveation = function () { return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0 }, this.setFoveation = function (e) { null !== u && (u.fixedFoveation = e), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e) }; let D = null; const F = new us; F.setAnimationLoop(function (e, n) { if (l = n.getViewerPose(a), v = n, null !== l) { const e = l.views; null !== d && r.bindXRFramebuffer(d.framebuffer); let n = !1; e.length !== E.cameras.length && (E.cameras.length = 0, n = !0); for (let i = 0; i < e.length; i++) { const s = e[i]; let a = null; if (null !== d) a = d.getViewport(s); else { const e = c.getViewSubImage(u, s); r.bindXRFramebuffer(h), void 0 !== e.depthStencilTexture && t.framebufferTexture2D(t.FRAMEBUFFER, y, t.TEXTURE_2D, e.depthStencilTexture, 0), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e.colorTexture, 0), a = e.viewport } const o = T[i]; o.matrix.fromArray(s.transform.matrix), o.projectionMatrix.fromArray(s.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === i && E.matrix.copy(o.matrix), !0 === n && E.cameras.push(o) } p && (r.bindXRFramebuffer(m), null !== x && t.clear(x)) } const s = i.inputSources; for (let e = 0; e < _.length; e++) { const t = _[e], r = s[e]; t.update(r, n, a) } if (D && D(e, n), p) { const e = u.textureWidth, n = u.textureHeight; r.bindFramebuffer(t.READ_FRAMEBUFFER, m), r.bindFramebuffer(t.DRAW_FRAMEBUFFER, h), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [y]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [y]), t.blitFramebuffer(0, 0, e, n, 0, 0, e, n, t.COLOR_BUFFER_BIT, t.NEAREST), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [t.COLOR_ATTACHMENT0]), r.bindFramebuffer(t.READ_FRAMEBUFFER, null), r.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(t.FRAMEBUFFER, m) } v = null }), this.setAnimationLoop = function (e) { D = e }, this.dispose = function () { } } } function tl(e) { function t(t, n) { t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest); const r = e.get(n).envMap; if (r) { t.envMap.value = r, t.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio; const i = e.get(r).__maxMipLevel; void 0 !== i && (t.maxMipLevel.value = i) } let i, s; n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? i = n.clearcoatRoughnessMap : n.specularIntensityMap ? i = n.specularIntensityMap : n.specularTintMap ? i = n.specularTintMap : n.transmissionMap ? i = n.transmissionMap : n.thicknessMap && (i = n.thicknessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), t.uv2Transform.value.copy(s.matrix)) } function n(t, n) { t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, n.side === h && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), n.side === h && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias), e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (e, r, i, s, a) { r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(e, r), function (e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(e, r)) : r.isMeshToonMaterial ? (t(e, r), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === h && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === h && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshPhongMaterial ? (t(e, r), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === h && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === h && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshStandardMaterial ? (t(e, r), r.isMeshPhysicalMaterial ? function (e, t, r) { n(e, t), e.ior.value = t.ior, t.sheenTint && e.sheenTint.value.copy(t.sheenTint), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === h && e.clearcoatNormalScale.value.negate())), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = r.texture, e.transmissionSamplerSize.value.set(r.width, r.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationTint.value.copy(t.attenuationTint)), e.specularIntensity.value = t.specularIntensity, e.specularTint.value.copy(t.specularTint), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap), t.specularTintMap && (e.specularTintMap.value = t.specularTintMap) }(e, r, a) : n(e, r)) : r.isMeshMatcapMaterial ? (t(e, r), function (e, t) { t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === h && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === h && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshDepthMaterial ? (t(e, r), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshDistanceMaterial ? (t(e, r), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(e, r)) : r.isMeshNormalMaterial ? (t(e, r), function (e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === h && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === h && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity }(e, r), r.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, r)) : r.isPointsMaterial ? function (e, t, n, r) { let i; e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * r, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? i = t.map : t.alphaMap && (i = t.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)) }(e, r, i, s) : r.isSpriteMaterial ? function (e, t) { let n; e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix)) }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1) } } } function nl(e = {}) { const t = void 0 !== e.canvas ? e.canvas : function () { const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return e.style.display = "block", e }(), n = void 0 !== e.context ? e.context : null, r = void 0 !== e.alpha && e.alpha, i = void 0 === e.depth || e.depth, s = void 0 === e.stencil || e.stencil, a = void 0 !== e.antialias && e.antialias, o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, d = void 0 !== e.powerPreference ? e.powerPreference : "default", p = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat; let m = null, f = null; const g = [], v = []; this.domElement = t, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Ht, this.physicallyCorrectLights = !1, this.toneMapping = X, this.toneMappingExposure = 1; const y = this; let x = !1, _ = 0, b = 0, w = null, M = -1, T = null; const E = new Sn, S = new Sn; let A = null, R = t.width, L = t.height, C = 1, P = null, I = null; const N = new Sn(0, 0, R, L), D = new Sn(0, 0, R, L); let F = !1; const O = [], U = new hs; let B = !1, H = !1, z = null; const G = new lr, k = new Pn, V = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function W() { return null === w ? C : 1 } let j, q, Y, Z, J, K, Q, $, ee, te, ne, re, ie, se, oe, ce, he, ue, de, fe, ge, ve, ye, xe = n; function we(e, n) { for (let r = 0; r < e.length; r++) { const i = e[r], s = t.getContext(i, n); if (null !== s) return s } return null } try { const e = { alpha: r, depth: i, stencil: s, antialias: a, premultipliedAlpha: o, preserveDrawingBuffer: l, powerPreference: d, failIfMajorPerformanceCaveat: p }; if (t.addEventListener("webglcontextlost", Ee, !1), t.addEventListener("webglcontextrestored", Se, !1), null === xe) { const t = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === y.isWebGL1Renderer && t.shift(), null === (xe = we(t, e))) throw we(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === xe.getShaderPrecisionFormat && (xe.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function Me() { j = new Ks(xe), q = new _s(xe, j, e), j.init(q), ve = new Zo(xe, j, q), Y = new qo(xe, j, q), O[0] = xe.BACK, Z = new ea(xe), J = new Po, K = new Yo(xe, j, Y, J, q, ve, Z), Q = new ws(y), $ = new Js(y), ee = new ds(xe, q), ye = new ys(xe, j, ee, q), te = new Qs(xe, ee, Z, ye), ne = new ia(xe, te, ee, Z), de = new ra(xe), ce = new bs(J), re = new Co(y, Q, $, j, q, ye, ce), ie = new tl(J), se = new Fo(J), oe = new Go(j, q), ue = new vs(y, Q, Y, ne, o), he = new Xo(y, ne, q), fe = new xs(xe, j, Z, q), ge = new $s(xe, j, Z, q), Z.programs = re.programs, y.capabilities = q, y.extensions = j, y.properties = J, y.renderLists = se, y.shadowMap = he, y.state = Y, y.info = Z } Me(); const Te = new el(y, xe); function Ee(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0 } function Se() { console.log("THREE.WebGLRenderer: Context Restored."), x = !1; const e = Z.autoReset, t = he.enabled, n = he.autoUpdate, r = he.needsUpdate, i = he.type; Me(), Z.autoReset = e, he.enabled = t, he.autoUpdate = n, he.needsUpdate = r, he.type = i } function Ae(e) { const t = e.target; t.removeEventListener("dispose", Ae), function (e) { (function (e) { const t = J.get(e).programs; void 0 !== t && t.forEach(function (e) { re.releaseProgram(e) }) })(e), J.remove(e) }(t) } this.xr = Te, this.getContext = function () { return xe }, this.getContextAttributes = function () { return xe.getContextAttributes() }, this.forceContextLoss = function () { const e = j.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = j.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return C }, this.setPixelRatio = function (e) { void 0 !== e && (C = e, this.setSize(R, L, !1)) }, this.getSize = function (e) { return e.set(R, L) }, this.setSize = function (e, n, r) { Te.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e, L = n, t.width = Math.floor(e * C), t.height = Math.floor(n * C), !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n)) }, this.getDrawingBufferSize = function (e) { return e.set(R * C, L * C).floor() }, this.setDrawingBufferSize = function (e, n, r) { R = e, L = n, C = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n) }, this.getCurrentViewport = function (e) { return e.copy(E) }, this.getViewport = function (e) { return e.copy(N) }, this.setViewport = function (e, t, n, r) { e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, r), Y.viewport(E.copy(N).multiplyScalar(C).floor()) }, this.getScissor = function (e) { return e.copy(D) }, this.setScissor = function (e, t, n, r) { e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r), Y.scissor(S.copy(D).multiplyScalar(C).floor()) }, this.getScissorTest = function () { return F }, this.setScissorTest = function (e) { Y.setScissorTest(F = e) }, this.setOpaqueSort = function (e) { P = e }, this.setTransparentSort = function (e) { I = e }, this.getClearColor = function (e) { return e.copy(ue.getClearColor()) }, this.setClearColor = function () { ue.setClearColor.apply(ue, arguments) }, this.getClearAlpha = function () { return ue.getClearAlpha() }, this.setClearAlpha = function () { ue.setClearAlpha.apply(ue, arguments) }, this.clear = function (e, t, n) { let r = 0; (void 0 === e || e) && (r |= xe.COLOR_BUFFER_BIT), (void 0 === t || t) && (r |= xe.DEPTH_BUFFER_BIT), (void 0 === n || n) && (r |= xe.STENCIL_BUFFER_BIT), xe.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", Ee, !1), t.removeEventListener("webglcontextrestored", Se, !1), se.dispose(), oe.dispose(), J.dispose(), Q.dispose(), $.dispose(), ne.dispose(), ye.dispose(), Te.dispose(), Te.removeEventListener("sessionstart", Ce), Te.removeEventListener("sessionend", Pe), z && (z.dispose(), z = null), Ie.stop() }, this.renderBufferImmediate = function (e, t) { ye.initAttributes(); const n = J.get(e); e.hasPositions && !n.position && (n.position = xe.createBuffer()), e.hasNormals && !n.normal && (n.normal = xe.createBuffer()), e.hasUvs && !n.uv && (n.uv = xe.createBuffer()), e.hasColors && !n.color && (n.color = xe.createBuffer()); const r = t.getAttributes(); e.hasPositions && (xe.bindBuffer(xe.ARRAY_BUFFER, n.position), xe.bufferData(xe.ARRAY_BUFFER, e.positionArray, xe.DYNAMIC_DRAW), ye.enableAttribute(r.position.location), xe.vertexAttribPointer(r.position.location, 3, xe.FLOAT, !1, 0, 0)), e.hasNormals && (xe.bindBuffer(xe.ARRAY_BUFFER, n.normal), xe.bufferData(xe.ARRAY_BUFFER, e.normalArray, xe.DYNAMIC_DRAW), ye.enableAttribute(r.normal.location), xe.vertexAttribPointer(r.normal.location, 3, xe.FLOAT, !1, 0, 0)), e.hasUvs && (xe.bindBuffer(xe.ARRAY_BUFFER, n.uv), xe.bufferData(xe.ARRAY_BUFFER, e.uvArray, xe.DYNAMIC_DRAW), ye.enableAttribute(r.uv.location), xe.vertexAttribPointer(r.uv.location, 2, xe.FLOAT, !1, 0, 0)), e.hasColors && (xe.bindBuffer(xe.ARRAY_BUFFER, n.color), xe.bufferData(xe.ARRAY_BUFFER, e.colorArray, xe.DYNAMIC_DRAW), ye.enableAttribute(r.color.location), xe.vertexAttribPointer(r.color.location, 3, xe.FLOAT, !1, 0, 0)), ye.disableUnusedAttributes(), xe.drawArrays(xe.TRIANGLES, 0, e.count), e.count = 0 }, this.renderBufferDirect = function (e, t, n, r, i, s) { null === t && (t = V); const a = i.isMesh && i.matrixWorld.determinant() < 0, o = Be(e, t, r, i); Y.setMaterial(r, a); let l = n.index; const c = n.attributes.position; if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return; let h, u = 1; !0 === r.wireframe && (l = te.getWireframeAttribute(n), u = 2), void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || de.update(i, n, r, o), ye.setup(i, r, o, n, l); let d = fe; null !== l && (h = ee.get(l), (d = ge).setIndex(h)); const p = null !== l ? l.count : c.count, m = n.drawRange.start * u, f = n.drawRange.count * u, g = null !== s ? s.start * u : 0, v = null !== s ? s.count * u : 1 / 0, y = Math.max(m, g), x = Math.min(p, m + f, g + v) - 1, _ = Math.max(0, x - y + 1); if (0 !== _) { if (i.isMesh) !0 === r.wireframe ? (Y.setLineWidth(r.wireframeLinewidth * W()), d.setMode(xe.LINES)) : d.setMode(xe.TRIANGLES); else if (i.isLine) { let e = r.linewidth; void 0 === e && (e = 1), Y.setLineWidth(e * W()), i.isLineSegments ? d.setMode(xe.LINES) : i.isLineLoop ? d.setMode(xe.LINE_LOOP) : d.setMode(xe.LINE_STRIP) } else i.isPoints ? d.setMode(xe.POINTS) : i.isSprite && d.setMode(xe.TRIANGLES); if (i.isInstancedMesh) d.renderInstances(y, _, i.count); else if (n.isInstancedBufferGeometry) { const e = Math.min(n.instanceCount, n._maxInstanceCount); d.renderInstances(y, _, e) } else d.render(y, _) } }, this.compile = function (e, t) { (f = oe.get(e)).init(), v.push(f), e.traverseVisible(function (e) { e.isLight && e.layers.test(t.layers) && (f.pushLight(e), e.castShadow && f.pushShadow(e)) }), f.setupLights(y.physicallyCorrectLights), e.traverse(function (t) { const n = t.material; if (n) if (Array.isArray(n)) for (let r = 0; r < n.length; r++) { Oe(n[r], e, t) } else Oe(n, e, t) }), v.pop(), f = null }; let Le = null; function Ce() { Ie.stop() } function Pe() { Ie.start() } const Ie = new us; function Ne(e, t, n, r) { const i = e.opaque, s = e.transmissive, o = e.transparent; f.setupLightsView(n), s.length > 0 && function (e, t, n) { if (null === z) { const e = !0 === a && !0 === q.isWebGL2, t = e ? Ln : An; z = new t(1024, 1024, { generateMipmaps: !0, type: null !== ve.convert(be) ? be : me, minFilter: pe, magFilter: le, wrapS: ae, wrapT: ae }) } const r = y.getRenderTarget(); y.setRenderTarget(z), y.clear(); const i = y.toneMapping; y.toneMapping = X, De(e, t, n), y.toneMapping = i, K.updateMultisampleRenderTarget(z), K.updateRenderTargetMipmap(z), y.setRenderTarget(r) }(i, t, n), r && Y.viewport(E.copy(r)), i.length > 0 && De(i, t, n), s.length > 0 && De(s, t, n), o.length > 0 && De(o, t, n) } function De(e, t, n) { const r = !0 === t.isScene ? t.overrideMaterial : null; for (let i = 0, s = e.length; i < s; i++) { const s = e[i], a = s.object, o = s.geometry, l = null === r ? s.material : r, c = s.group; a.layers.test(n.layers) && Fe(a, t, n, o, l, c) } } function Fe(e, t, n, r, i, s) { if (e.onBeforeRender(y, t, n, r, i, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { const r = Be(n, t, i, e); Y.setMaterial(i), ye.reset(), function (e, t) { e.render(function (e) { y.renderBufferImmediate(e, t) }) }(e, r) } else !0 === i.transparent && i.side === u ? (i.side = h, i.needsUpdate = !0, y.renderBufferDirect(n, t, r, i, e, s), i.side = c, i.needsUpdate = !0, y.renderBufferDirect(n, t, r, i, e, s), i.side = u) : y.renderBufferDirect(n, t, r, i, e, s); e.onAfterRender(y, t, n, r, i, s) } function Oe(e, t, n) { !0 !== t.isScene && (t = V); const r = J.get(e), i = f.state.lights, s = f.state.shadowsArray, a = i.state.version, o = re.getParameters(e, i.state, s, t, n), l = re.getProgramCacheKey(o); let c = r.programs; r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? $ : Q).get(e.envMap || r.environment), void 0 === c && (e.addEventListener("dispose", Ae), c = new Map, r.programs = c); let h = c.get(l); if (void 0 !== h) { if (r.currentProgram === h && r.lightsStateVersion === a) return Ue(e, o), h } else o.uniforms = re.getUniforms(e), e.onBuild(o, y), e.onBeforeCompile(o, y), h = re.acquireProgram(o, l), c.set(l, h), r.uniforms = o.uniforms; const u = r.uniforms; (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = ce.uniform), Ue(e, o), r.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), r.lightsStateVersion = a, r.needsLights && (u.ambientLightColor.value = i.state.ambient, u.lightProbe.value = i.state.probe, u.directionalLights.value = i.state.directional, u.directionalLightShadows.value = i.state.directionalShadow, u.spotLights.value = i.state.spot, u.spotLightShadows.value = i.state.spotShadow, u.rectAreaLights.value = i.state.rectArea, u.ltc_1.value = i.state.rectAreaLTC1, u.ltc_2.value = i.state.rectAreaLTC2, u.pointLights.value = i.state.point, u.pointLightShadows.value = i.state.pointShadow, u.hemisphereLights.value = i.state.hemi, u.directionalShadowMap.value = i.state.directionalShadowMap, u.directionalShadowMatrix.value = i.state.directionalShadowMatrix, u.spotShadowMap.value = i.state.spotShadowMap, u.spotShadowMatrix.value = i.state.spotShadowMatrix, u.pointShadowMap.value = i.state.pointShadowMap, u.pointShadowMatrix.value = i.state.pointShadowMatrix); const d = h.getUniforms(), p = lo.seqWithValue(d.seq, u); return r.currentProgram = h, r.uniformsList = p, h } function Ue(e, t) { const n = J.get(e); n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents } function Be(e, t, n, r) { !0 !== t.isScene && (t = V), K.resetTextureUnits(); const i = t.fog, s = n.isMeshStandardMaterial ? t.environment : null, a = null === w ? y.outputEncoding : w.texture.encoding, o = (n.isMeshStandardMaterial ? $ : Q).get(n.envMap || s), l = !0 === n.vertexColors && !!r.geometry && !!r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize, c = !!r.geometry && !!r.geometry.attributes.tangent, h = !!r.geometry && !!r.geometry.morphAttributes.position, u = !!r.geometry && !!r.geometry.morphAttributes.normal, d = J.get(n), p = f.state.lights; if (!0 === B && (!0 === H || e !== T)) { const t = e === T && n.id === M; ce.setState(n, e, t) } let m = !1; n.version === d.__version ? d.needsLights && d.lightsStateVersion !== p.state.version ? m = !0 : d.outputEncoding !== a ? m = !0 : r.isInstancedMesh && !1 === d.instancing ? m = !0 : r.isInstancedMesh || !0 !== d.instancing ? r.isSkinnedMesh && !1 === d.skinning ? m = !0 : r.isSkinnedMesh || !0 !== d.skinning ? d.envMap !== o ? m = !0 : n.fog && d.fog !== i ? m = !0 : void 0 === d.numClippingPlanes || d.numClippingPlanes === ce.numPlanes && d.numIntersection === ce.numIntersection ? d.vertexAlphas !== l ? m = !0 : d.vertexTangents !== c ? m = !0 : d.morphTargets !== h ? m = !0 : d.morphNormals !== u && (m = !0) : m = !0 : m = !0 : m = !0 : (m = !0, d.__version = n.version); let g = d.currentProgram; !0 === m && (g = Oe(n, t, r)); let v = !1, x = !1, _ = !1; const b = g.getUniforms(), E = d.uniforms; if (Y.useProgram(g.program) && (v = !0, x = !0, _ = !0), n.id !== M && (M = n.id, x = !0), v || T !== e) { if (b.setValue(xe, "projectionMatrix", e.projectionMatrix), q.logarithmicDepthBuffer && b.setValue(xe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), T !== e && (T = e, x = !0, _ = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { const t = b.map.cameraPosition; void 0 !== t && t.setValue(xe, k.setFromMatrixPosition(e.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && b.setValue(xe, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && b.setValue(xe, "viewMatrix", e.matrixWorldInverse) } if (r.isSkinnedMesh) { b.setOptional(xe, r, "bindMatrix"), b.setOptional(xe, r, "bindMatrixInverse"); const e = r.skeleton; e && (q.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), b.setValue(xe, "boneTexture", e.boneTexture, K), b.setValue(xe, "boneTextureSize", e.boneTextureSize)) : b.setOptional(xe, e, "boneMatrices")) } var S, A; return (x || d.receiveShadow !== r.receiveShadow) && (d.receiveShadow = r.receiveShadow, b.setValue(xe, "receiveShadow", r.receiveShadow)), x && (b.setValue(xe, "toneMappingExposure", y.toneMappingExposure), d.needsLights && (A = _, (S = E).ambientLightColor.needsUpdate = A, S.lightProbe.needsUpdate = A, S.directionalLights.needsUpdate = A, S.directionalLightShadows.needsUpdate = A, S.pointLights.needsUpdate = A, S.pointLightShadows.needsUpdate = A, S.spotLights.needsUpdate = A, S.spotLightShadows.needsUpdate = A, S.rectAreaLights.needsUpdate = A, S.hemisphereLights.needsUpdate = A), i && n.fog && ie.refreshFogUniforms(E, i), ie.refreshMaterialUniforms(E, n, C, L, z), lo.upload(xe, d.uniformsList, E, K)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (lo.upload(xe, d.uniformsList, E, K), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && b.setValue(xe, "center", r.center), b.setValue(xe, "modelViewMatrix", r.modelViewMatrix), b.setValue(xe, "normalMatrix", r.normalMatrix), b.setValue(xe, "modelMatrix", r.matrixWorld), g } Ie.setAnimationLoop(function (e) { Le && Le(e) }), "undefined" != typeof window && Ie.setContext(window), this.setAnimationLoop = function (e) { Le = e, Te.setAnimationLoop(e), null === e ? Ie.stop() : Ie.start() }, Te.addEventListener("sessionstart", Ce), Te.addEventListener("sessionend", Pe), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === x) return; !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === Te.enabled && !0 === Te.isPresenting && (!0 === Te.cameraAutoUpdate && Te.updateCamera(t), t = Te.getCamera()), !0 === e.isScene && e.onBeforeRender(y, e, t, w), (f = oe.get(e, v.length)).init(), v.push(f), G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), U.setFromProjectionMatrix(G), H = this.localClippingEnabled, B = ce.init(this.clippingPlanes, H, t), (m = se.get(e, g.length)).init(), g.push(m), function e(t, n, r, i) { if (!1 === t.visible) return; const s = t.layers.test(n.layers); if (s) if (t.isGroup) r = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(n); else if (t.isLight) f.pushLight(t), t.castShadow && f.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || U.intersectsSprite(t)) { i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G); const e = ne.update(t), n = t.material; n.visible && m.push(t, e, n, r, k.z, null) } } else if (t.isImmediateRenderObject) i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G), m.push(t, null, t.material, r, k.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Z.render.frame && (t.skeleton.update(), t.skeleton.frame = Z.render.frame), !t.frustumCulled || U.intersectsObject(t))) { i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G); const e = ne.update(t), n = t.material; if (Array.isArray(n)) { const i = e.groups; for (let s = 0, a = i.length; s < a; s++) { const a = i[s], o = n[a.materialIndex]; o && o.visible && m.push(t, e, o, r, k.z, a) } } else n.visible && m.push(t, e, n, r, k.z, null) } const a = t.children; for (let t = 0, s = a.length; t < s; t++)e(a[t], n, r, i) }(e, t, 0, y.sortObjects), m.finish(), !0 === y.sortObjects && m.sort(P, I), !0 === B && ce.beginShadows(); const n = f.state.shadowsArray; if (he.render(n, e, t), !0 === B && ce.endShadows(), !0 === this.info.autoReset && this.info.reset(), ue.render(m, e), f.setupLights(y.physicallyCorrectLights), t.isArrayCamera) { const n = t.cameras; for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; Ne(m, e, r, r.viewport) } } else Ne(m, e, t); null !== w && (K.updateMultisampleRenderTarget(w), K.updateRenderTargetMipmap(w)), !0 === e.isScene && e.onAfterRender(y, e, t), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1), ye.resetDefaultState(), M = -1, T = null, v.pop(), f = v.length > 0 ? v[v.length - 1] : null, g.pop(), m = g.length > 0 ? g[g.length - 1] : null }, this.getActiveCubeFace = function () { return _ }, this.getActiveMipmapLevel = function () { return b }, this.getRenderTarget = function () { return w }, this.setRenderTarget = function (e, t = 0, n = 0) { w = e, _ = t, b = n, e && void 0 === J.get(e).__webglFramebuffer && K.setupRenderTarget(e); let r = null, i = !1, s = !1; if (e) { const n = e.texture; (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0); const a = J.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (r = a[t], i = !0) : r = e.isWebGLMultisampleRenderTarget ? J.get(e).__webglMultisampledFramebuffer : a, E.copy(e.viewport), S.copy(e.scissor), A = e.scissorTest } else E.copy(N).multiplyScalar(C).floor(), S.copy(D).multiplyScalar(C).floor(), A = F; if (Y.bindFramebuffer(xe.FRAMEBUFFER, r) && q.drawBuffers) { let t = !1; if (e) if (e.isWebGLMultipleRenderTargets) { const n = e.texture; if (O.length !== n.length || O[0] !== xe.COLOR_ATTACHMENT0) { for (let e = 0, t = n.length; e < t; e++)O[e] = xe.COLOR_ATTACHMENT0 + e; O.length = n.length, t = !0 } } else 1 === O.length && O[0] === xe.COLOR_ATTACHMENT0 || (O[0] = xe.COLOR_ATTACHMENT0, O.length = 1, t = !0); else 1 === O.length && O[0] === xe.BACK || (O[0] = xe.BACK, O.length = 1, t = !0); t && (q.isWebGL2 ? xe.drawBuffers(O) : j.get("WEBGL_draw_buffers").drawBuffersWEBGL(O)) } if (Y.viewport(E), Y.scissor(S), Y.setScissorTest(A), i) { const r = J.get(e.texture); xe.framebufferTexture2D(xe.FRAMEBUFFER, xe.COLOR_ATTACHMENT0, xe.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, n) } else if (s) { const r = J.get(e.texture), i = t || 0; xe.framebufferTextureLayer(xe.FRAMEBUFFER, xe.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i) } M = -1 }, this.readRenderTargetPixels = function (e, t, n, r, i, s, a) { if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let o = J.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) { Y.bindFramebuffer(xe.FRAMEBUFFER, o); try { const a = e.texture, o = a.format, l = a.type; if (o !== Re && ve.convert(o) !== xe.getParameter(xe.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const c = l === be && (j.has("EXT_color_buffer_half_float") || q.isWebGL2 && j.has("EXT_color_buffer_float")); if (!(l === me || ve.convert(l) === xe.getParameter(xe.IMPLEMENTATION_COLOR_READ_TYPE) || l === _e && (q.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); xe.checkFramebufferStatus(xe.FRAMEBUFFER) === xe.FRAMEBUFFER_COMPLETE ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && xe.readPixels(t, n, r, i, ve.convert(o), ve.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { const e = null !== w ? J.get(w).__webglFramebuffer : null; Y.bindFramebuffer(xe.FRAMEBUFFER, e) } } }, this.copyFramebufferToTexture = function (e, t, n = 0) { const r = Math.pow(2, -n), i = Math.floor(t.image.width * r), s = Math.floor(t.image.height * r); let a = ve.convert(t.format); q.isWebGL2 && (a === xe.RGB && (a = xe.RGB8), a === xe.RGBA && (a = xe.RGBA8)), K.setTexture2D(t, 0), xe.copyTexImage2D(xe.TEXTURE_2D, n, a, e.x, e.y, i, s, 0), Y.unbindTexture() }, this.copyTextureToTexture = function (e, t, n, r = 0) { const i = t.image.width, s = t.image.height, a = ve.convert(n.format), o = ve.convert(n.type); K.setTexture2D(n, 0), xe.pixelStorei(xe.UNPACK_FLIP_Y_WEBGL, n.flipY), xe.pixelStorei(xe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), xe.pixelStorei(xe.UNPACK_ALIGNMENT, n.unpackAlignment), t.isDataTexture ? xe.texSubImage2D(xe.TEXTURE_2D, r, e.x, e.y, i, s, a, o, t.image.data) : t.isCompressedTexture ? xe.compressedTexSubImage2D(xe.TEXTURE_2D, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : xe.texSubImage2D(xe.TEXTURE_2D, r, e.x, e.y, a, o, t.image), 0 === r && n.generateMipmaps && xe.generateMipmap(xe.TEXTURE_2D), Y.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, n, r, i = 0) { if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const s = e.max.x - e.min.x + 1, a = e.max.y - e.min.y + 1, o = e.max.z - e.min.z + 1, l = ve.convert(r.format), c = ve.convert(r.type); let h; if (r.isDataTexture3D) K.setTexture3D(r, 0), h = xe.TEXTURE_3D; else { if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); K.setTexture2DArray(r, 0), h = xe.TEXTURE_2D_ARRAY } xe.pixelStorei(xe.UNPACK_FLIP_Y_WEBGL, r.flipY), xe.pixelStorei(xe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), xe.pixelStorei(xe.UNPACK_ALIGNMENT, r.unpackAlignment); const u = xe.getParameter(xe.UNPACK_ROW_LENGTH), d = xe.getParameter(xe.UNPACK_IMAGE_HEIGHT), p = xe.getParameter(xe.UNPACK_SKIP_PIXELS), m = xe.getParameter(xe.UNPACK_SKIP_ROWS), f = xe.getParameter(xe.UNPACK_SKIP_IMAGES), g = n.isCompressedTexture ? n.mipmaps[0] : n.image; xe.pixelStorei(xe.UNPACK_ROW_LENGTH, g.width), xe.pixelStorei(xe.UNPACK_IMAGE_HEIGHT, g.height), xe.pixelStorei(xe.UNPACK_SKIP_PIXELS, e.min.x), xe.pixelStorei(xe.UNPACK_SKIP_ROWS, e.min.y), xe.pixelStorei(xe.UNPACK_SKIP_IMAGES, e.min.z), n.isDataTexture || n.isDataTexture3D ? xe.texSubImage3D(h, i, t.x, t.y, t.z, s, a, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xe.compressedTexSubImage3D(h, i, t.x, t.y, t.z, s, a, o, l, g.data)) : xe.texSubImage3D(h, i, t.x, t.y, t.z, s, a, o, l, c, g), xe.pixelStorei(xe.UNPACK_ROW_LENGTH, u), xe.pixelStorei(xe.UNPACK_IMAGE_HEIGHT, d), xe.pixelStorei(xe.UNPACK_SKIP_PIXELS, p), xe.pixelStorei(xe.UNPACK_SKIP_ROWS, m), xe.pixelStorei(xe.UNPACK_SKIP_IMAGES, f), 0 === i && r.generateMipmaps && xe.generateMipmap(h), Y.unbindTexture() }, this.initTexture = function (e) { K.setTexture2D(e, 0), Y.unbindTexture() }, this.resetState = function () { _ = 0, b = 0, w = null, Y.reset(), ye.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } class rl extends nl { } rl.prototype.isWebGL1Renderer = !0; class il { constructor(e, t = 25e-5) { this.name = "", this.color = new $r(e), this.density = t } clone() { return new il(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } il.prototype.isFogExp2 = !0; class sl { constructor(e, t = 1, n = 1e3) { this.name = "", this.color = new $r(e), this.near = t, this.far = n } clone() { return new sl(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } sl.prototype.isFog = !0; class al extends Nr { constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), t } } al.prototype.isScene = !0; class ol { constructor(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = $t, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = ln() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.stride, n *= t.stride; for (let r = 0, i = this.stride; r < i; r++)this.array[e + r] = t.array[n + r]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ln()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride); return n.setUsage(this.usage), n } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ln()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } ol.prototype.isInterleavedBuffer = !0; const ll = new Pn; class cl { constructor(e, t, n, r = !1) { this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, n = this.data.count; t < n; t++)ll.x = this.getX(t), ll.y = this.getY(t), ll.z = this.getZ(t), ll.applyMatrix4(e), this.setXYZ(t, ll.x, ll.y, ll.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)ll.x = this.getX(t), ll.y = this.getY(t), ll.z = this.getZ(t), ll.applyNormalMatrix(e), this.setXYZ(t, ll.x, ll.y, ll.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)ll.x = this.getX(t), ll.y = this.getY(t), ll.z = this.getZ(t), ll.transformDirection(e), this.setXYZ(t, ll.x, ll.y, ll.z); return this } setX(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { return this.data.array[e * this.data.stride + this.offset] } getY(e) { return this.data.array[e * this.data.stride + this.offset + 1] } getZ(e) { return this.data.array[e * this.data.stride + this.offset + 2] } getW(e) { return this.data.array[e * this.data.stride + this.offset + 3] } setXY(e, t, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this } setXYZW(e, t, n, r, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this } clone(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return new ri(new this.array.constructor(e), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new cl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } cl.prototype.isInterleavedBufferAttribute = !0; class hl extends Xr { constructor(e) { super(), this.type = "SpriteMaterial", this.color = new $r(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this } } let ul; hl.prototype.isSpriteMaterial = !0; const dl = new Pn, pl = new Pn, ml = new Pn, fl = new gn, gl = new gn, vl = new lr, yl = new Pn, xl = new Pn, _l = new Pn, bl = new gn, wl = new gn, Ml = new gn; class Tl extends Nr { constructor(e) { if (super(), this.type = "Sprite", void 0 === ul) { ul = new Ti; const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), t = new ol(e, 5); ul.setIndex([0, 1, 2, 0, 2, 3]), ul.setAttribute("position", new cl(t, 3, 0, !1)), ul.setAttribute("uv", new cl(t, 2, 3, !1)) } this.geometry = ul, this.material = void 0 !== e ? e : new hl, this.center = new gn(.5, .5) } raycast(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), pl.setFromMatrixScale(this.matrixWorld), vl.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ml.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && pl.multiplyScalar(-ml.z); const n = this.material.rotation; let r, i; 0 !== n && (i = Math.cos(n), r = Math.sin(n)); const s = this.center; El(yl.set(-.5, -.5, 0), ml, s, pl, r, i), El(xl.set(.5, -.5, 0), ml, s, pl, r, i), El(_l.set(.5, .5, 0), ml, s, pl, r, i), bl.set(0, 0), wl.set(1, 0), Ml.set(1, 1); let a = e.ray.intersectTriangle(yl, xl, _l, !1, dl); if (null === a && (El(xl.set(-.5, .5, 0), ml, s, pl, r, i), wl.set(0, 1), null === (a = e.ray.intersectTriangle(yl, _l, xl, !1, dl)))) return; const o = e.ray.origin.distanceTo(dl); o < e.near || o > e.far || t.push({ distance: o, point: dl.clone(), uv: Wr.getUV(dl, yl, xl, _l, bl, wl, Ml, new gn), face: null, object: this }) } copy(e) { return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } } function El(e, t, n, r, i, s) { fl.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (gl.x = s * fl.x - i * fl.y, gl.y = i * fl.x + s * fl.y) : gl.copy(fl), e.copy(t), e.x += gl.x, e.y += gl.y, e.applyMatrix4(vl) } Tl.prototype.isSprite = !0; const Sl = new Pn, Al = new Pn; class Rl extends Nr { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; this.addLevel(n.object.clone(), n.distance) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0) { t = Math.abs(t); const n = this.levels; let r; for (r = 0; r < n.length && !(t < n[r].distance); r++); return n.splice(r, 0, { distance: t, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let n, r; for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++); return t[n - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { Sl.setFromMatrixPosition(this.matrixWorld); const n = e.ray.origin.distanceTo(Sl); this.getObjectForDistance(n).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { Sl.setFromMatrixPosition(e.matrixWorld), Al.setFromMatrixPosition(this.matrixWorld); const n = Sl.distanceTo(Al) / e.zoom; let r, i; for (t[0].object.visible = !0, r = 1, i = t.length; r < i && n >= t[r].distance; r++)t[r - 1].object.visible = !1, t[r].object.visible = !0; for (this._currentLevel = r - 1; r < i; r++)t[r].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = []; const n = this.levels; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; t.object.levels.push({ object: r.object.uuid, distance: r.distance }) } return t } } const Ll = new Pn, Cl = new Sn, Pl = new Sn, Il = new Pn, Nl = new lr; class Dl extends ki { constructor(e, t) { super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new lr, this.bindMatrixInverse = new lr } copy(e) { return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Sn, t = this.geometry.attributes.skinWeight; for (let n = 0, r = t.count; n < r; n++) { e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n); const r = 1 / e.manhattanLength(); r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const n = this.skeleton, r = this.geometry; Cl.fromBufferAttribute(r.attributes.skinIndex, e), Pl.fromBufferAttribute(r.attributes.skinWeight, e), Ll.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const r = Pl.getComponent(e); if (0 !== r) { const i = Cl.getComponent(e); Nl.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(Il.copy(Ll).applyMatrix4(Nl), r) } } return t.applyMatrix4(this.bindMatrixInverse) } } Dl.prototype.isSkinnedMesh = !0; class Fl extends Nr { constructor() { super(), this.type = "Bone" } } Fl.prototype.isBone = !0; class Ol extends bn { constructor(e = null, t = 1, n = 1, r, i, s, a, o, l = le, c = le, h, u) { super(null, s, a, o, l, c, r, i, h, u), this.image = { data: e, width: t, height: n }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } Ol.prototype.isDataTexture = !0; const Ul = new lr, Bl = new lr; class Hl { constructor(e = [], t = []) { this.uuid = ln(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new lr) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const t = new lr; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture; for (let r = 0, i = e.length; r < i; r++) { const i = e[r] ? e[r].matrixWorld : Bl; Ul.multiplyMatrices(i, t[r]), Ul.toArray(n, 16 * r) } null !== r && (r.needsUpdate = !0) } clone() { return new Hl(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(4 * this.bones.length); e = pn(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const n = new Ol(t, e, e, Re, _e); return this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, n = this.bones.length; t < n; t++) { const n = this.bones[t]; if (n.name === e) return n } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let n = 0, r = e.bones.length; n < r; n++) { const r = e.bones[n]; let i = t[r]; void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new Fl), this.bones.push(i), this.boneInverses.push((new lr).fromArray(e.boneInverses[n])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, n = this.boneInverses; for (let r = 0, i = t.length; r < i; r++) { const i = t[r]; e.bones.push(i.uuid); const s = n[r]; e.boneInverses.push(s.toArray()) } return e } } class zl extends ri { constructor(e, t, n, r = 1) { "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } zl.prototype.isInstancedBufferAttribute = !0; const Gl = new lr, kl = new lr, Vl = [], Wl = new ki; class jl extends ki { constructor(e, t, n) { super(e, t), this.instanceMatrix = new zl(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 } copy(e) { return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } raycast(e, t) { const n = this.matrixWorld, r = this.count; if (Wl.geometry = this.geometry, Wl.material = this.material, void 0 !== Wl.material) for (let i = 0; i < r; i++) { this.getMatrixAt(i, Gl), kl.multiplyMatrices(n, Gl), Wl.matrixWorld = kl, Wl.raycast(e, Vl); for (let e = 0, n = Vl.length; e < n; e++) { const n = Vl[e]; n.instanceId = i, n.object = this, t.push(n) } Vl.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new zl(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } jl.prototype.isInstancedMesh = !0; class Xl extends Xr { constructor(e) { super(), this.type = "LineBasicMaterial", this.color = new $r(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this } } Xl.prototype.isLineBasicMaterial = !0; const ql = new Pn, Yl = new Pn, Zl = new lr, Jl = new or, Kl = new $n; class Ql extends Nr { constructor(e = new Ti, t = new Xl) { super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, n = [0]; for (let e = 1, r = t.count; e < r; e++)ql.fromBufferAttribute(t, e - 1), Yl.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += ql.distanceTo(Yl); e.setAttribute("lineDistance", new di(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } raycast(e, t) { const n = this.geometry, r = this.matrixWorld, i = e.params.Line.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), Kl.copy(n.boundingSphere), Kl.applyMatrix4(r), Kl.radius += i, !1 === e.ray.intersectsSphere(Kl)) return; Zl.copy(r).invert(), Jl.copy(e.ray).applyMatrix4(Zl); const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, l = new Pn, c = new Pn, h = new Pn, u = new Pn, d = this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { const r = n.index, i = n.attributes.position; if (null !== r) { for (let n = Math.max(0, s.start), a = Math.min(r.count, s.start + s.count) - 1; n < a; n += d) { const s = r.getX(n), a = r.getX(n + 1); if (l.fromBufferAttribute(i, s), c.fromBufferAttribute(i, a), Jl.distanceSqToSegment(l, c, u, h) > o) continue; u.applyMatrix4(this.matrixWorld); const d = e.ray.origin.distanceTo(u); d < e.near || d > e.far || t.push({ distance: d, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else { for (let n = Math.max(0, s.start), r = Math.min(i.count, s.start + s.count) - 1; n < r; n += d) { if (l.fromBufferAttribute(i, n), c.fromBufferAttribute(i, n + 1), Jl.distanceSqToSegment(l, c, u, h) > o) continue; u.applyMatrix4(this.matrixWorld); const r = e.ray.origin.distanceTo(u); r < e.near || r > e.far || t.push({ distance: r, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } Ql.prototype.isLine = !0; const $l = new Pn, ec = new Pn; class tc extends Ql { constructor(e, t) { super(e, t), this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, n = []; for (let e = 0, r = t.count; e < r; e += 2)$l.fromBufferAttribute(t, e), ec.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + $l.distanceTo(ec); e.setAttribute("lineDistance", new di(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } } tc.prototype.isLineSegments = !0; class nc extends Ql { constructor(e, t) { super(e, t), this.type = "LineLoop" } } nc.prototype.isLineLoop = !0; class rc extends Xr { constructor(e) { super(), this.type = "PointsMaterial", this.color = new $r(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this } } rc.prototype.isPointsMaterial = !0; const ic = new lr, sc = new or, ac = new $n, oc = new Pn; class lc extends Nr { constructor(e = new Ti, t = new rc) { super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } raycast(e, t) { const n = this.geometry, r = this.matrixWorld, i = e.params.Points.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), ac.copy(n.boundingSphere), ac.applyMatrix4(r), ac.radius += i, !1 === e.ray.intersectsSphere(ac)) return; ic.copy(r).invert(), sc.copy(e.ray).applyMatrix4(ic); const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a; if (n.isBufferGeometry) { const i = n.index, a = n.attributes.position; if (null !== i) { for (let n = Math.max(0, s.start), l = Math.min(i.count, s.start + s.count); n < l; n++) { const s = i.getX(n); oc.fromBufferAttribute(a, s), cc(oc, s, o, r, e, t, this) } } else { for (let n = Math.max(0, s.start), i = Math.min(a.count, s.start + s.count); n < i; n++)oc.fromBufferAttribute(a, n), cc(oc, n, o, r, e, t, this) } } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } function cc(e, t, n, r, i, s, a) { const o = sc.distanceSqToPoint(e); if (o < n) { const n = new Pn; sc.closestPointToPoint(e, n), n.applyMatrix4(r); const l = i.ray.origin.distanceTo(n); if (l < i.near || l > i.far) return; s.push({ distance: l, distanceToRay: Math.sqrt(o), point: n, index: t, face: null, object: a }) } } lc.prototype.isPoints = !0; class hc extends bn { constructor(e, t, n, r, i, s, a, o, l) { super(e, t, n, r, i, s, a, o, l), this.format = void 0 !== a ? a : Ae, this.minFilter = void 0 !== s ? s : ue, this.magFilter = void 0 !== i ? i : ue, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() { c.needsUpdate = !0, e.requestVideoFrameCallback(t) }) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } hc.prototype.isVideoTexture = !0; class uc extends bn { constructor(e, t, n, r, i, s, a, o, l, c, h, u) { super(null, s, a, o, l, c, r, i, h, u), this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } uc.prototype.isCompressedTexture = !0; class dc extends bn { constructor(e, t, n, r, i, s, a, o, l) { super(e, t, n, r, i, s, a, o, l), this.needsUpdate = !0 } } dc.prototype.isCanvasTexture = !0; class pc extends bn { constructor(e, t, n, r, i, s, a, o, l, c) { if ((c = void 0 !== c ? c : Ie) !== Ie && c !== Ne) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && c === Ie && (n = ve), void 0 === n && c === Ne && (n = Ee), super(null, r, i, s, a, o, c, n, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== a ? a : le, this.minFilter = void 0 !== o ? o : le, this.flipY = !1, this.generateMipmaps = !1 } } pc.prototype.isDepthTexture = !0; class mc extends Ti { constructor(e = 1, t = 8, n = 0, r = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, t = Math.max(3, t); const i = [], s = [], a = [], o = [], l = new Pn, c = new gn; s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5); for (let i = 0, h = 3; i <= t; i++, h += 3) { const u = n + i / t * r; l.x = e * Math.cos(u), l.y = e * Math.sin(u), s.push(l.x, l.y, l.z), a.push(0, 0, 1), c.x = (s[h] / e + 1) / 2, c.y = (s[h + 1] / e + 1) / 2, o.push(c.x, c.y) } for (let e = 1; e <= t; e++)i.push(e, e + 1, 0); this.setIndex(i), this.setAttribute("position", new di(s, 3)), this.setAttribute("normal", new di(a, 3)), this.setAttribute("uv", new di(o, 2)) } static fromJSON(e) { return new mc(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class fc extends Ti { constructor(e = 1, t = 1, n = 1, r = 8, i = 1, s = !1, a = 0, o = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: i, openEnded: s, thetaStart: a, thetaLength: o }; const l = this; r = Math.floor(r), i = Math.floor(i); const c = [], h = [], u = [], d = []; let p = 0; const m = [], f = n / 2; let g = 0; function v(n) { const i = p, s = new gn, m = new Pn; let v = 0; const y = !0 === n ? e : t, x = !0 === n ? 1 : -1; for (let e = 1; e <= r; e++)h.push(0, f * x, 0), u.push(0, x, 0), d.push(.5, .5), p++; const _ = p; for (let e = 0; e <= r; e++) { const t = e / r * o + a, n = Math.cos(t), i = Math.sin(t); m.x = y * i, m.y = f * x, m.z = y * n, h.push(m.x, m.y, m.z), u.push(0, x, 0), s.x = .5 * n + .5, s.y = .5 * i * x + .5, d.push(s.x, s.y), p++ } for (let e = 0; e < r; e++) { const t = i + e, r = _ + e; !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t), v += 3 } l.addGroup(g, v, !0 === n ? 1 : 2), g += v } !function () { const s = new Pn, v = new Pn; let y = 0; const x = (t - e) / n; for (let l = 0; l <= i; l++) { const c = [], g = l / i, y = g * (t - e) + e; for (let e = 0; e <= r; e++) { const t = e / r, i = t * o + a, l = Math.sin(i), m = Math.cos(i); v.x = y * l, v.y = -g * n + f, v.z = y * m, h.push(v.x, v.y, v.z), s.set(l, x, m).normalize(), u.push(s.x, s.y, s.z), d.push(t, 1 - g), c.push(p++) } m.push(c) } for (let e = 0; e < r; e++)for (let t = 0; t < i; t++) { const n = m[t][e], r = m[t + 1][e], i = m[t + 1][e + 1], s = m[t][e + 1]; c.push(n, r, s), c.push(r, i, s), y += 6 } l.addGroup(g, y, 0), g += y }(), !1 === s && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new di(h, 3)), this.setAttribute("normal", new di(u, 3)), this.setAttribute("uv", new di(d, 2)) } static fromJSON(e) { return new fc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class gc extends fc { constructor(e = 1, t = 1, n = 8, r = 1, i = !1, s = 0, a = 2 * Math.PI) { super(0, e, t, n, r, i, s, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: s, thetaLength: a } } static fromJSON(e) { return new gc(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class vc extends Ti { constructor(e, t, n = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: r }; const i = [], s = []; function a(e, t, n, r) { const i = r + 1, s = []; for (let r = 0; r <= i; r++) { s[r] = []; const a = e.clone().lerp(n, r / i), o = t.clone().lerp(n, r / i), l = i - r; for (let e = 0; e <= l; e++)s[r][e] = 0 === e && r === i ? a : a.clone().lerp(o, e / l) } for (let e = 0; e < i; e++)for (let t = 0; t < 2 * (i - e) - 1; t++) { const n = Math.floor(t / 2); t % 2 == 0 ? (o(s[e][n + 1]), o(s[e + 1][n]), o(s[e][n])) : (o(s[e][n + 1]), o(s[e + 1][n + 1]), o(s[e + 1][n])) } } function o(e) { i.push(e.x, e.y, e.z) } function l(t, n) { const r = 3 * t; n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2] } function c(e, t, n, r) { r < 0 && 1 === e.x && (s[t] = e.x - 1), 0 === n.x && 0 === n.z && (s[t] = r / 2 / Math.PI + .5) } function h(e) { return Math.atan2(e.z, -e.x) } !function (e) { const n = new Pn, r = new Pn, i = new Pn; for (let s = 0; s < t.length; s += 3)l(t[s + 0], n), l(t[s + 1], r), l(t[s + 2], i), a(n, r, i, e) }(r), function (e) { const t = new Pn; for (let n = 0; n < i.length; n += 3)t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z }(n), function () { const e = new Pn; for (let n = 0; n < i.length; n += 3) { e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2]; const r = h(e) / 2 / Math.PI + .5, a = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5); s.push(r, 1 - a) } var t; (function () { const e = new Pn, t = new Pn, n = new Pn, r = new Pn, a = new gn, o = new gn, l = new gn; for (let u = 0, d = 0; u < i.length; u += 9, d += 6) { e.set(i[u + 0], i[u + 1], i[u + 2]), t.set(i[u + 3], i[u + 4], i[u + 5]), n.set(i[u + 6], i[u + 7], i[u + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), r.copy(e).add(t).add(n).divideScalar(3); const p = h(r); c(a, d + 0, e, p), c(o, d + 2, t, p), c(l, d + 4, n, p) } })(), function () { for (let e = 0; e < s.length; e += 6) { const t = s[e + 0], n = s[e + 2], r = s[e + 4], i = Math.max(t, n, r), a = Math.min(t, n, r); i > .9 && a < .1 && (t < .2 && (s[e + 0] += 1), n < .2 && (s[e + 2] += 1), r < .2 && (s[e + 4] += 1)) } }() }(), this.setAttribute("position", new di(i, 3)), this.setAttribute("normal", new di(i.slice(), 3)), this.setAttribute("uv", new di(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals() } static fromJSON(e) { return new vc(e.vertices, e.indices, e.radius, e.details) } } class yc extends vc { constructor(e = 1, t = 0) { const n = (1 + Math.sqrt(5)) / 2, r = 1 / n; super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new yc(e.radius, e.detail) } } const xc = new Pn, _c = new Pn, bc = new Pn, wc = new Wr; class Mc extends Ti { constructor(e, t) { if (super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1, !0 === e.isGeometry) return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); const n = Math.pow(10, 4), r = Math.cos(an * t), i = e.getIndex(), s = e.getAttribute("position"), a = i ? i.count : s.count, o = [0, 0, 0], l = ["a", "b", "c"], c = new Array(3), h = {}, u = []; for (let e = 0; e < a; e += 3) { i ? (o[0] = i.getX(e), o[1] = i.getX(e + 1), o[2] = i.getX(e + 2)) : (o[0] = e, o[1] = e + 1, o[2] = e + 2); const { a: t, b: a, c: d } = wc; if (t.fromBufferAttribute(s, o[0]), a.fromBufferAttribute(s, o[1]), d.fromBufferAttribute(s, o[2]), wc.getNormal(bc), c[0] = `${Math.round(t.x * n)},${Math.round(t.y * n)},${Math.round(t.z * n)}`, c[1] = `${Math.round(a.x * n)},${Math.round(a.y * n)},${Math.round(a.z * n)}`, c[2] = `${Math.round(d.x * n)},${Math.round(d.y * n)},${Math.round(d.z * n)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0]) for (let e = 0; e < 3; e++) { const t = (e + 1) % 3, n = c[e], i = c[t], s = wc[l[e]], a = wc[l[t]], d = `${n}_${i}`, p = `${i}_${n}`; p in h && h[p] ? (bc.dot(h[p].normal) <= r && (u.push(s.x, s.y, s.z), u.push(a.x, a.y, a.z)), h[p] = null) : d in h || (h[d] = { index0: o[e], index1: o[t], normal: bc.clone() }) } } for (const e in h) if (h[e]) { const { index0: t, index1: n } = h[e]; xc.fromBufferAttribute(s, t), _c.fromBufferAttribute(s, n), u.push(xc.x, xc.y, xc.z), u.push(_c.x, _c.y, _c.z) } this.setAttribute("position", new di(u, 3)) } } class Tc { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const n = this.getUtoTmapping(e); return this.getPoint(n, t) } getPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPointAt(n / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let n, r = this.getPoint(0), i = 0; t.push(0); for (let s = 1; s <= e; s++)i += (n = this.getPoint(s / e)).distanceTo(r), t.push(i), r = n; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const n = this.getLengths(); let r = 0; const i = n.length; let s; s = t || e * n[i - 1]; let a, o = 0, l = i - 1; for (; o <= l;)if ((a = n[r = Math.floor(o + (l - o) / 2)] - s) < 0) o = r + 1; else { if (!(a > 0)) { l = r; break } l = r - 1 } if (n[r = l] === s) return r / (i - 1); const c = n[r]; return (r + (s - c) / (n[r + 1] - c)) / (i - 1) } getTangent(e, t) { let n = e - 1e-4, r = e + 1e-4; n < 0 && (n = 0), r > 1 && (r = 1); const i = this.getPoint(n), s = this.getPoint(r), a = t || (i.isVector2 ? new gn : new Pn); return a.copy(s).sub(i).normalize(), a } getTangentAt(e, t) { const n = this.getUtoTmapping(e); return this.getTangent(n, t) } computeFrenetFrames(e, t) { const n = new Pn, r = [], i = [], s = [], a = new Pn, o = new lr; for (let t = 0; t <= e; t++) { const n = t / e; r[t] = this.getTangentAt(n, new Pn), r[t].normalize() } i[0] = new Pn, s[0] = new Pn; let l = Number.MAX_VALUE; const c = Math.abs(r[0].x), h = Math.abs(r[0].y), u = Math.abs(r[0].z); c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], a), s[0].crossVectors(r[0], i[0]); for (let t = 1; t <= e; t++) { if (i[t] = i[t - 1].clone(), s[t] = s[t - 1].clone(), a.crossVectors(r[t - 1], r[t]), a.length() > Number.EPSILON) { a.normalize(); const e = Math.acos(cn(r[t - 1].dot(r[t]), -1, 1)); i[t].applyMatrix4(o.makeRotationAxis(a, e)) } s[t].crossVectors(r[t], i[t]) } if (!0 === t) { let t = Math.acos(cn(i[0].dot(i[e]), -1, 1)); t /= e, r[0].dot(a.crossVectors(i[0], i[e])) > 0 && (t = -t); for (let n = 1; n <= e; n++)i[n].applyMatrix4(o.makeRotationAxis(r[n], t * n)), s[n].crossVectors(r[n], i[n]) } return { tangents: r, normals: i, binormals: s } } clone() { return (new this.constructor).copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class Ec extends Tc { constructor(e = 0, t = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, a = !1, o = 0) { super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o } getPoint(e, t) { const n = t || new gn, r = 2 * Math.PI; let i = this.aEndAngle - this.aStartAngle; const s = Math.abs(i) < Number.EPSILON; for (; i < 0;)i += r; for (; i > r;)i -= r; i < Number.EPSILON && (i = s ? 0 : r), !0 !== this.aClockwise || s || (i === r ? i = -r : i -= r); const a = this.aStartAngle + e * i; let o = this.aX + this.xRadius * Math.cos(a), l = this.aY + this.yRadius * Math.sin(a); if (0 !== this.aRotation) { const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), n = o - this.aX, r = l - this.aY; o = n * e - r * t + this.aX, l = n * t + r * e + this.aY } return n.set(o, l) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } Ec.prototype.isEllipseCurve = !0; class Sc extends Ec { constructor(e, t, n, r, i, s) { super(e, t, n, n, r, i, s), this.type = "ArcCurve" } } function Ac() { let e = 0, t = 0, n = 0, r = 0; function i(i, s, a, o) { e = i, t = a, n = -3 * i + 3 * s - 2 * a - o, r = 2 * i - 2 * s + a + o } return { initCatmullRom: function (e, t, n, r, s) { i(t, n, s * (n - e), s * (r - t)) }, initNonuniformCatmullRom: function (e, t, n, r, s, a, o) { let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a, c = (n - t) / a - (r - t) / (a + o) + (r - n) / o; i(t, n, l *= a, c *= a) }, calc: function (i) { const s = i * i; return e + t * i + n * s + r * (s * i) } } } Sc.prototype.isArcCurve = !0; const Rc = new Pn, Lc = new Ac, Cc = new Ac, Pc = new Ac; class Ic extends Tc { constructor(e = [], t = !1, n = "centripetal", r = .5) { super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r } getPoint(e, t = new Pn) { const n = t, r = this.points, i = r.length, s = (i - (this.closed ? 0 : 1)) * e; let a, o, l = Math.floor(s), c = s - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? a = r[(l - 1) % i] : (Rc.subVectors(r[0], r[1]).add(r[0]), a = Rc); const h = r[l % i], u = r[(l + 1) % i]; if (this.closed || l + 2 < i ? o = r[(l + 2) % i] : (Rc.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), o = Rc), "centripetal" === this.curveType || "chordal" === this.curveType) { const e = "chordal" === this.curveType ? .5 : .25; let t = Math.pow(a.distanceToSquared(h), e), n = Math.pow(h.distanceToSquared(u), e), r = Math.pow(u.distanceToSquared(o), e); n < 1e-4 && (n = 1), t < 1e-4 && (t = n), r < 1e-4 && (r = n), Lc.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, t, n, r), Cc.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, t, n, r), Pc.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, t, n, r) } else "catmullrom" === this.curveType && (Lc.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), Cc.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), Pc.initCatmullRom(a.z, h.z, u.z, o.z, this.tension)); return n.set(Lc.calc(c), Cc.calc(c), Pc.calc(c)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new Pn).fromArray(n)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function Nc(e, t, n, r, i) { const s = .5 * (r - t), a = .5 * (i - n), o = e * e; return (2 * n - 2 * r + s + a) * (e * o) + (-3 * n + 3 * r - 2 * s - a) * o + s * e + n } function Dc(e, t, n, r) { return function (e, t) { const n = 1 - e; return n * n * t }(e, t) + function (e, t) { return 2 * (1 - e) * e * t }(e, n) + function (e, t) { return e * e * t }(e, r) } function Fc(e, t, n, r, i) { return function (e, t) { const n = 1 - e; return n * n * n * t }(e, t) + function (e, t) { const n = 1 - e; return 3 * n * n * e * t }(e, n) + function (e, t) { return 3 * (1 - e) * e * e * t }(e, r) + function (e, t) { return e * e * e * t }(e, i) } Ic.prototype.isCatmullRomCurve3 = !0; class Oc extends Tc { constructor(e = new gn, t = new gn, n = new gn, r = new gn) { super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new gn) { const n = t, r = this.v0, i = this.v1, s = this.v2, a = this.v3; return n.set(Fc(e, r.x, i.x, s.x, a.x), Fc(e, r.y, i.y, s.y, a.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } Oc.prototype.isCubicBezierCurve = !0; class Uc extends Tc { constructor(e = new Pn, t = new Pn, n = new Pn, r = new Pn) { super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new Pn) { const n = t, r = this.v0, i = this.v1, s = this.v2, a = this.v3; return n.set(Fc(e, r.x, i.x, s.x, a.x), Fc(e, r.y, i.y, s.y, a.y), Fc(e, r.z, i.z, s.z, a.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } Uc.prototype.isCubicBezierCurve3 = !0; class Bc extends Tc { constructor(e = new gn, t = new gn) { super(), this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new gn) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const n = t || new gn; return n.copy(this.v2).sub(this.v1).normalize(), n } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Bc.prototype.isLineCurve = !0; class Hc extends Tc { constructor(e = new Pn, t = new Pn) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t } getPoint(e, t = new Pn) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class zc extends Tc { constructor(e = new gn, t = new gn, n = new gn) { super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new gn) { const n = t, r = this.v0, i = this.v1, s = this.v2; return n.set(Dc(e, r.x, i.x, s.x), Dc(e, r.y, i.y, s.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } zc.prototype.isQuadraticBezierCurve = !0; class Gc extends Tc { constructor(e = new Pn, t = new Pn, n = new Pn) { super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new Pn) { const n = t, r = this.v0, i = this.v1, s = this.v2; return n.set(Dc(e, r.x, i.x, s.x), Dc(e, r.y, i.y, s.y), Dc(e, r.z, i.z, s.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Gc.prototype.isQuadraticBezierCurve3 = !0; class kc extends Tc { constructor(e = []) { super(), this.type = "SplineCurve", this.points = e } getPoint(e, t = new gn) { const n = t, r = this.points, i = (r.length - 1) * e, s = Math.floor(i), a = i - s, o = r[0 === s ? s : s - 1], l = r[s], c = r[s > r.length - 2 ? r.length - 1 : s + 1], h = r[s > r.length - 3 ? r.length - 1 : s + 2]; return n.set(Nc(a, o.x, l.x, c.x, h.x), Nc(a, o.y, l.y, c.y, h.y)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new gn).fromArray(n)) } return this } } kc.prototype.isSplineCurve = !0; var Vc = Object.freeze({ __proto__: null, ArcCurve: Sc, CatmullRomCurve3: Ic, CubicBezierCurve: Oc, CubicBezierCurve3: Uc, EllipseCurve: Ec, LineCurve: Bc, LineCurve3: Hc, QuadraticBezierCurve: zc, QuadraticBezierCurve3: Gc, SplineCurve: kc }); const Wc = { triangulate: function (e, t, n = 2) { const r = t && t.length, i = r ? t[0] * n : e.length; let s = jc(e, 0, i, n, !0); const a = []; if (!s || s.next === s.prev) return a; let o, l, c, h, u, d, p; if (r && (s = function (e, t, n, r) { const i = []; let s, a, o, l, c; for (s = 0, a = t.length; s < a; s++)o = t[s] * r, l = s < a - 1 ? t[s + 1] * r : e.length, (c = jc(e, o, l, r, !1)) === c.next && (c.steiner = !0), i.push(nh(c)); for (i.sort(Qc), s = 0; s < i.length; s++)$c(i[s], n), n = Xc(n, n.next); return n }(e, t, s, n)), e.length > 80 * n) { o = c = e[0], l = h = e[1]; for (let t = n; t < i; t += n)(u = e[t]) < o && (o = u), (d = e[t + 1]) < l && (l = d), u > c && (c = u), d > h && (h = d); p = 0 !== (p = Math.max(c - o, h - l)) ? 1 / p : 0 } return qc(s, a, n, o, l, p), a } }; function jc(e, t, n, r, i) { let s, a; if (i === function (e, t, n, r) { let i = 0; for (let s = t, a = n - r; s < n; s += r)i += (e[a] - e[s]) * (e[s + 1] + e[a + 1]), a = s; return i }(e, t, n, r) > 0) for (s = t; s < n; s += r)a = dh(s, e[s], e[s + 1], a); else for (s = n - r; s >= t; s -= r)a = dh(s, e[s], e[s + 1], a); return a && ah(a, a.next) && (ph(a), a = a.next), a } function Xc(e, t) { if (!e) return e; t || (t = e); let n, r = e; do { if (n = !1, r.steiner || !ah(r, r.next) && 0 !== sh(r.prev, r, r.next)) r = r.next; else { if (ph(r), (r = t = r.prev) === r.next) break; n = !0 } } while (n || r !== t); return t } function qc(e, t, n, r, i, s, a) { if (!e) return; !a && s && function (e, t, n, r) { let i = e; do { null === i.z && (i.z = th(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== e); i.prevZ.nextZ = null, i.prevZ = null, function (e) { let t, n, r, i, s, a, o, l, c = 1; do { for (n = e, e = null, s = null, a = 0; n;) { for (a++, r = n, o = 0, t = 0; t < c && (o++, r = r.nextZ); t++); for (l = c; o > 0 || l > 0 && r;)0 !== o && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, o--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : e = i, i.prevZ = s, s = i; n = r } s.nextZ = null, c *= 2 } while (a > 1) }(i) }(e, r, i, s); let o, l, c = e; for (; e.prev !== e.next;)if (o = e.prev, l = e.next, s ? Zc(e, r, i, s) : Yc(e)) t.push(o.i / n), t.push(e.i / n), t.push(l.i / n), ph(e), e = l.next, c = l.next; else if ((e = l) === c) { a ? 1 === a ? qc(e = Jc(Xc(e), t, n), t, n, r, i, s, 2) : 2 === a && Kc(e, t, n, r, i, s) : qc(Xc(e), t, n, r, i, s, 1); break } } function Yc(e) { const t = e.prev, n = e, r = e.next; if (sh(t, n, r) >= 0) return !1; let i = e.next.next; for (; i !== e.prev;) { if (rh(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && sh(i.prev, i, i.next) >= 0) return !1; i = i.next } return !0 } function Zc(e, t, n, r) { const i = e.prev, s = e, a = e.next; if (sh(i, s, a) >= 0) return !1; const o = i.x < s.x ? i.x < a.x ? i.x : a.x : s.x < a.x ? s.x : a.x, l = i.y < s.y ? i.y < a.y ? i.y : a.y : s.y < a.y ? s.y : a.y, c = i.x > s.x ? i.x > a.x ? i.x : a.x : s.x > a.x ? s.x : a.x, h = i.y > s.y ? i.y > a.y ? i.y : a.y : s.y > a.y ? s.y : a.y, u = th(o, l, t, n, r), d = th(c, h, t, n, r); let p = e.prevZ, m = e.nextZ; for (; p && p.z >= u && m && m.z <= d;) { if (p !== e.prev && p !== e.next && rh(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && sh(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, m !== e.prev && m !== e.next && rh(i.x, i.y, s.x, s.y, a.x, a.y, m.x, m.y) && sh(m.prev, m, m.next) >= 0) return !1; m = m.nextZ } for (; p && p.z >= u;) { if (p !== e.prev && p !== e.next && rh(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && sh(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (; m && m.z <= d;) { if (m !== e.prev && m !== e.next && rh(i.x, i.y, s.x, s.y, a.x, a.y, m.x, m.y) && sh(m.prev, m, m.next) >= 0) return !1; m = m.nextZ } return !0 } function Jc(e, t, n) { let r = e; do { const i = r.prev, s = r.next.next; !ah(i, s) && oh(i, r, r.next, s) && hh(i, s) && hh(s, i) && (t.push(i.i / n), t.push(r.i / n), t.push(s.i / n), ph(r), ph(r.next), r = e = s), r = r.next } while (r !== e); return Xc(r) } function Kc(e, t, n, r, i, s) { let a = e; do { let e = a.next.next; for (; e !== a.prev;) { if (a.i !== e.i && ih(a, e)) { let o = uh(a, e); return a = Xc(a, a.next), o = Xc(o, o.next), qc(a, t, n, r, i, s), void qc(o, t, n, r, i, s) } e = e.next } a = a.next } while (a !== e) } function Qc(e, t) { return e.x - t.x } function $c(e, t) { if (t = function (e, t) { let n = t; const r = e.x, i = e.y; let s, a = -1 / 0; do { if (i <= n.y && i >= n.next.y && n.next.y !== n.y) { const e = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (e <= r && e > a) { if (a = e, e === r) { if (i === n.y) return n; if (i === n.next.y) return n.next } s = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== t); if (!s) return null; if (r === a) return s; const o = s, l = s.x, c = s.y; let h, u = 1 / 0; n = s; do { r >= n.x && n.x >= l && r !== n.x && rh(i < c ? r : a, i, l, c, i < c ? a : r, i, n.x, n.y) && (h = Math.abs(i - n.y) / (r - n.x), hh(n, e) && (h < u || h === u && (n.x > s.x || n.x === s.x && eh(s, n))) && (s = n, u = h)), n = n.next } while (n !== o); return s }(e, t)) { const n = uh(t, e); Xc(t, t.next), Xc(n, n.next) } } function eh(e, t) { return sh(e.prev, e, t.prev) < 0 && sh(t.next, e, e.next) < 0 } function th(e, t, n, r, i) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function nh(e) { let t = e, n = e; do { (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next } while (t !== e); return n } function rh(e, t, n, r, i, s, a, o) { return (i - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (r - o) - (n - a) * (t - o) >= 0 && (n - a) * (s - o) - (i - a) * (r - o) >= 0 } function ih(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { let n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && oh(n, n.next, e, t)) return !0; n = n.next } while (n !== e); return !1 }(e, t) && (hh(e, t) && hh(t, e) && function (e, t) { let n = e, r = !1; const i = (e.x + t.x) / 2, s = (e.y + t.y) / 2; do { n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== e); return r }(e, t) && (sh(e.prev, e, t.prev) || sh(e, t.prev, t)) || ah(e, t) && sh(e.prev, e, e.next) > 0 && sh(t.prev, t, t.next) > 0) } function sh(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) } function ah(e, t) { return e.x === t.x && e.y === t.y } function oh(e, t, n, r) { const i = ch(sh(e, t, n)), s = ch(sh(e, t, r)), a = ch(sh(n, r, e)), o = ch(sh(n, r, t)); return i !== s && a !== o || (!(0 !== i || !lh(e, n, t)) || (!(0 !== s || !lh(e, r, t)) || (!(0 !== a || !lh(n, e, r)) || !(0 !== o || !lh(n, t, r))))) } function lh(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) } function ch(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function hh(e, t) { return sh(e.prev, e, e.next) < 0 ? sh(e, t, e.next) >= 0 && sh(e, e.prev, t) >= 0 : sh(e, t, e.prev) < 0 || sh(e, e.next, t) < 0 } function uh(e, t) { const n = new mh(e.i, e.x, e.y), r = new mh(t.i, t.x, t.y), i = e.next, s = t.prev; return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r } function dh(e, t, n, r) { const i = new mh(e, t, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function ph(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function mh(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } class fh { static area(e) { const t = e.length; let n = 0; for (let r = t - 1, i = 0; i < t; r = i++)n += e[r].x * e[i].y - e[i].x * e[r].y; return .5 * n } static isClockWise(e) { return fh.area(e) < 0 } static triangulateShape(e, t) { const n = [], r = [], i = []; gh(e), vh(n, e); let s = e.length; t.forEach(gh); for (let e = 0; e < t.length; e++)r.push(s), s += t[e].length, vh(n, t[e]); const a = Wc.triangulate(n, r); for (let e = 0; e < a.length; e += 3)i.push(a.slice(e, e + 3)); return i } } function gh(e) { const t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function vh(e, t) { for (let n = 0; n < t.length; n++)e.push(t[n].x), e.push(t[n].y) } class yh extends Ti { constructor(e, t) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const n = this, r = [], i = []; for (let t = 0, n = e.length; t < n; t++) { s(e[t]) } function s(e) { const s = [], a = void 0 !== t.curveSegments ? t.curveSegments : 12, o = void 0 !== t.steps ? t.steps : 1; let l = void 0 !== t.depth ? t.depth : 100, c = void 0 === t.bevelEnabled || t.bevelEnabled, h = void 0 !== t.bevelThickness ? t.bevelThickness : 6, u = void 0 !== t.bevelSize ? t.bevelSize : h - 2, d = void 0 !== t.bevelOffset ? t.bevelOffset : 0, p = void 0 !== t.bevelSegments ? t.bevelSegments : 3; const m = t.extrudePath, f = void 0 !== t.UVGenerator ? t.UVGenerator : xh; void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount); let g, v, y, x, _, b = !1; m && (g = m.getSpacedPoints(o), b = !0, c = !1, v = m.computeFrenetFrames(o, !1), y = new Pn, x = new Pn, _ = new Pn), c || (p = 0, h = 0, u = 0, d = 0); const w = e.extractPoints(a); let M = w.shape; const T = w.holes; if (!fh.isClockWise(M)) { M = M.reverse(); for (let e = 0, t = T.length; e < t; e++) { const t = T[e]; fh.isClockWise(t) && (T[e] = t.reverse()) } } const E = fh.triangulateShape(M, T), S = M; for (let e = 0, t = T.length; e < t; e++) { const t = T[e]; M = M.concat(t) } function A(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e) } const R = M.length, L = E.length; function C(e, t, n) { let r, i, s; const a = e.x - t.x, o = e.y - t.y, l = n.x - e.x, c = n.y - e.y, h = a * a + o * o, u = a * c - o * l; if (Math.abs(u) > Number.EPSILON) { const u = Math.sqrt(h), d = Math.sqrt(l * l + c * c), p = t.x - o / u, m = t.y + a / u, f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l), g = (r = p + a * f - e.x) * r + (i = m + o * f - e.y) * i; if (g <= 2) return new gn(r, i); s = Math.sqrt(g / 2) } else { let e = !1; a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(c) && (e = !0), e ? (r = -o, i = a, s = Math.sqrt(h)) : (r = a, i = o, s = Math.sqrt(h / 2)) } return new gn(r / s, i / s) } const P = []; for (let e = 0, t = S.length, n = t - 1, r = e + 1; e < t; e++, n++, r++)n === t && (n = 0), r === t && (r = 0), P[e] = C(S[e], S[n], S[r]); const I = []; let N, D = P.concat(); for (let e = 0, t = T.length; e < t; e++) { const t = T[e]; N = []; for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++)r === n && (r = 0), i === n && (i = 0), N[e] = C(t[e], t[r], t[i]); I.push(N), D = D.concat(N) } for (let e = 0; e < p; e++) { const t = e / p, n = h * Math.cos(t * Math.PI / 2), r = u * Math.sin(t * Math.PI / 2) + d; for (let e = 0, t = S.length; e < t; e++) { const t = A(S[e], P[e], r); U(t.x, t.y, -n) } for (let e = 0, t = T.length; e < t; e++) { const t = T[e]; N = I[e]; for (let e = 0, i = t.length; e < i; e++) { const i = A(t[e], N[e], r); U(i.x, i.y, -n) } } } const F = u + d; for (let e = 0; e < R; e++) { const t = c ? A(M[e], D[e], F) : M[e]; b ? (x.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), _.copy(g[0]).add(x).add(y), U(_.x, _.y, _.z)) : U(t.x, t.y, 0) } for (let e = 1; e <= o; e++)for (let t = 0; t < R; t++) { const n = c ? A(M[t], D[t], F) : M[t]; b ? (x.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), _.copy(g[e]).add(x).add(y), U(_.x, _.y, _.z)) : U(n.x, n.y, l / o * e) } for (let e = p - 1; e >= 0; e--) { const t = e / p, n = h * Math.cos(t * Math.PI / 2), r = u * Math.sin(t * Math.PI / 2) + d; for (let e = 0, t = S.length; e < t; e++) { const t = A(S[e], P[e], r); U(t.x, t.y, l + n) } for (let e = 0, t = T.length; e < t; e++) { const t = T[e]; N = I[e]; for (let e = 0, i = t.length; e < i; e++) { const i = A(t[e], N[e], r); b ? U(i.x, i.y + g[o - 1].y, g[o - 1].x + n) : U(i.x, i.y, l + n) } } } function O(e, t) { let n = e.length; for (; --n >= 0;) { const r = n; let i = n - 1; i < 0 && (i = e.length - 1); for (let e = 0, n = o + 2 * p; e < n; e++) { const n = R * e, s = R * (e + 1); H(t + r + n, t + i + n, t + i + s, t + r + s) } } } function U(e, t, n) { s.push(e), s.push(t), s.push(n) } function B(e, t, i) { z(e), z(t), z(i); const s = r.length / 3, a = f.generateTopUV(n, r, s - 3, s - 2, s - 1); G(a[0]), G(a[1]), G(a[2]) } function H(e, t, i, s) { z(e), z(t), z(s), z(t), z(i), z(s); const a = r.length / 3, o = f.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1); G(o[0]), G(o[1]), G(o[3]), G(o[1]), G(o[2]), G(o[3]) } function z(e) { r.push(s[3 * e + 0]), r.push(s[3 * e + 1]), r.push(s[3 * e + 2]) } function G(e) { i.push(e.x), i.push(e.y) } !function () { const e = r.length / 3; if (c) { let e = 0, t = R * e; for (let e = 0; e < L; e++) { const n = E[e]; B(n[2] + t, n[1] + t, n[0] + t) } t = R * (e = o + 2 * p); for (let e = 0; e < L; e++) { const n = E[e]; B(n[0] + t, n[1] + t, n[2] + t) } } else { for (let e = 0; e < L; e++) { const t = E[e]; B(t[2], t[1], t[0]) } for (let e = 0; e < L; e++) { const t = E[e]; B(t[0] + R * o, t[1] + R * o, t[2] + R * o) } } n.addGroup(e, r.length / 3 - e, 0) }(), function () { const e = r.length / 3; let t = 0; O(S, t), t += S.length; for (let e = 0, n = T.length; e < n; e++) { const n = T[e]; O(n, t), t += n.length } n.addGroup(e, r.length / 3 - e, 1) }() } this.setAttribute("position", new di(r, 3)), this.setAttribute("uv", new di(i, 2)), this.computeVertexNormals() } toJSON() { const e = super.toJSON(); return function (e, t, n) { if (n.shapes = [], Array.isArray(e)) for (let t = 0, r = e.length; t < r; t++) { const r = e[t]; n.shapes.push(r.uuid) } else n.shapes.push(e.uuid); void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()); return n }(this.parameters.shapes, this.parameters.options, e) } static fromJSON(e, t) { const n = []; for (let r = 0, i = e.shapes.length; r < i; r++) { const i = t[e.shapes[r]]; n.push(i) } const r = e.options.extrudePath; return void 0 !== r && (e.options.extrudePath = (new Vc[r.type]).fromJSON(r)), new yh(n, e.options) } } const xh = { generateTopUV: function (e, t, n, r, i) { const s = t[3 * n], a = t[3 * n + 1], o = t[3 * r], l = t[3 * r + 1], c = t[3 * i], h = t[3 * i + 1]; return [new gn(s, a), new gn(o, l), new gn(c, h)] }, generateSideWallUV: function (e, t, n, r, i, s) { const a = t[3 * n], o = t[3 * n + 1], l = t[3 * n + 2], c = t[3 * r], h = t[3 * r + 1], u = t[3 * r + 2], d = t[3 * i], p = t[3 * i + 1], m = t[3 * i + 2], f = t[3 * s], g = t[3 * s + 1], v = t[3 * s + 2]; return Math.abs(o - h) < Math.abs(a - c) ? [new gn(a, 1 - l), new gn(c, 1 - u), new gn(d, 1 - m), new gn(f, 1 - v)] : [new gn(o, 1 - l), new gn(h, 1 - u), new gn(p, 1 - m), new gn(g, 1 - v)] } }; class _h extends vc { constructor(e = 1, t = 0) { const n = (1 + Math.sqrt(5)) / 2; super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new _h(e.radius, e.detail) } } class bh extends Ti { constructor(e, t = 12, n = 0, r = 2 * Math.PI) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, t = Math.floor(t), r = cn(r, 0, 2 * Math.PI); const i = [], s = [], a = [], o = 1 / t, l = new Pn, c = new gn; for (let i = 0; i <= t; i++) { const h = n + i * o * r, u = Math.sin(h), d = Math.cos(h); for (let n = 0; n <= e.length - 1; n++)l.x = e[n].x * u, l.y = e[n].y, l.z = e[n].x * d, s.push(l.x, l.y, l.z), c.x = i / t, c.y = n / (e.length - 1), a.push(c.x, c.y) } for (let n = 0; n < t; n++)for (let t = 0; t < e.length - 1; t++) { const r = t + n * e.length, s = r, a = r + e.length, o = r + e.length + 1, l = r + 1; i.push(s, a, l), i.push(a, o, l) } if (this.setIndex(i), this.setAttribute("position", new di(s, 3)), this.setAttribute("uv", new di(a, 2)), this.computeVertexNormals(), r === 2 * Math.PI) { const n = this.attributes.normal.array, r = new Pn, i = new Pn, s = new Pn, a = t * e.length * 3; for (let t = 0, o = 0; t < e.length; t++, o += 3)r.x = n[o + 0], r.y = n[o + 1], r.z = n[o + 2], i.x = n[a + o + 0], i.y = n[a + o + 1], i.z = n[a + o + 2], s.addVectors(r, i).normalize(), n[o + 0] = n[a + o + 0] = s.x, n[o + 1] = n[a + o + 1] = s.y, n[o + 2] = n[a + o + 2] = s.z } } static fromJSON(e) { return new bh(e.points, e.segments, e.phiStart, e.phiLength) } } class wh extends vc { constructor(e = 1, t = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new wh(e.radius, e.detail) } } class Mh extends Ti { constructor(e, t, n) { super(), this.type = "ParametricGeometry", this.parameters = { func: e, slices: t, stacks: n }; const r = [], i = [], s = [], a = [], o = new Pn, l = new Pn, c = new Pn, h = new Pn, u = new Pn; e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); const d = t + 1; for (let r = 0; r <= n; r++) { const d = r / n; for (let n = 0; n <= t; n++) { const r = n / t; e(r, d, l), i.push(l.x, l.y, l.z), r - 1e-5 >= 0 ? (e(r - 1e-5, d, c), h.subVectors(l, c)) : (e(r + 1e-5, d, c), h.subVectors(c, l)), d - 1e-5 >= 0 ? (e(r, d - 1e-5, c), u.subVectors(l, c)) : (e(r, d + 1e-5, c), u.subVectors(c, l)), o.crossVectors(h, u).normalize(), s.push(o.x, o.y, o.z), a.push(r, d) } } for (let e = 0; e < n; e++)for (let n = 0; n < t; n++) { const t = e * d + n, i = e * d + n + 1, s = (e + 1) * d + n + 1, a = (e + 1) * d + n; r.push(t, i, a), r.push(i, s, a) } this.setIndex(r), this.setAttribute("position", new di(i, 3)), this.setAttribute("normal", new di(s, 3)), this.setAttribute("uv", new di(a, 2)) } } class Th extends Ti { constructor(e = .5, t = 1, n = 8, r = 1, i = 0, s = 2 * Math.PI) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: s }, n = Math.max(3, n); const a = [], o = [], l = [], c = []; let h = e; const u = (t - e) / (r = Math.max(1, r)), d = new Pn, p = new gn; for (let e = 0; e <= r; e++) { for (let e = 0; e <= n; e++) { const r = i + e / n * s; d.x = h * Math.cos(r), d.y = h * Math.sin(r), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, c.push(p.x, p.y) } h += u } for (let e = 0; e < r; e++) { const t = e * (n + 1); for (let e = 0; e < n; e++) { const r = e + t, i = r, s = r + n + 1, o = r + n + 2, l = r + 1; a.push(i, s, l), a.push(s, o, l) } } this.setIndex(a), this.setAttribute("position", new di(o, 3)), this.setAttribute("normal", new di(l, 3)), this.setAttribute("uv", new di(c, 2)) } static fromJSON(e) { return new Th(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class Eh extends Ti { constructor(e, t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const n = [], r = [], i = [], s = []; let a = 0, o = 0; if (!1 === Array.isArray(e)) l(e); else for (let t = 0; t < e.length; t++)l(e[t]), this.addGroup(a, o, t), a += o, o = 0; function l(e) { const a = r.length / 3, l = e.extractPoints(t); let c = l.shape; const h = l.holes; !1 === fh.isClockWise(c) && (c = c.reverse()); for (let e = 0, t = h.length; e < t; e++) { const t = h[e]; !0 === fh.isClockWise(t) && (h[e] = t.reverse()) } const u = fh.triangulateShape(c, h); for (let e = 0, t = h.length; e < t; e++) { const t = h[e]; c = c.concat(t) } for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; r.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y) } for (let e = 0, t = u.length; e < t; e++) { const t = u[e], r = t[0] + a, i = t[1] + a, s = t[2] + a; n.push(r, i, s), o += 3 } } this.setIndex(n), this.setAttribute("position", new di(r, 3)), this.setAttribute("normal", new di(i, 3)), this.setAttribute("uv", new di(s, 2)) } toJSON() { const e = super.toJSON(); return function (e, t) { if (t.shapes = [], Array.isArray(e)) for (let n = 0, r = e.length; n < r; n++) { const r = e[n]; t.shapes.push(r.uuid) } else t.shapes.push(e.uuid); return t }(this.parameters.shapes, e) } static fromJSON(e, t) { const n = []; for (let r = 0, i = e.shapes.length; r < i; r++) { const i = t[e.shapes[r]]; n.push(i) } return new Eh(n, e.curveSegments) } } class Sh extends Ti { constructor(e = 1, t = 32, n = 16, r = 0, i = 2 * Math.PI, s = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: i, thetaStart: s, thetaLength: a }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n)); const o = Math.min(s + a, Math.PI); let l = 0; const c = [], h = new Pn, u = new Pn, d = [], p = [], m = [], f = []; for (let d = 0; d <= n; d++) { const g = [], v = d / n; let y = 0; 0 == d && 0 == s ? y = .5 / t : d == n && o == Math.PI && (y = -.5 / t); for (let n = 0; n <= t; n++) { const o = n / t; h.x = -e * Math.cos(r + o * i) * Math.sin(s + v * a), h.y = e * Math.cos(s + v * a), h.z = e * Math.sin(r + o * i) * Math.sin(s + v * a), p.push(h.x, h.y, h.z), u.copy(h).normalize(), m.push(u.x, u.y, u.z), f.push(o + y, 1 - v), g.push(l++) } c.push(g) } for (let e = 0; e < n; e++)for (let r = 0; r < t; r++) { const t = c[e][r + 1], i = c[e][r], a = c[e + 1][r], l = c[e + 1][r + 1]; (0 !== e || s > 0) && d.push(t, i, l), (e !== n - 1 || o < Math.PI) && d.push(i, a, l) } this.setIndex(d), this.setAttribute("position", new di(p, 3)), this.setAttribute("normal", new di(m, 3)), this.setAttribute("uv", new di(f, 2)) } static fromJSON(e) { return new Sh(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class Ah extends vc { constructor(e = 1, t = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Ah(e.radius, e.detail) } } class Rh extends yh { constructor(e, t = {}) { const n = t.font; if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Ti; const r = n.generateShapes(e, t.size); t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), super(r, t), this.type = "TextGeometry" } } class Lh extends Ti { constructor(e = 1, t = .4, n = 8, r = 6, i = 2 * Math.PI) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: i }, n = Math.floor(n), r = Math.floor(r); const s = [], a = [], o = [], l = [], c = new Pn, h = new Pn, u = new Pn; for (let s = 0; s <= n; s++)for (let d = 0; d <= r; d++) { const p = d / r * i, m = s / n * Math.PI * 2; h.x = (e + t * Math.cos(m)) * Math.cos(p), h.y = (e + t * Math.cos(m)) * Math.sin(p), h.z = t * Math.sin(m), a.push(h.x, h.y, h.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), u.subVectors(h, c).normalize(), o.push(u.x, u.y, u.z), l.push(d / r), l.push(s / n) } for (let e = 1; e <= n; e++)for (let t = 1; t <= r; t++) { const n = (r + 1) * e + t - 1, i = (r + 1) * (e - 1) + t - 1, a = (r + 1) * (e - 1) + t, o = (r + 1) * e + t; s.push(n, i, o), s.push(i, a, o) } this.setIndex(s), this.setAttribute("position", new di(a, 3)), this.setAttribute("normal", new di(o, 3)), this.setAttribute("uv", new di(l, 2)) } static fromJSON(e) { return new Lh(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class Ch extends Ti { constructor(e = 1, t = .4, n = 64, r = 8, i = 2, s = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: i, q: s }, n = Math.floor(n), r = Math.floor(r); const a = [], o = [], l = [], c = [], h = new Pn, u = new Pn, d = new Pn, p = new Pn, m = new Pn, f = new Pn, g = new Pn; for (let a = 0; a <= n; ++a) { const y = a / n * i * Math.PI * 2; v(y, i, s, e, d), v(y + .01, i, s, e, p), f.subVectors(p, d), g.addVectors(p, d), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize(); for (let e = 0; e <= r; ++e) { const i = e / r * Math.PI * 2, s = -t * Math.cos(i), p = t * Math.sin(i); h.x = d.x + (s * g.x + p * m.x), h.y = d.y + (s * g.y + p * m.y), h.z = d.z + (s * g.z + p * m.z), o.push(h.x, h.y, h.z), u.subVectors(h, d).normalize(), l.push(u.x, u.y, u.z), c.push(a / n), c.push(e / r) } } for (let e = 1; e <= n; e++)for (let t = 1; t <= r; t++) { const n = (r + 1) * (e - 1) + (t - 1), i = (r + 1) * e + (t - 1), s = (r + 1) * e + t, o = (r + 1) * (e - 1) + t; a.push(n, i, o), a.push(i, s, o) } function v(e, t, n, r, i) { const s = Math.cos(e), a = Math.sin(e), o = n / t * e, l = Math.cos(o); i.x = r * (2 + l) * .5 * s, i.y = r * (2 + l) * a * .5, i.z = r * Math.sin(o) * .5 } this.setIndex(a), this.setAttribute("position", new di(o, 3)), this.setAttribute("normal", new di(l, 3)), this.setAttribute("uv", new di(c, 2)) } static fromJSON(e) { return new Ch(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class Ph extends Ti { constructor(e, t = 64, n = 1, r = 8, i = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: i }; const s = e.computeFrenetFrames(t, i); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals; const a = new Pn, o = new Pn, l = new gn; let c = new Pn; const h = [], u = [], d = [], p = []; function m(i) { c = e.getPointAt(i / t, c); const l = s.normals[i], d = s.binormals[i]; for (let e = 0; e <= r; e++) { const t = e / r * Math.PI * 2, i = Math.sin(t), s = -Math.cos(t); o.x = s * l.x + i * d.x, o.y = s * l.y + i * d.y, o.z = s * l.z + i * d.z, o.normalize(), u.push(o.x, o.y, o.z), a.x = c.x + n * o.x, a.y = c.y + n * o.y, a.z = c.z + n * o.z, h.push(a.x, a.y, a.z) } } !function () { for (let e = 0; e < t; e++)m(e); m(!1 === i ? t : 0), function () { for (let e = 0; e <= t; e++)for (let n = 0; n <= r; n++)l.x = e / t, l.y = n / r, d.push(l.x, l.y) }(), function () { for (let e = 1; e <= t; e++)for (let t = 1; t <= r; t++) { const n = (r + 1) * (e - 1) + (t - 1), i = (r + 1) * e + (t - 1), s = (r + 1) * e + t, a = (r + 1) * (e - 1) + t; p.push(n, i, a), p.push(i, s, a) } }() }(), this.setIndex(p), this.setAttribute("position", new di(h, 3)), this.setAttribute("normal", new di(u, 3)), this.setAttribute("uv", new di(d, 2)) } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new Ph((new Vc[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class Ih extends Ti { constructor(e) { if (super(), this.type = "WireframeGeometry", !0 === e.isGeometry) return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); const t = [], n = new Set, r = new Pn, i = new Pn; if (null !== e.index) { const s = e.attributes.position, a = e.index; let o = e.groups; 0 === o.length && (o = [{ start: 0, count: a.count, materialIndex: 0 }]); for (let e = 0, l = o.length; e < l; ++e) { const l = o[e], c = l.start; for (let e = c, o = c + l.count; e < o; e += 3)for (let o = 0; o < 3; o++) { const l = a.getX(e + o), c = a.getX(e + (o + 1) % 3); r.fromBufferAttribute(s, l), i.fromBufferAttribute(s, c), !0 === Nh(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z)) } } } else { const s = e.attributes.position; for (let e = 0, a = s.count / 3; e < a; e++)for (let a = 0; a < 3; a++) { const o = 3 * e + a, l = 3 * e + (a + 1) % 3; r.fromBufferAttribute(s, o), i.fromBufferAttribute(s, l), !0 === Nh(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z)) } } this.setAttribute("position", new di(t, 3)) } } function Nh(e, t, n) { const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`, i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`; return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r, i), !0) } var Dh = Object.freeze({ __proto__: null, BoxGeometry: Wi, BoxBufferGeometry: Wi, CircleGeometry: mc, CircleBufferGeometry: mc, ConeGeometry: gc, ConeBufferGeometry: gc, CylinderGeometry: fc, CylinderBufferGeometry: fc, DodecahedronGeometry: yc, DodecahedronBufferGeometry: yc, EdgesGeometry: Mc, ExtrudeGeometry: yh, ExtrudeBufferGeometry: yh, IcosahedronGeometry: _h, IcosahedronBufferGeometry: _h, LatheGeometry: bh, LatheBufferGeometry: bh, OctahedronGeometry: wh, OctahedronBufferGeometry: wh, ParametricGeometry: Mh, ParametricBufferGeometry: Mh, PlaneGeometry: ps, PlaneBufferGeometry: ps, PolyhedronGeometry: vc, PolyhedronBufferGeometry: vc, RingGeometry: Th, RingBufferGeometry: Th, ShapeGeometry: Eh, ShapeBufferGeometry: Eh, SphereGeometry: Sh, SphereBufferGeometry: Sh, TetrahedronGeometry: Ah, TetrahedronBufferGeometry: Ah, TextGeometry: Rh, TextBufferGeometry: Rh, TorusGeometry: Lh, TorusBufferGeometry: Lh, TorusKnotGeometry: Ch, TorusKnotBufferGeometry: Ch, TubeGeometry: Ph, TubeBufferGeometry: Ph, WireframeGeometry: Ih }); class Fh extends Xr { constructor(e) { super(), this.type = "ShadowMaterial", this.color = new $r(0), this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this } } Fh.prototype.isShadowMaterial = !0; class Oh extends Xr { constructor(e) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new $r(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $r(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zt, this.normalScale = new gn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } Oh.prototype.isMeshStandardMaterial = !0; class Uh extends Oh { constructor(e) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new gn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return cn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (e) { this.ior = (1 + .4 * e) / (1 - .4 * e) } }), this.sheenTint = new $r(0), this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new $r(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new $r(1, 1, 1), this.specularTintMap = null, this._clearcoat = 0, this._transmission = 0, this.setValues(e) } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheenTint.copy(e.sheenTint), this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationTint.copy(e.attenuationTint), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularTint.copy(e.specularTint), this.specularTintMap = e.specularTintMap, this } } Uh.prototype.isMeshPhysicalMaterial = !0; class Bh extends Xr { constructor(e) { super(), this.type = "MeshPhongMaterial", this.color = new $r(16777215), this.specular = new $r(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $r(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zt, this.normalScale = new gn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } Bh.prototype.isMeshPhongMaterial = !0; class Hh extends Xr { constructor(e) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new $r(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $r(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zt, this.normalScale = new gn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } Hh.prototype.isMeshToonMaterial = !0; class zh extends Xr { constructor(e) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zt, this.normalScale = new gn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } zh.prototype.isMeshNormalMaterial = !0; class Gh extends Xr { constructor(e) { super(), this.type = "MeshLambertMaterial", this.color = new $r(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $r(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = V, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } Gh.prototype.isMeshLambertMaterial = !0; class kh extends Xr { constructor(e) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new $r(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zt, this.normalScale = new gn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this } } kh.prototype.isMeshMatcapMaterial = !0; class Vh extends Xl { constructor(e) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } Vh.prototype.isLineDashedMaterial = !0; var Wh = Object.freeze({ __proto__: null, ShadowMaterial: Fh, SpriteMaterial: hl, RawShaderMaterial: Ts, ShaderMaterial: Ji, PointsMaterial: rc, MeshPhysicalMaterial: Uh, MeshStandardMaterial: Oh, MeshPhongMaterial: Bh, MeshToonMaterial: Hh, MeshNormalMaterial: zh, MeshLambertMaterial: Gh, MeshDepthMaterial: ko, MeshDistanceMaterial: Vo, MeshBasicMaterial: ei, MeshMatcapMaterial: kh, LineDashedMaterial: Vh, LineBasicMaterial: Xl, Material: Xr }); const jh = { arraySlice: function (e, t, n) { return jh.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n) }, convertArray: function (e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function (e) { const t = e.length, n = new Array(t); for (let e = 0; e !== t; ++e)n[e] = e; return n.sort(function (t, n) { return e[t] - e[n] }), n }, sortedArray: function (e, t, n) { const r = e.length, i = new e.constructor(r); for (let s = 0, a = 0; a !== r; ++s) { const r = n[s] * t; for (let n = 0; n !== t; ++n)i[a++] = e[r + n] } return i }, flattenJSON: function (e, t, n, r) { let i = 1, s = e[0]; for (; void 0 !== s && void 0 === s[r];)s = e[i++]; if (void 0 === s) return; let a = s[r]; if (void 0 !== a) if (Array.isArray(a)) do { void 0 !== (a = s[r]) && (t.push(s.time), n.push.apply(n, a)), s = e[i++] } while (void 0 !== s); else if (void 0 !== a.toArray) do { void 0 !== (a = s[r]) && (t.push(s.time), a.toArray(n, n.length)), s = e[i++] } while (void 0 !== s); else do { void 0 !== (a = s[r]) && (t.push(s.time), n.push(a)), s = e[i++] } while (void 0 !== s) }, subclip: function (e, t, n, r, i = 30) { const s = e.clone(); s.name = t; const a = []; for (let e = 0; e < s.tracks.length; ++e) { const t = s.tracks[e], o = t.getValueSize(), l = [], c = []; for (let e = 0; e < t.times.length; ++e) { const s = t.times[e] * i; if (!(s < n || s >= r)) { l.push(t.times[e]); for (let n = 0; n < o; ++n)c.push(t.values[e * o + n]) } } 0 !== l.length && (t.times = jh.convertArray(l, t.times.constructor), t.values = jh.convertArray(c, t.values.constructor), a.push(t)) } s.tracks = a; let o = 1 / 0; for (let e = 0; e < s.tracks.length; ++e)o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]); for (let e = 0; e < s.tracks.length; ++e)s.tracks[e].shift(-1 * o); return s.resetDuration(), s }, makeClipAdditive: function (e, t = 0, n = e, r = 30) { r <= 0 && (r = 30); const i = n.tracks.length, s = t / r; for (let t = 0; t < i; ++t) { const r = n.tracks[t], i = r.ValueTypeName; if ("bool" === i || "string" === i) continue; const a = e.tracks.find(function (e) { return e.name === r.name && e.ValueTypeName === i }); if (void 0 === a) continue; let o = 0; const l = r.getValueSize(); r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3); let c = 0; const h = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3); const u = r.times.length - 1; let d; if (s <= r.times[0]) { const e = o, t = l - o; d = jh.arraySlice(r.values, e, t) } else if (s >= r.times[u]) { const e = u * l + o, t = e + l - o; d = jh.arraySlice(r.values, e, t) } else { const e = r.createInterpolant(), t = o, n = l - o; e.evaluate(s), d = jh.arraySlice(e.resultBuffer, t, n) } if ("quaternion" === i) { (new Cn).fromArray(d).normalize().conjugate().toArray(d) } const p = a.times.length; for (let e = 0; e < p; ++e) { const t = e * h + c; if ("quaternion" === i) Cn.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t); else { const e = h - 2 * c; for (let n = 0; n < e; ++n)a.values[t + n] -= d[n] } } } return e.blendMode = Ot, e } }; class Xh { constructor(e, t, n, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let n = this._cachedIndex, r = t[n], i = t[n - 1]; e: { t: { let s; n: { r: if (!(e < r)) { for (let s = n + 2; ;) { if (void 0 === r) { if (e < i) break r; return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i) } if (n === s) break; if (i = r, e < (r = t[++n])) break t } s = t.length; break n } if (e >= i) break e; { const a = t[1]; e < a && (n = 2, i = a); for (let s = n - 2; ;) { if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r); if (n === s) break; if (r = i, e >= (i = t[--n - 1])) break t } s = n, n = 0 } } for (; n < s;) { const r = n + s >>> 1; e < t[r] ? s = r : n = r + 1 } if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r); if (void 0 === r) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, e) } this._cachedIndex = n, this.intervalChanged_(n, i, r) } return this.interpolate_(n, i, e, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r; for (let e = 0; e !== r; ++e)t[e] = n[i + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } Xh.prototype.beforeStart_ = Xh.prototype.copySampleValue_, Xh.prototype.afterEnd_ = Xh.prototype.copySampleValue_; class qh extends Xh { constructor(e, t, n, r) { super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: It, endingEnd: It } } intervalChanged_(e, t, n) { const r = this.parameterPositions; let i = e - 2, s = e + 1, a = r[i], o = r[s]; if (void 0 === a) switch (this.getSettings_().endingStart) { case Nt: i = e, a = 2 * t - n; break; case Dt: a = t + r[i = r.length - 2] - r[i + 1]; break; default: i = e, a = n }if (void 0 === o) switch (this.getSettings_().endingEnd) { case Nt: s = e, o = 2 * n - t; break; case Dt: s = 1, o = n + r[1] - r[0]; break; default: s = e - 1, o = t }const l = .5 * (n - t), c = this.valueSize; this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = i * c, this._offsetNext = s * c } interpolate_(e, t, n, r) { const i = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (n - t) / (r - t), m = p * p, f = m * p, g = -u * f + 2 * u * m - u * p, v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1, y = (-1 - d) * f + (1.5 + d) * m + .5 * p, x = d * f - d * m; for (let e = 0; e !== a; ++e)i[e] = g * s[c + e] + v * s[l + e] + y * s[o + e] + x * s[h + e]; return i } } class Yh extends Xh { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { const i = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = (n - t) / (r - t), h = 1 - c; for (let e = 0; e !== a; ++e)i[e] = s[l + e] * h + s[o + e] * c; return i } } class Zh extends Xh { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class Jh { constructor(e, t, n, r) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = jh.convertArray(t, this.TimeBufferType), this.values = jh.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let n; if (t.toJSON !== this.toJSON) n = t.toJSON(e); else { n = { name: e.name, times: jh.convertArray(e.times, Array), values: jh.convertArray(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (n.interpolation = t) } return n.type = e.ValueTypeName, n } InterpolantFactoryMethodDiscrete(e) { return new Zh(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new Yh(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new qh(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case Lt: t = this.InterpolantFactoryMethodDiscrete; break; case Ct: t = this.InterpolantFactoryMethodLinear; break; case Pt: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return Lt; case this.InterpolantFactoryMethodLinear: return Ct; case this.InterpolantFactoryMethodSmooth: return Pt } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { const t = this.times; for (let n = 0, r = t.length; n !== r; ++n)t[n] += e } return this } scale(e) { if (1 !== e) { const t = this.times; for (let n = 0, r = t.length; n !== r; ++n)t[n] *= e } return this } trim(e, t) { const n = this.times, r = n.length; let i = 0, s = r - 1; for (; i !== r && n[i] < e;)++i; for (; -1 !== s && n[s] > t;)--s; if (++s, 0 !== i || s !== r) { i >= s && (i = (s = Math.max(s, 1)) - 1); const e = this.getValueSize(); this.times = jh.arraySlice(n, i, s), this.values = jh.arraySlice(this.values, i * e, s * e) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const n = this.times, r = this.values, i = n.length; 0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let s = null; for (let t = 0; t !== i; t++) { const r = n[t]; if ("number" == typeof r && isNaN(r)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r), e = !1; break } if (null !== s && s > r) { console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, s), e = !1; break } s = r } if (void 0 !== r && jh.isTypedArray(r)) for (let t = 0, n = r.length; t !== n; ++t) { const n = r[t]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1; break } } return e } optimize() { const e = jh.arraySlice(this.times), t = jh.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === Pt, i = e.length - 1; let s = 1; for (let a = 1; a < i; ++a) { let i = !1; const o = e[a]; if (o !== e[a + 1] && (1 !== a || o !== e[0])) if (r) i = !0; else { const e = a * n, r = e - n, s = e + n; for (let a = 0; a !== n; ++a) { const n = t[e + a]; if (n !== t[r + a] || n !== t[s + a]) { i = !0; break } } } if (i) { if (a !== s) { e[s] = e[a]; const r = a * n, i = s * n; for (let e = 0; e !== n; ++e)t[i + e] = t[r + e] } ++s } } if (i > 0) { e[s] = e[i]; for (let e = i * n, r = s * n, a = 0; a !== n; ++a)t[r + a] = t[e + a]; ++s } return s !== e.length ? (this.times = jh.arraySlice(e, 0, s), this.values = jh.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this } clone() { const e = jh.arraySlice(this.times, 0), t = jh.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, e, t); return n.createInterpolant = this.createInterpolant, n } } Jh.prototype.TimeBufferType = Float32Array, Jh.prototype.ValueBufferType = Float32Array, Jh.prototype.DefaultInterpolation = Ct; class Kh extends Jh { } Kh.prototype.ValueTypeName = "bool", Kh.prototype.ValueBufferType = Array, Kh.prototype.DefaultInterpolation = Lt, Kh.prototype.InterpolantFactoryMethodLinear = void 0, Kh.prototype.InterpolantFactoryMethodSmooth = void 0; class Qh extends Jh { } Qh.prototype.ValueTypeName = "color"; class $h extends Jh { } $h.prototype.ValueTypeName = "number"; class eu extends Xh { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { const i = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = (n - t) / (r - t); let l = e * a; for (let e = l + a; l !== e; l += 4)Cn.slerpFlat(i, 0, s, l - a, s, l, o); return i } } class tu extends Jh { InterpolantFactoryMethodLinear(e) { return new eu(this.times, this.values, this.getValueSize(), e) } } tu.prototype.ValueTypeName = "quaternion", tu.prototype.DefaultInterpolation = Ct, tu.prototype.InterpolantFactoryMethodSmooth = void 0; class nu extends Jh { } nu.prototype.ValueTypeName = "string", nu.prototype.ValueBufferType = Array, nu.prototype.DefaultInterpolation = Lt, nu.prototype.InterpolantFactoryMethodLinear = void 0, nu.prototype.InterpolantFactoryMethodSmooth = void 0; class ru extends Jh { } ru.prototype.ValueTypeName = "vector"; class iu { constructor(e, t = -1, n, r = Ft) { this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = ln(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], n = e.tracks, r = 1 / (e.fps || 1); for (let e = 0, i = n.length; e !== i; ++e)t.push(su(n[e]).scale(r)); const i = new this(e.name, e.duration, t, e.blendMode); return i.uuid = e.uuid, i } static toJSON(e) { const t = [], n = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, r = n.length; e !== r; ++e)t.push(Jh.toJSON(n[e])); return r } static CreateFromMorphTargetSequence(e, t, n, r) { const i = t.length, s = []; for (let e = 0; e < i; e++) { let a = [], o = []; a.push((e + i - 1) % i, e, (e + 1) % i), o.push(0, 1, 0); const l = jh.getKeyframeOrder(a); a = jh.sortedArray(a, 1, l), o = jh.sortedArray(o, 1, l), r || 0 !== a[0] || (a.push(i), o.push(o[0])), s.push(new $h(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / n)) } return new this(e, -1, s) } static findByName(e, t) { let n = e; if (!Array.isArray(e)) { const t = e; n = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < n.length; e++)if (n[e].name === t) return n[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, n) { const r = {}, i = /^([\w-]*?)([\d]+)$/; for (let t = 0, n = e.length; t < n; t++) { const n = e[t], s = n.name.match(i); if (s && s.length > 1) { const e = s[1]; let t = r[e]; t || (r[e] = t = []), t.push(n) } } const s = []; for (const e in r) s.push(this.CreateFromMorphTargetSequence(e, r[e], t, n)); return s } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (e, t, n, r, i) { if (0 !== n.length) { const s = [], a = []; jh.flattenJSON(n, s, a, r), 0 !== s.length && i.push(new e(t, s, a)) } }, r = [], i = e.name || "default", s = e.fps || 30, a = e.blendMode; let o = e.length || -1; const l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { const i = l[e].keys; if (i && 0 !== i.length) if (i[0].morphTargets) { const e = {}; let t; for (t = 0; t < i.length; t++)if (i[t].morphTargets) for (let n = 0; n < i[t].morphTargets.length; n++)e[i[t].morphTargets[n]] = -1; for (const n in e) { const e = [], s = []; for (let r = 0; r !== i[t].morphTargets.length; ++r) { const r = i[t]; e.push(r.time), s.push(r.morphTarget === n ? 1 : 0) } r.push(new $h(".morphTargetInfluence[" + n + "]", e, s)) } o = e.length * (s || 1) } else { const s = ".bones[" + t[e].name + "]"; n(ru, s + ".position", i, "pos", r), n(tu, s + ".quaternion", i, "rot", r), n(ru, s + ".scale", i, "scl", r) } } return 0 === r.length ? null : new this(i, o, r, a) } resetDuration() { let e = 0; for (let t = 0, n = this.tracks.length; t !== n; ++t) { const n = this.tracks[t]; e = Math.max(e, n.times[n.times.length - 1]) } return this.duration = e, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function su(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return $h; case "vector": case "vector2": case "vector3": case "vector4": return ru; case "color": return Qh; case "quaternion": return tu; case "bool": case "boolean": return Kh; case "string": return nu }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], n = []; jh.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } const au = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class ou { constructor(e, t, n) { const r = this; let i = !1, s = 0, a = 0, o = void 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) { a++, !1 === i && void 0 !== r.onStart && r.onStart(e, s, a), i = !0 }, this.itemEnd = function (e) { s++, void 0 !== r.onProgress && r.onProgress(e, s, a), s === a && (i = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (e) { void 0 !== r.onError && r.onError(e) }, this.resolveURL = function (e) { return o ? o(e) : e }, this.setURLModifier = function (e) { return o = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { const t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, n = l.length; t < n; t += 2) { const n = l[t], r = l[t + 1]; if (n.global && (n.lastIndex = 0), n.test(e)) return r } return null } } } const lu = new ou; class cu { constructor(e) { this.manager = void 0 !== e ? e : lu, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const n = this; return new Promise(function (r, i) { n.load(e, r, t, i) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const hu = {}; class uu extends cu { constructor(e) { super(e) } load(e, t, n, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const i = this, s = au.get(e); if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function () { t && t(s), i.manager.itemEnd(e) }, 0), s; if (void 0 !== hu[e]) return void hu[e].push({ onLoad: t, onProgress: n, onError: r }); const a = e.match(/^data:(.*?)(;base64)?,(.*)$/); let o; if (a) { const n = a[1], s = !!a[2]; let o = a[3]; o = decodeURIComponent(o), s && (o = atob(o)); try { let s; const a = (this.responseType || "").toLowerCase(); switch (a) { case "arraybuffer": case "blob": const e = new Uint8Array(o.length); for (let t = 0; t < o.length; t++)e[t] = o.charCodeAt(t); s = "blob" === a ? new Blob([e.buffer], { type: n }) : e.buffer; break; case "document": const t = new DOMParser; s = t.parseFromString(o, n); break; case "json": s = JSON.parse(o); break; default: s = o }setTimeout(function () { t && t(s), i.manager.itemEnd(e) }, 0) } catch (t) { setTimeout(function () { r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) }, 0) } } else { hu[e] = [], hu[e].push({ onLoad: t, onProgress: n, onError: r }), (o = new XMLHttpRequest).open("GET", e, !0), o.addEventListener("load", function (t) { const n = this.response, r = hu[e]; if (delete hu[e], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), au.add(e, n); for (let e = 0, t = r.length; e < t; e++) { const t = r[e]; t.onLoad && t.onLoad(n) } i.manager.itemEnd(e) } else { for (let e = 0, n = r.length; e < n; e++) { const n = r[e]; n.onError && n.onError(t) } i.manager.itemError(e), i.manager.itemEnd(e) } }, !1), o.addEventListener("progress", function (t) { const n = hu[e]; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; r.onProgress && r.onProgress(t) } }, !1), o.addEventListener("error", function (t) { const n = hu[e]; delete hu[e]; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; r.onError && r.onError(t) } i.manager.itemError(e), i.manager.itemEnd(e) }, !1), o.addEventListener("abort", function (t) { const n = hu[e]; delete hu[e]; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; r.onError && r.onError(t) } i.manager.itemError(e), i.manager.itemEnd(e) }, !1), void 0 !== this.responseType && (o.responseType = this.responseType), void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials), o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const e in this.requestHeader) o.setRequestHeader(e, this.requestHeader[e]); o.send(null) } return i.manager.itemStart(e), o } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class du extends cu { constructor(e) { super(e) } load(e, t, n, r) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const i = this, s = au.get(e); if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function () { t && t(s), i.manager.itemEnd(e) }, 0), s; const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function o() { a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), au.add(e, this), t && t(this), i.manager.itemEnd(e) } function l(t) { a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) } return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a } } class pu extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = new ns, s = new du(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let a = 0; function o(n) { s.load(e[n], function (e) { i.images[n] = e, 6 === ++a && (i.needsUpdate = !0, t && t(i)) }, void 0, r) } for (let t = 0; t < e.length; ++t)o(t); return i } } class mu extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = new Ol, a = new uu(this.manager); return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(i.withCredentials), a.load(e, function (e) { const n = i.parse(e); n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : ae, s.wrapT = void 0 !== n.wrapT ? n.wrapT : ae, s.magFilter = void 0 !== n.magFilter ? n.magFilter : ue, s.minFilter = void 0 !== n.minFilter ? n.minFilter : ue, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = pe), 1 === n.mipmapCount && (s.minFilter = ue), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, t && t(s, n)) }, n, r), s } } class fu extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = new bn, s = new du(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function (n) { i.image = n; const r = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/); i.format = r ? Ae : Re, i.needsUpdate = !0, void 0 !== t && t(i) }, n, r), i } } class gu extends Tc { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new Bc(t, e)) } getPoint(e) { const t = e * this.getLength(), n = this.getCurveLengths(); let r = 0; for (; r < n.length;) { if (n[r] >= t) { const e = n[r] - t, i = this.curves[r], s = i.getLength(), a = 0 === s ? 0 : 1 - e / s; return i.getPointAt(a) } r++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let n = 0, r = this.curves.length; n < r; n++)t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let n; for (let r = 0, i = this.curves; r < i.length; r++) { const s = i[r], a = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e, o = s.getPoints(a); for (let e = 0; e < o.length; e++) { const r = o[e]; n && n.equals(r) || (t.push(r), n = r) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push(n.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, n = this.curves.length; t < n; t++) { const n = this.curves[t]; e.curves.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push((new Vc[n.type]).fromJSON(n)) } return this } } class vu extends gu { constructor(e) { super(), this.type = "Path", this.currentPoint = new gn, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, n = e.length; t < n; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const n = new Bc(this.currentPoint.clone(), new gn(e, t)); return this.curves.push(n), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, n, r) { const i = new zc(this.currentPoint.clone(), new gn(e, t), new gn(n, r)); return this.curves.push(i), this.currentPoint.set(n, r), this } bezierCurveTo(e, t, n, r, i, s) { const a = new Oc(this.currentPoint.clone(), new gn(e, t), new gn(n, r), new gn(i, s)); return this.curves.push(a), this.currentPoint.set(i, s), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), n = new kc(t); return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, n, r, i, s) { const a = this.currentPoint.x, o = this.currentPoint.y; return this.absarc(e + a, t + o, n, r, i, s), this } absarc(e, t, n, r, i, s) { return this.absellipse(e, t, n, n, r, i, s), this } ellipse(e, t, n, r, i, s, a, o) { const l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, n, r, i, s, a, o), this } absellipse(e, t, n, r, i, s, a, o) { const l = new Ec(e, t, n, r, i, s, a, o); if (this.curves.length > 0) { const e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } this.curves.push(l); const c = l.getPoint(1); return this.currentPoint.copy(c), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class yu extends vu { constructor(e) { super(e), this.uuid = ln(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let n = 0, r = this.holes.length; n < r; n++)t[n] = this.holes[n].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, n = this.holes.length; t < n; t++) { const n = this.holes[t]; e.holes.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push((new vu).fromJSON(n)) } return this } } class xu extends Nr { constructor(e, t = 1) { super(), this.type = "Light", this.color = new $r(e), this.intensity = t } dispose() { } copy(e) { return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } } xu.prototype.isLight = !0; class _u extends xu { constructor(e, t, n) { super(e, n), this.type = "HemisphereLight", this.position.copy(Nr.DefaultUp), this.updateMatrix(), this.groundColor = new $r(t) } copy(e) { return xu.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } } _u.prototype.isHemisphereLight = !0; const bu = new lr, wu = new Pn, Mu = new Pn; class Tu { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new gn(512, 512), this.map = null, this.mapPass = null, this.matrix = new lr, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new hs, this._frameExtents = new gn(1, 1), this._viewportCount = 1, this._viewports = [new Sn(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, n = this.matrix; wu.setFromMatrixPosition(e.matrixWorld), t.position.copy(wu), Mu.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Mu), t.updateMatrixWorld(), bu.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(bu), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class Eu extends Tu { constructor() { super(new Qi(50, 1, .5, 500)), this.focus = 1 } updateMatrices(e) { const t = this.camera, n = 2 * on * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, i = e.distance || t.far; n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } Eu.prototype.isSpotLightShadow = !0; class Su extends xu { constructor(e, t, n = 0, r = Math.PI / 3, i = 0, s = 1) { super(e, t), this.type = "SpotLight", this.position.copy(Nr.DefaultUp), this.updateMatrix(), this.target = new Nr, this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.shadow = new Eu } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } Su.prototype.isSpotLight = !0; const Au = new lr, Ru = new Pn, Lu = new Pn; class Cu extends Tu { constructor() { super(new Qi(90, 1, .5, 500)), this._frameExtents = new gn(4, 2), this._viewportCount = 6, this._viewports = [new Sn(2, 1, 1, 1), new Sn(0, 1, 1, 1), new Sn(3, 1, 1, 1), new Sn(1, 1, 1, 1), new Sn(3, 0, 1, 1), new Sn(1, 0, 1, 1)], this._cubeDirections = [new Pn(1, 0, 0), new Pn(-1, 0, 0), new Pn(0, 0, 1), new Pn(0, 0, -1), new Pn(0, 1, 0), new Pn(0, -1, 0)], this._cubeUps = [new Pn(0, 1, 0), new Pn(0, 1, 0), new Pn(0, 1, 0), new Pn(0, 1, 0), new Pn(0, 0, 1), new Pn(0, 0, -1)] } updateMatrices(e, t = 0) { const n = this.camera, r = this.matrix, i = e.distance || n.far; i !== n.far && (n.far = i, n.updateProjectionMatrix()), Ru.setFromMatrixPosition(e.matrixWorld), n.position.copy(Ru), Lu.copy(n.position), Lu.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Lu), n.updateMatrixWorld(), r.makeTranslation(-Ru.x, -Ru.y, -Ru.z), Au.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Au) } } Cu.prototype.isPointLightShadow = !0; class Pu extends xu { constructor(e, t, n = 0, r = 1) { super(e, t), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Cu } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } Pu.prototype.isPointLight = !0; class Iu extends Tu { constructor() { super(new Ms(-5, 5, 5, -5, .5, 500)) } } Iu.prototype.isDirectionalLightShadow = !0; class Nu extends xu { constructor(e, t) { super(e, t), this.type = "DirectionalLight", this.position.copy(Nr.DefaultUp), this.updateMatrix(), this.target = new Nr, this.shadow = new Iu } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } Nu.prototype.isDirectionalLight = !0; class Du extends xu { constructor(e, t) { super(e, t), this.type = "AmbientLight" } } Du.prototype.isAmbientLight = !0; class Fu extends xu { constructor(e, t, n = 10, r = 10) { super(e, t), this.type = "RectAreaLight", this.width = n, this.height = r } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } Fu.prototype.isRectAreaLight = !0; class Ou { constructor() { this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new Pn) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const n = e.x, r = e.y, i = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * r), t.addScaledVector(s[2], .488603 * i), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * r * 1.092548), t.addScaledVector(s[5], r * i * 1.092548), t.addScaledVector(s[6], .315392 * (3 * i * i - 1)), t.addScaledVector(s[7], n * i * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - r * r)), t } getIrradianceAt(e, t) { const n = e.x, r = e.y, i = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * r), t.addScaledVector(s[2], 1.023328 * i), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * r), t.addScaledVector(s[5], .858086 * r * i), t.addScaledVector(s[6], .743125 * i * i - .247708), t.addScaledVector(s[7], .858086 * n * i), t.addScaledVector(s[8], .429043 * (n * n - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(e.coefficients[n], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(e.coefficients[n], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(e, t = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].fromArray(e, t + 3 * r); return this } toArray(e = [], t = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].toArray(e, t + 3 * r); return e } static getBasisAt(e, t) { const n = e.x, r = e.y, i = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r) } } Ou.prototype.isSphericalHarmonics3 = !0; class Uu extends xu { constructor(e = new Ou, t = 1) { super(void 0, t), this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } Uu.prototype.isLightProbe = !0; class Bu extends cu { constructor(e) { super(e), this.textures = {} } load(e, t, n, r) { const i = this, s = new uu(i.manager); s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } parse(e) { const t = this.textures; function n(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] } const r = new Wh[e.type]; if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheenTint && (r.sheenTint = (new $r).setHex(e.sheenTint)), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularTint && void 0 !== r.specularTint && r.specularTint.setHex(e.specularTint), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationTint && void 0 !== r.attenuationTint && r.attenuationTint.setHex(e.attenuationTint), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.format && (r.format = e.format), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms) for (const t in e.uniforms) { const i = e.uniforms[t]; switch (r.uniforms[t] = {}, i.type) { case "t": r.uniforms[t].value = n(i.value); break; case "c": r.uniforms[t].value = (new $r).setHex(i.value); break; case "v2": r.uniforms[t].value = (new gn).fromArray(i.value); break; case "v3": r.uniforms[t].value = (new Pn).fromArray(i.value); break; case "v4": r.uniforms[t].value = (new Sn).fromArray(i.value); break; case "m3": r.uniforms[t].value = (new vn).fromArray(i.value); break; case "m4": r.uniforms[t].value = (new lr).fromArray(i.value); break; default: r.uniforms[t].value = i.value } } if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions) for (const t in e.extensions) r.extensions[t] = e.extensions[t]; if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) { let t = e.normalScale; !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = (new gn).fromArray(t) } return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularTintMap && (r.specularTintMap = n(e.specularTintMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new gn).fromArray(e.clearcoatNormalScale)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), r } setTextures(e) { return this.textures = e, this } } class Hu { static decodeText(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let n = 0, r = e.length; n < r; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } } class zu extends Ti { constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = super.toJSON(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } zu.prototype.isInstancedBufferGeometry = !0; class Gu extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = new uu(i.manager); s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } parse(e) { const t = {}, n = {}; function r(e, r) { if (void 0 !== t[r]) return t[r]; const i = e.interleavedBuffers[r], s = function (e, t) { if (void 0 !== n[t]) return n[t]; const r = e.arrayBuffers[t], i = new Uint32Array(r).buffer; return n[t] = i, i }(e, i.buffer), a = gi(i.type, s), o = new ol(a, i.stride); return o.uuid = i.uuid, t[r] = o, o } const i = e.isInstancedBufferGeometry ? new zu : new Ti, s = e.data.index; if (void 0 !== s) { const e = gi(s.type, s.array); i.setIndex(new ri(e, 1)) } const a = e.data.attributes; for (const t in a) { const n = a[t]; let s; if (n.isInterleavedBufferAttribute) { const t = r(e.data, n.data); s = new cl(t, n.itemSize, n.offset, n.normalized) } else { const e = gi(n.type, n.array); s = new (n.isInstancedBufferAttribute ? zl : ri)(e, n.itemSize, n.normalized) } void 0 !== n.name && (s.name = n.name), void 0 !== n.usage && s.setUsage(n.usage), void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset, s.updateRange.count = n.updateRange.count), i.setAttribute(t, s) } const o = e.data.morphAttributes; if (o) for (const t in o) { const n = o[t], s = []; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; let a; if (i.isInterleavedBufferAttribute) { const t = r(e.data, i.data); a = new cl(t, i.itemSize, i.offset, i.normalized) } else { const e = gi(i.type, i.array); a = new ri(e, i.itemSize, i.normalized) } void 0 !== i.name && (a.name = i.name), s.push(a) } i.morphAttributes[t] = s } e.data.morphTargetsRelative && (i.morphTargetsRelative = !0); const l = e.data.groups || e.data.drawcalls || e.data.offsets; if (void 0 !== l) for (let e = 0, t = l.length; e !== t; ++e) { const t = l[e]; i.addGroup(t.start, t.count, t.materialIndex) } const c = e.data.boundingSphere; if (void 0 !== c) { const e = new Pn; void 0 !== c.center && e.fromArray(c.center), i.boundingSphere = new $n(e, c.radius) } return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i } } const ku = { UVMapping: Q, CubeReflectionMapping: $, CubeRefractionMapping: ee, EquirectangularReflectionMapping: te, EquirectangularRefractionMapping: ne, CubeUVReflectionMapping: re, CubeUVRefractionMapping: ie }, Vu = { RepeatWrapping: se, ClampToEdgeWrapping: ae, MirroredRepeatWrapping: oe }, Wu = { NearestFilter: le, NearestMipmapNearestFilter: ce, NearestMipmapLinearFilter: he, LinearFilter: ue, LinearMipmapNearestFilter: de, LinearMipmapLinearFilter: pe }; class ju extends cu { constructor(e) { super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, n, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const i = this, s = au.get(e); if (void 0 !== s) return i.manager.itemStart(e), setTimeout(function () { t && t(s), i.manager.itemEnd(e) }, 0), s; const a = {}; a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function (e) { return e.blob() }).then(function (e) { return createImageBitmap(e, Object.assign(i.options, { colorSpaceConversion: "none" })) }).then(function (n) { au.add(e, n), t && t(n), i.manager.itemEnd(e) }).catch(function (t) { r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) }), i.manager.itemStart(e) } } ju.prototype.isImageBitmapLoader = !0; class Xu { constructor() { this.type = "ShapePath", this.color = new $r, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new vu, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, n, r) { return this.currentPath.quadraticCurveTo(e, t, n, r), this } bezierCurveTo(e, t, n, r, i, s) { return this.currentPath.bezierCurveTo(e, t, n, r, i, s), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e, t) { function n(e) { const t = []; for (let n = 0, r = e.length; n < r; n++) { const r = e[n], i = new yu; i.curves = r.curves, t.push(i) } return t } function r(e, t) { const n = t.length; let r = !1; for (let i = n - 1, s = 0; s < n; i = s++) { let n = t[i], a = t[s], o = a.x - n.x, l = a.y - n.y; if (Math.abs(l) > Number.EPSILON) { if (l < 0 && (n = t[s], o = -o, a = t[i], l = -l), e.y < n.y || e.y > a.y) continue; if (e.y === n.y) { if (e.x === n.x) return !0 } else { const t = l * (e.x - n.x) - o * (e.y - n.y); if (0 === t) return !0; if (t < 0) continue; r = !r } } else { if (e.y !== n.y) continue; if (a.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= a.x) return !0 } } return r } const i = fh.isClockWise, s = this.subPaths; if (0 === s.length) return []; if (!0 === t) return n(s); let a, o, l; const c = []; if (1 === s.length) return o = s[0], (l = new yu).curves = o.curves, c.push(l), c; let h = !i(s[0].getPoints()); h = e ? !h : h; const u = [], d = []; let p, m, f = [], g = 0; d[g] = void 0, f[g] = []; for (let t = 0, n = s.length; t < n; t++)a = i(p = (o = s[t]).getPoints()), (a = e ? !a : a) ? (!h && d[g] && g++, d[g] = { s: new yu, p: p }, d[g].s.curves = o.curves, h && g++, f[g] = []) : f[g].push({ h: o, p: p[0] }); if (!d[0]) return n(s); if (d.length > 1) { let e = !1; const t = []; for (let e = 0, t = d.length; e < t; e++)u[e] = []; for (let n = 0, i = d.length; n < i; n++) { const i = f[n]; for (let s = 0; s < i.length; s++) { const a = i[s]; let o = !0; for (let i = 0; i < d.length; i++)r(a.p, d[i].p) && (n !== i && t.push({ froms: n, tos: i, hole: s }), o ? (o = !1, u[i].push(a)) : e = !0); o && u[n].push(a) } } t.length > 0 && (e || (f = u)) } for (let e = 0, t = d.length; e < t; e++) { l = d[e].s, c.push(l); for (let t = 0, n = (m = f[e]).length; t < n; t++)l.holes.push(m[t].h) } return c } } class qu { constructor(e) { this.type = "Font", this.data = e } generateShapes(e, t = 100) { const n = [], r = function (e, t, n) { const r = Array.from(e), i = t / n.resolution, s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, a = []; let o = 0, l = 0; for (let e = 0; e < r.length; e++) { const t = r[e]; if ("\n" === t) o = 0, l -= s; else { const e = Yu(t, i, o, l, n); o += e.offsetX, a.push(e.path) } } return a }(e, t, this.data); for (let e = 0, t = r.length; e < t; e++)Array.prototype.push.apply(n, r[e].toShapes()); return n } } function Yu(e, t, n, r, i) { const s = i.glyphs[e] || i.glyphs["?"]; if (!s) return void console.error('THREE.Font: character "' + e + '" does not exists in font family ' + i.familyName + "."); const a = new Xu; let o, l, c, h, u, d, p, m; if (s.o) { const e = s._cachedOutline || (s._cachedOutline = s.o.split(" ")); for (let i = 0, s = e.length; i < s;) { switch (e[i++]) { case "m": o = e[i++] * t + n, l = e[i++] * t + r, a.moveTo(o, l); break; case "l": o = e[i++] * t + n, l = e[i++] * t + r, a.lineTo(o, l); break; case "q": c = e[i++] * t + n, h = e[i++] * t + r, u = e[i++] * t + n, d = e[i++] * t + r, a.quadraticCurveTo(u, d, c, h); break; case "b": c = e[i++] * t + n, h = e[i++] * t + r, u = e[i++] * t + n, d = e[i++] * t + r, p = e[i++] * t + n, m = e[i++] * t + r, a.bezierCurveTo(u, d, p, m, c, h) } } } return { offsetX: s.ha * t, path: a } } qu.prototype.isFont = !0; let Zu; const Ju = { getContext: function () { return void 0 === Zu && (Zu = new (window.AudioContext || window.webkitAudioContext)), Zu }, setContext: function (e) { Zu = e } }; class Ku extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = new uu(this.manager); s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (n) { try { const s = n.slice(0); Ju.getContext().decodeAudioData(s, function (e) { t(e) }) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } } class Qu extends Uu { constructor(e, t, n = 1) { super(void 0, n); const r = (new $r).set(e), i = (new $r).set(t), s = new Pn(r.r, r.g, r.b), a = new Pn(i.r, i.g, i.b), o = Math.sqrt(Math.PI), l = o * Math.sqrt(.75); this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l) } } Qu.prototype.isHemisphereLightProbe = !0; class $u extends Uu { constructor(e, t = 1) { super(void 0, t); const n = (new $r).set(e); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } $u.prototype.isAmbientLightProbe = !0; const ed = new lr, td = new lr; class nd { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = rd(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = rd(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function rd() { return ("undefined" == typeof performance ? Date : performance).now() } const id = new Pn, sd = new Cn, ad = new Pn, od = new Pn; class ld extends Nr { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const cd = new Pn, hd = new Cn, ud = new Pn, dd = new Pn; class pd { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let n = 0; n < t.length; n++)e += t[n]; return e / t.length } } class md { constructor(e, t, n) { let r, i, s; switch (this.binding = e, this.valueSize = n, t) { case "quaternion": r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const n = this.buffer, r = this.valueSize, i = e * r + r; let s = this.cumulativeWeight; if (0 === s) { for (let e = 0; e !== r; ++e)n[i + e] = n[e]; s = t } else { const e = t / (s += t); this._mixBufferRegion(n, i, 0, e, r) } this.cumulativeWeight = s } accumulateAdditive(e) { const t = this.buffer, n = this.valueSize, r = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, n = this.buffer, r = e * t + t, i = this.cumulativeWeight, s = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) { const e = t * this._origIndex; this._mixBufferRegion(n, r, e, 1 - i, t) } s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t); for (let e = t, i = t + t; e !== i; ++e)if (n[e] !== n[e + t]) { a.setValue(n, r); break } } saveOriginalState() { const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex; e.getValue(t, r); for (let e = n, i = r; e !== i; ++e)t[e] = t[r + e % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let n = e; n < t; n++)this.buffer[n] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n] } _select(e, t, n, r, i) { if (r >= .5) for (let r = 0; r !== i; ++r)e[t + r] = e[n + r] } _slerp(e, t, n, r) { Cn.slerpFlat(e, t, e, t, e, n, r) } _slerpAdditive(e, t, n, r, i) { const s = this._workIndex * i; Cn.multiplyQuaternionsFlat(e, s, e, t, e, n), Cn.slerpFlat(e, t, e, t, e, s, r) } _lerp(e, t, n, r, i) { const s = 1 - r; for (let a = 0; a !== i; ++a) { const i = t + a; e[i] = e[i] * s + e[n + a] * r } } _lerpAdditive(e, t, n, r, i) { for (let s = 0; s !== i; ++s) { const i = t + s; e[i] = e[i] + e[n + s] * r } } } const fd = new RegExp("[\\[\\]\\.:\\/]", "g"), gd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", vd = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), yd = /(WCOD+)?/.source.replace("WCOD", gd), xd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), _d = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), bd = new RegExp("^" + vd + yd + xd + _d + "$"), wd = ["material", "materials", "bones"]; class Md { constructor(e, t, n) { this.path = t, this.parsedPath = n || Md.parseTrackName(t), this.node = Md.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, n) { return e && e.isAnimationObjectGroup ? new Md.Composite(e, t, n) : new Md(e, t, n) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(fd, "") } static parseTrackName(e) { const t = bd.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { const e = n.nodeName.substring(r + 1); -1 !== wd.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n } static findNode(e, t) { if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { const n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n } if (e.children) { const n = function (e) { for (let r = 0; r < e.length; r++) { const i = e[r]; if (i.name === t || i.uuid === t) return i; const s = n(i.children); if (s) return s } return null }, r = n(e.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)e[t++] = n[r] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, n = t.objectName, r = t.propertyName; let i = t.propertyIndex; if (e || (e = Md.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let r = t.objectIndex; switch (n) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === r) { r = t; break } break; default: if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[n] }if (void 0 !== r) { if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[r] } } const s = e[r]; if (void 0 === s) { const n = t.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e) } let a = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate); let o = this.BindingType.Direct; if (void 0 !== i) { if ("morphTargetInfluences" === r) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i]) } o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r; this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Md.Composite = class { constructor(e, t, n) { const r = n || Md.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } getValue(e, t) { this.bind(); const n = this._targetGroup.nCachedObjects_, r = this._bindings[n]; void 0 !== r && r.getValue(e, t) } setValue(e, t) { const n = this._bindings; for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)n[r].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind() } }, Md.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Md.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Md.prototype.GetterByBindingType = [Md.prototype._getValue_direct, Md.prototype._getValue_array, Md.prototype._getValue_arrayElement, Md.prototype._getValue_toArray], Md.prototype.SetterByBindingTypeAndVersioning = [[Md.prototype._setValue_direct, Md.prototype._setValue_direct_setNeedsUpdate, Md.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Md.prototype._setValue_array, Md.prototype._setValue_array_setNeedsUpdate, Md.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Md.prototype._setValue_arrayElement, Md.prototype._setValue_arrayElement_setNeedsUpdate, Md.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Md.prototype._setValue_fromArray, Md.prototype._setValue_fromArray_setNeedsUpdate, Md.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class Td { constructor() { this.uuid = ln(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let t = 0, n = arguments.length; t !== n; ++t)e[arguments[t].uuid] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, i = this._bindings, s = i.length; let a = void 0, o = e.length, l = this.nCachedObjects_; for (let c = 0, h = arguments.length; c !== h; ++c) { const h = arguments[c], u = h.uuid; let d = t[u]; if (void 0 === d) { d = o++, t[u] = d, e.push(h); for (let e = 0, t = s; e !== t; ++e)i[e].push(new Md(h, n[e], r[e])) } else if (d < l) { a = e[d]; const o = --l, c = e[o]; t[c.uuid] = d, e[d] = c, t[u] = o, e[o] = h; for (let e = 0, t = s; e !== t; ++e) { const t = i[e], s = t[o]; let a = t[d]; t[d] = s, void 0 === a && (a = new Md(h, n[e], r[e])), t[o] = a } } else e[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = l } remove() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let i = this.nCachedObjects_; for (let s = 0, a = arguments.length; s !== a; ++s) { const a = arguments[s], o = a.uuid, l = t[o]; if (void 0 !== l && l >= i) { const s = i++, c = e[s]; t[c.uuid] = l, e[l] = c, t[o] = s, e[s] = a; for (let e = 0, t = r; e !== t; ++e) { const t = n[e], r = t[s], i = t[l]; t[l] = r, t[s] = i } } } this.nCachedObjects_ = i } uncache() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let i = this.nCachedObjects_, s = e.length; for (let a = 0, o = arguments.length; a !== o; ++a) { const o = arguments[a].uuid, l = t[o]; if (void 0 !== l) if (delete t[o], l < i) { const a = --i, o = e[a], c = --s, h = e[c]; t[o.uuid] = l, e[l] = o, t[h.uuid] = a, e[a] = h, e.pop(); for (let e = 0, t = r; e !== t; ++e) { const t = n[e], r = t[a], i = t[c]; t[l] = r, t[a] = i, t.pop() } } else { const i = --s, a = e[i]; i > 0 && (t[a.uuid] = l), e[l] = a, e.pop(); for (let e = 0, t = r; e !== t; ++e) { const t = n[e]; t[l] = t[i], t.pop() } } } this.nCachedObjects_ = i } subscribe_(e, t) { const n = this._bindingsIndicesByPath; let r = n[e]; const i = this._bindings; if (void 0 !== r) return i[r]; const s = this._paths, a = this._parsedPaths, o = this._objects, l = o.length, c = this.nCachedObjects_, h = new Array(l); r = i.length, n[e] = r, s.push(e), a.push(t), i.push(h); for (let n = c, r = o.length; n !== r; ++n) { const r = o[n]; h[n] = new Md(r, e, t) } return h } unsubscribe_(e) { const t = this._bindingsIndicesByPath, n = t[e]; if (void 0 !== n) { const r = this._paths, i = this._parsedPaths, s = this._bindings, a = s.length - 1, o = s[a]; t[e[a]] = n, s[n] = o, s.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop() } } } Td.prototype.isAnimationObjectGroup = !0; class Ed { constructor(e, t, n = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r; const i = t.tracks, s = i.length, a = new Array(s), o = { endingStart: It, endingEnd: It }; for (let e = 0; e !== s; ++e) { const t = i[e].createInterpolant(null); a[e] = t, t.settings = o } this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = At, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { const n = this._clip.duration, r = e._clip.duration, i = r / n, s = n / r; e.warp(1, i, t), this.warp(s, 1, t) } return this } crossFadeTo(e, t, n) { return e.crossFadeFrom(this, t, n) } stopFading() { const e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, n) { const r = this._mixer, i = r.time, s = this.timeScale; let a = this._timeScaleInterpolant; null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a); const o = a.parameterPositions, l = a.sampleValues; return o[0] = i, o[1] = i + n, l[0] = e / s, l[1] = t / s, this } stopWarping() { const e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, n, r) { if (!this.enabled) return void this._updateWeight(e); const i = this._startTime; if (null !== i) { const r = (e - i) * n; if (r < 0 || 0 === n) return; this._startTime = null, t = n * r } t *= this._updateTimeScale(e); const s = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { const e = this._interpolants, t = this._propertyBindings; switch (this.blendMode) { case Ot: for (let n = 0, r = e.length; n !== r; ++n)e[n].evaluate(s), t[n].accumulateAdditive(a); break; case Ft: default: for (let n = 0, i = e.length; n !== i; ++n)e[n].evaluate(s), t[n].accumulate(r, a) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const n = this._weightInterpolant; if (null !== n) { const r = n.evaluate(e)[0]; t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const n = this._timeScaleInterpolant; if (null !== n) { t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, n = this.loop; let r = this.time + e, i = this._loopCount; const s = n === Rt; if (0 === e) return -1 === i ? r : s && 1 == (1 & i) ? t - r : r; if (n === St) { -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else { if (!(r < 0)) { this.time = r; break e } r = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= t || r < 0) { const n = Math.floor(r / t); r -= t * n, i += Math.abs(n); const a = this.repetitions - i; if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === a) { const t = e < 0; this._setEndings(t, !t, s) } else this._setEndings(!1, !1, s); this._loopCount = i, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = r; if (s && 1 == (1 & i)) return t - r } return r } _setEndings(e, t, n) { const r = this._interpolantSettings; n ? (r.endingStart = Nt, r.endingEnd = Nt) : (r.endingStart = e ? this.zeroSlopeAtStart ? Nt : It : Dt, r.endingEnd = t ? this.zeroSlopeAtEnd ? Nt : It : Dt) } _scheduleFading(e, t, n) { const r = this._mixer, i = r.time; let s = this._weightInterpolant; null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s); const a = s.parameterPositions, o = s.sampleValues; return a[0] = i, o[0] = t, a[1] = i + e, o[1] = n, this } } class Sd extends nn { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const n = e._localRoot || this._root, r = e._clip.tracks, i = r.length, s = e._propertyBindings, a = e._interpolants, o = n.uuid, l = this._bindingsByRootAndName; let c = l[o]; void 0 === c && (c = {}, l[o] = c); for (let e = 0; e !== i; ++e) { const i = r[e], l = i.name; let h = c[l]; if (void 0 !== h) s[e] = h; else { if (void 0 !== (h = s[e])) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l)); continue } const r = t && t._propertyBindings[e].binding.parsedPath; ++(h = new md(Md.create(n, l, r), i.ValueTypeName, i.getValueSize())).referenceCount, this._addInactiveBinding(h, o, l), s[e] = h } a[e].resultBuffer = h.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { const t = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n]; this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t) } const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return null !== t && t < this._nActiveActions } _addInactiveAction(e, t, n) { const r = this._actions, i = this._actionsByClip; let s = i[t]; if (void 0 === s) s = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, i[t] = s; else { const t = s.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = r.length, r.push(e), s.actionByRoot[n] = e } _removeInactiveAction(e) { const t = this._actions, n = t[t.length - 1], r = e._cacheIndex; n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null; const i = e._clip.uuid, s = this._actionsByClip, a = s[i], o = a.knownActions, l = o[o.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete s[i], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.referenceCount && this._removeInactiveBinding(n) } } _lendAction(e) { const t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _takeBackAction(e) { const t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _addInactiveBinding(e, t, n) { const r = this._bindingsByRootAndName, i = this._bindings; let s = r[t]; void 0 === s && (s = {}, r[t] = s), s[n] = e, e._cacheIndex = i.length, i.push(e) } _removeInactiveBinding(e) { const t = this._bindings, n = e.binding, r = n.rootNode.uuid, i = n.path, s = this._bindingsByRootAndName, a = s[r], o = t[t.length - 1], l = e._cacheIndex; o._cacheIndex = l, t[l] = o, t.pop(), delete a[i], 0 === Object.keys(a).length && delete s[r] } _lendBinding(e) { const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _takeBackBinding(e) { const t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let n = e[t]; return void 0 === n && ((n = new Yh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, i = t[r]; e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i } clipAction(e, t, n) { const r = t || this._root, i = r.uuid; let s = "string" == typeof e ? iu.findByName(r, e) : e; const a = null !== s ? s.uuid : e, o = this._actionsByClip[a]; let l = null; if (void 0 === n && (n = null !== s ? s.blendMode : Ft), void 0 !== o) { const e = o.actionByRoot[i]; if (void 0 !== e && e.blendMode === n) return e; l = o.knownActions[0], null === s && (s = l._clip) } if (null === s) return null; const c = new Ed(this, s, t, n); return this._bindAction(c, l), this._addInactiveAction(c, a, i), c } existingAction(e, t) { const n = t || this._root, r = n.uuid, i = "string" == typeof e ? iu.findByName(n, e) : e, s = i ? i.uuid : e, a = this._actionsByClip[s]; return void 0 !== a && a.actionByRoot[r] || null } stopAllAction() { const e = this._actions; for (let t = this._nActiveActions - 1; t >= 0; --t)e[t].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), s = this._accuIndex ^= 1; for (let a = 0; a !== n; ++a) { t[a]._update(r, e, i, s) } const a = this._bindings, o = this._nActiveBindings; for (let e = 0; e !== o; ++e)a[e].apply(s); return this } setTime(e) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, n = e.uuid, r = this._actionsByClip, i = r[n]; if (void 0 !== i) { const e = i.knownActions; for (let n = 0, r = e.length; n !== r; ++n) { const r = e[n]; this._deactivateAction(r); const i = r._cacheIndex, s = t[t.length - 1]; r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, t[i] = s, t.pop(), this._removeInactiveBindingsForAction(r) } delete r[n] } } uncacheRoot(e) { const t = e.uuid, n = this._actionsByClip; for (const e in n) { const r = n[e].actionByRoot[t]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } const r = this._bindingsByRootAndName[t]; if (void 0 !== r) for (const e in r) { const t = r[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { const n = this.existingAction(e, t); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } } Sd.prototype._controlInterpolantsResultBuffer = new Float32Array(1); class Ad { constructor(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e } clone() { return new Ad(void 0 === this.value.clone ? this.value : this.value.clone()) } } class Rd extends ol { constructor(e, t, n = 1) { super(e, t), this.meshPerAttribute = n } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } Rd.prototype.isInstancedInterleavedBuffer = !0; class Ld { constructor(e, t, n, r, i) { this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } Ld.prototype.isGLBufferAttribute = !0; function Cd(e, t) { return e.distance - t.distance } function Pd(e, t, n, r) { if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) { const r = e.children; for (let e = 0, i = r.length; e < i; e++)Pd(r[e], t, n, !0) } } class Id { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.phi = t, this.theta = n, this } set(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(cn(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } const Nd = new gn; class Dd { constructor(e = new gn(1 / 0, 1 / 0), t = new gn(-1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = Nd.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return Nd.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } Dd.prototype.isBox2 = !0; const Fd = new Pn, Od = new Pn; class Ud { constructor(e = new Pn, t = new Pn) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { Fd.subVectors(e, this.start), Od.subVectors(this.end, this.start); const n = Od.dot(Od); let r = Od.dot(Fd) / n; return t && (r = cn(r, 0, 1)), r } closestPointToPoint(e, t, n) { const r = this.closestPointToPointParameter(e, t); return this.delta(n).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return (new this.constructor).copy(this) } } class Bd extends Nr { constructor(e) { super(), this.material = e, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } } Bd.prototype.isImmediateRenderObject = !0; const Hd = new Pn; const zd = new Pn, Gd = new lr, kd = new lr; class Vd extends tc { constructor(e) { const t = function e(t) { const n = []; t && t.isBone && n.push(t); for (let r = 0; r < t.children.length; r++)n.push.apply(n, e(t.children[r])); return n }(e), n = new Ti, r = [], i = [], s = new $r(0, 0, 1), a = new $r(0, 1, 0); for (let e = 0; e < t.length; e++) { const n = t[e]; n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(a.r, a.g, a.b)) } n.setAttribute("position", new di(r, 3)), n.setAttribute("color", new di(i, 3)), super(n, new Xl({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, n = this.geometry, r = n.getAttribute("position"); kd.copy(this.root.matrixWorld).invert(); for (let e = 0, n = 0; e < t.length; e++) { const i = t[e]; i.parent && i.parent.isBone && (Gd.multiplyMatrices(kd, i.matrixWorld), zd.setFromMatrixPosition(Gd), r.setXYZ(n, zd.x, zd.y, zd.z), Gd.multiplyMatrices(kd, i.parent.matrixWorld), zd.setFromMatrixPosition(Gd), r.setXYZ(n + 1, zd.x, zd.y, zd.z), n += 2) } n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } } const Wd = new Pn, jd = new $r, Xd = new $r; class qd extends tc { constructor(e = 10, t = 10, n = 4473924, r = 8947848) { n = new $r(n), r = new $r(r); const i = t / 2, s = e / t, a = e / 2, o = [], l = []; for (let e = 0, c = 0, h = -a; e <= t; e++, h += s) { o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a); const t = e === i ? n : r; t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3 } const c = new Ti; c.setAttribute("position", new di(o, 3)), c.setAttribute("color", new di(l, 3)), super(c, new Xl({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } } const Yd = new Pn, Zd = new Pn, Jd = new Pn; const Kd = new Pn, Qd = new Ki; function $d(e, t, n, r, i, s, a) { Kd.set(i, s, a).unproject(r); const o = t[e]; if (void 0 !== o) { const e = n.getAttribute("position"); for (let t = 0, n = o.length; t < n; t++)e.setXYZ(o[t], Kd.x, Kd.y, Kd.z) } } const ep = new Dn; class tp extends tc { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), i = new Ti; i.setIndex(new ri(n, 1)), i.setAttribute("position", new ri(r, 3)), super(i, new Xl({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && ep.setFromObject(this.object), ep.isEmpty()) return; const t = ep.min, n = ep.max, r = this.geometry.attributes.position, i = r.array; i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e) { return tc.prototype.copy.call(this, e), this.object = e.object, this } } const np = new Pn; let rp, ip; class sp extends tc { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], n = new Ti; n.setAttribute("position", new di(t, 3)), n.setAttribute("color", new di([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new Xl({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper" } setColors(e, t, n) { const r = new $r, i = this.geometry.attributes.color.array; return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } const ap = new Float32Array(1), op = new Int32Array(ap.buffer); Tc.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Tc.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, vu.prototype.fromPoints = function (e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) }, qd.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, Vd.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, cu.prototype.extractUrlBase = function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Hu.extractUrlBase(e) }, cu.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Dd.prototype.center = function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Dd.prototype.empty = function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Dd.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Dd.prototype.size = function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) }, Dn.prototype.center = function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Dn.prototype.empty = function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Dn.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Dn.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Dn.prototype.size = function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) }, $n.prototype.empty = function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, hs.prototype.setFromMatrix = function (e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, Ud.prototype.center = function (e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, vn.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, vn.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, vn.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, vn.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, vn.prototype.applyToVector3Array = function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, vn.prototype.getInverse = function (e) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, lr.prototype.extractPosition = function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, lr.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, lr.prototype.getPosition = function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Pn).setFromMatrixColumn(this, 3) }, lr.prototype.setRotationFromQuaternion = function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, lr.prototype.multiplyToArray = function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, lr.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, lr.prototype.multiplyVector4 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, lr.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, lr.prototype.rotateAxis = function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, lr.prototype.crossVector = function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, lr.prototype.translate = function () { console.error("THREE.Matrix4: .translate() has been removed.") }, lr.prototype.rotateX = function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, lr.prototype.rotateY = function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, lr.prototype.rotateZ = function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, lr.prototype.rotateByAxis = function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, lr.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, lr.prototype.applyToVector3Array = function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, lr.prototype.makeFrustum = function (e, t, n, r, i, s) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, s) }, lr.prototype.getInverse = function (e) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, os.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, Cn.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Cn.prototype.inverse = function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, or.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, or.prototype.isIntersectionPlane = function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, or.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Wr.prototype.area = function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, Wr.prototype.barycoordFromPoint = function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, Wr.prototype.midpoint = function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, Wr.prototypenormal = function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, Wr.prototype.plane = function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) }, Wr.barycoordFromPoint = function (e, t, n, r, i) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Wr.getBarycoord(e, t, n, r, i) }, Wr.normal = function (e, t, n, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Wr.getNormal(e, t, n, r) }, yu.prototype.extractAllPoints = function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, yu.prototype.extrude = function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new yh(this, e) }, yu.prototype.makeGeometry = function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Eh(this, e) }, gn.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, gn.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, gn.prototype.lengthManhattan = function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Pn.prototype.setEulerFromRotationMatrix = function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, Pn.prototype.setEulerFromQuaternion = function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, Pn.prototype.getPositionFromMatrix = function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, Pn.prototype.getScaleFromMatrix = function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, Pn.prototype.getColumnFromMatrix = function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, Pn.prototype.applyProjection = function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, Pn.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, Pn.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, Pn.prototype.lengthManhattan = function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Sn.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, Sn.prototype.lengthManhattan = function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Nr.prototype.getChildByName = function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, Nr.prototype.renderDepth = function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, Nr.prototype.translate = function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, Nr.prototype.getWorldRotation = function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, Nr.prototype.applyMatrix = function (e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(Nr.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), ki.prototype.setDrawMode = function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(ki.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Dl.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Qi.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(xu.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(ri.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === en }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(en) } } }), ri.prototype.setDynamic = function (e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? en : $t), this }, ri.prototype.copyIndicesArray = function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, ri.prototype.setArray = function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, Ti.prototype.addIndex = function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, Ti.prototype.addAttribute = function (e, t) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new ri(arguments[1], arguments[2]))) }, Ti.prototype.addDrawCall = function (e, t, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, Ti.prototype.clearDrawCalls = function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, Ti.prototype.computeOffsets = function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, Ti.prototype.removeAttribute = function (e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, Ti.prototype.applyMatrix = function (e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(Ti.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), ol.prototype.setDynamic = function (e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? en : $t), this }, ol.prototype.setArray = function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, yh.prototype.getArrays = function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, yh.prototype.addShapeList = function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, yh.prototype.addShape = function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, al.prototype.dispose = function () { console.error("THREE.Scene: .dispose() has been removed.") }, Ad.prototype.onUpdate = function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(Xr.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new $r } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === d } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } }, vertexTangents: { get: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") }, set: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") } } }), Object.defineProperties(Ji.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), nl.prototype.clearTarget = function (e, t, n, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r) }, nl.prototype.animate = function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, nl.prototype.getCurrentRenderTarget = function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, nl.prototype.getMaxAnisotropy = function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, nl.prototype.getPrecision = function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, nl.prototype.resetGLState = function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, nl.prototype.supportsFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, nl.prototype.supportsHalfFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, nl.prototype.supportsStandardDerivatives = function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, nl.prototype.supportsCompressedTextureS3TC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, nl.prototype.supportsCompressedTexturePVRTC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, nl.prototype.supportsBlendMinMax = function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, nl.prototype.supportsVertexTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, nl.prototype.supportsInstancedArrays = function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, nl.prototype.enableScissorTest = function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, nl.prototype.initMaterial = function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, nl.prototype.addPrePlugin = function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, nl.prototype.addPostPlugin = function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, nl.prototype.updateShadowMap = function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, nl.prototype.setFaceCulling = function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, nl.prototype.allocTextureUnit = function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, nl.prototype.setTexture = function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, nl.prototype.setTexture2D = function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, nl.prototype.setTextureCube = function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, nl.prototype.getActiveMipMapLevel = function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(nl.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? zt : Ht } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(Xo.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(An.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), ld.prototype.load = function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const t = this; return (new Ku).load(e, function (e) { t.setBuffer(e) }), this }, pd.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, ts.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, ts.prototype.clear = function (e, t, n, r) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, r) }, xn.crossOrigin = void 0, xn.loadTexture = function (e, t, n, r) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const i = new fu; i.setCrossOrigin(this.crossOrigin); const s = i.load(e, n, void 0, r); return t && (s.mapping = t), s }, xn.loadTextureCube = function (e, t, n, r) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const i = new pu; i.setCrossOrigin(this.crossOrigin); const s = i.load(e, n, void 0, r); return t && (s.mapping = t), s }, xn.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, xn.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; const lp = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } }; "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "132" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "132"); const cp = new WeakMap; class hp extends Tc { constructor(e, t, n, r, i) { super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = i || this.knots.length - 1; for (let e = 0; e < n.length; ++e) { const t = n[e]; this.controlPoints[e] = new Sn(t.x, t.y, t.z, t.w) } } getPoint(e, t = new Pn) { const n = t, r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, r); return 1 !== i.w && i.divideScalar(i.w), n.set(i.x, i.y, i.z) } getTangent(e, t = new Pn) { const n = t, r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, r, 1); return n.copy(i[1]).normalize(), n } } let up, dp, pp; class mp { constructor(e, t) { this.textureLoader = e, this.manager = t } parse() { dp = this.parseConnections(); const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), r = this.parseDeformers(), i = (new fp).parse(r); return this.parseScene(r, i, n), pp } parseConnections() { const e = new Map; if ("Connections" in up) { up.Connections.connections.forEach(function (t) { const n = t[0], r = t[1], i = t[2]; e.has(n) || e.set(n, { parents: [], children: [] }); const s = { ID: r, relationship: i }; e.get(n).parents.push(s), e.has(r) || e.set(r, { parents: [], children: [] }); const a = { ID: n, relationship: i }; e.get(r).children.push(a) }) } return e } parseImages() { const e = {}, t = {}; if ("Video" in up.Objects) { const n = up.Objects.Video; for (const r in n) { const i = n[r]; if (e[parseInt(r)] = i.RelativeFilename || i.Filename, "Content" in i) { const e = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, s = "string" == typeof i.Content && "" !== i.Content; if (e || s) { const e = this.parseImage(n[r]); t[i.RelativeFilename || i.Filename] = e } } } } for (const n in e) { const r = e[n]; void 0 !== t[r] ? e[n] = t[r] : e[n] = e[n].split("\\").pop() } return e } parseImage(e) { const t = e.Content, n = e.RelativeFilename || e.Filename, r = n.slice(n.lastIndexOf(".") + 1).toLowerCase(); let i; switch (r) { case "bmp": i = "image/bmp"; break; case "jpg": case "jpeg": i = "image/jpeg"; break; case "png": i = "image/png"; break; case "tif": i = "image/tiff"; break; case "tga": null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga"; break; default: return void console.warn('FBXLoader: Image type "' + r + '" is not supported.') }if ("string" == typeof t) return "data:" + i + ";base64," + t; { const e = new Uint8Array(t); return window.URL.createObjectURL(new Blob([e], { type: i })) } } parseTextures(e) { const t = new Map; if ("Texture" in up.Objects) { const n = up.Objects.Texture; for (const r in n) { const i = this.parseTexture(n[r], e); t.set(parseInt(r), i) } } return t } parseTexture(e, t) { const n = this.loadTexture(e, t); n.ID = e.id, n.name = e.attrName; const r = e.WrapModeU, i = e.WrapModeV, s = void 0 !== r ? r.value : 0, a = void 0 !== i ? i.value : 0; if (n.wrapS = 0 === s ? se : ae, n.wrapT = 0 === a ? se : ae, "Scaling" in e) { const t = e.Scaling.value; n.repeat.x = t[0], n.repeat.y = t[1] } return n } loadTexture(e, t) { let n; const r = this.textureLoader.path, i = dp.get(e.id).children; let s; void 0 !== i && i.length > 0 && void 0 !== t[i[0].ID] && (0 !== (n = t[i[0].ID]).indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0)); const a = e.FileName.slice(-3).toLowerCase(); if ("tga" === a) { const t = this.manager.getHandler(".tga"); null === t ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), s = new bn) : (t.setPath(this.textureLoader.path), s = t.load(n)) } else "psd" === a ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), s = new bn) : s = this.textureLoader.load(n); return this.textureLoader.setPath(r), s } parseMaterials(e) { const t = new Map; if ("Material" in up.Objects) { const n = up.Objects.Material; for (const r in n) { const i = this.parseMaterial(n[r], e); null !== i && t.set(parseInt(r), i) } } return t } parseMaterial(e, t) { const n = e.id, r = e.attrName; let i = e.ShadingModel; if ("object" == typeof i && (i = i.value), !dp.has(n)) return null; const s = this.parseParameters(e, t, n); let a; switch (i.toLowerCase()) { case "phong": a = new Bh; break; case "lambert": a = new Gh; break; default: console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), a = new Bh }return a.setValues(s), a.name = r, a } parseParameters(e, t, n) { const r = {}; e.BumpFactor && (r.bumpScale = e.BumpFactor.value), e.Diffuse ? r.color = (new $r).fromArray(e.Diffuse.value) : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (r.color = (new $r).fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value), e.Emissive ? r.emissive = (new $r).fromArray(e.Emissive.value) : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (r.emissive = (new $r).fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (r.opacity = parseFloat(e.Opacity.value)), r.opacity < 1 && (r.transparent = !0), e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value), e.Shininess && (r.shininess = e.Shininess.value), e.Specular ? r.specular = (new $r).fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (r.specular = (new $r).fromArray(e.SpecularColor.value)); const i = this; return dp.get(n).children.forEach(function (e) { const n = e.relationship; switch (n) { case "Bump": r.bumpMap = i.getTexture(t, e.ID); break; case "Maya|TEX_ao_map": r.aoMap = i.getTexture(t, e.ID); break; case "DiffuseColor": case "Maya|TEX_color_map": r.map = i.getTexture(t, e.ID), void 0 !== r.map && (r.map.encoding = zt); break; case "DisplacementColor": r.displacementMap = i.getTexture(t, e.ID); break; case "EmissiveColor": r.emissiveMap = i.getTexture(t, e.ID), void 0 !== r.emissiveMap && (r.emissiveMap.encoding = zt); break; case "NormalMap": case "Maya|TEX_normal_map": r.normalMap = i.getTexture(t, e.ID); break; case "ReflectionColor": r.envMap = i.getTexture(t, e.ID), void 0 !== r.envMap && (r.envMap.mapping = te, r.envMap.encoding = zt); break; case "SpecularColor": r.specularMap = i.getTexture(t, e.ID), void 0 !== r.specularMap && (r.specularMap.encoding = zt); break; case "TransparentColor": case "TransparencyFactor": r.alphaMap = i.getTexture(t, e.ID), r.transparent = !0; break; case "AmbientColor": case "ShininessExponent": case "SpecularFactor": case "VectorDisplacementColor": default: console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n) } }), r } getTexture(e, t) { return "LayeredTexture" in up.Objects && t in up.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = dp.get(t).children[0].ID), e.get(t) } parseDeformers() { const e = {}, t = {}; if ("Deformer" in up.Objects) { const n = up.Objects.Deformer; for (const r in n) { const i = n[r], s = dp.get(parseInt(r)); if ("Skin" === i.attrType) { const t = this.parseSkeleton(s, n); t.ID = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t.geometryID = s.parents[0].ID, e[r] = t } else if ("BlendShape" === i.attrType) { const e = { id: r }; e.rawTargets = this.parseMorphTargets(s, n), e.id = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[r] = e } } } return { skeletons: e, morphTargets: t } } parseSkeleton(e, t) { const n = []; return e.children.forEach(function (e) { const r = t[e.ID]; if ("Cluster" !== r.attrType) return; const i = { ID: e.ID, indices: [], weights: [], transformLink: (new lr).fromArray(r.TransformLink.a) }; "Indexes" in r && (i.indices = r.Indexes.a, i.weights = r.Weights.a), n.push(i) }), { rawBones: n, bones: [] } } parseMorphTargets(e, t) { const n = []; for (let r = 0; r < e.children.length; r++) { const i = e.children[r], s = t[i.ID], a = { name: s.attrName, initialWeight: s.DeformPercent, id: s.id, fullWeights: s.FullWeights.a }; if ("BlendShapeChannel" !== s.attrType) return; a.geoID = dp.get(parseInt(i.ID)).children.filter(function (e) { return void 0 === e.relationship })[0].ID, n.push(a) } return n } parseScene(e, t, n) { pp = new Ko; const r = this.parseModels(e.skeletons, t, n), i = up.Objects.Model, s = this; r.forEach(function (e) { const t = i[e.ID]; s.setLookAtProperties(e, t), dp.get(e.ID).parents.forEach(function (t) { const n = r.get(t.ID); void 0 !== n && n.add(e) }), null === e.parent && pp.add(e) }), this.bindSkeleton(e.skeletons, t, r), this.createAmbientLight(), pp.traverse(function (e) { if (e.userData.transformData) { e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix, e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld); const t = Ap(e.userData.transformData); e.applyMatrix4(t), e.updateWorldMatrix() } }); const a = (new gp).parse(); 1 === pp.children.length && pp.children[0].isGroup && (pp.children[0].animations = a, pp = pp.children[0]), pp.animations = a } parseModels(e, t, n) { const r = new Map, i = up.Objects.Model; for (const s in i) { const a = parseInt(s), o = i[s], l = dp.get(a); let c = this.buildSkeleton(l, e, a, o.attrName); if (!c) { switch (o.attrType) { case "Camera": c = this.createCamera(l); break; case "Light": c = this.createLight(l); break; case "Mesh": c = this.createMesh(l, t, n); break; case "NurbsCurve": c = this.createCurve(l, t); break; case "LimbNode": case "Root": c = new Fl; break; case "Null": default: c = new Ko }c.name = o.attrName ? Md.sanitizeNodeName(o.attrName) : "", c.ID = a } this.getTransformData(c, o), r.set(a, c) } return r } buildSkeleton(e, t, n, r) { let i = null; return e.parents.forEach(function (e) { for (const s in t) { const a = t[s]; a.rawBones.forEach(function (t, s) { if (t.ID === e.ID) { const e = i; (i = new Fl).matrixWorld.copy(t.transformLink), i.name = r ? Md.sanitizeNodeName(r) : "", i.ID = n, a.bones[s] = i, null !== e && i.add(e) } }) } }), i } createCamera(e) { let t, n; if (e.children.forEach(function (e) { const t = up.Objects.NodeAttribute[e.ID]; void 0 !== t && (n = t) }), void 0 === n) t = new Nr; else { let e = 0; void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (e = 1); let r = 1; void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3); let i = 1e3; void 0 !== n.FarPlane && (i = n.FarPlane.value / 1e3); let s = window.innerWidth, a = window.innerHeight; void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (s = n.AspectWidth.value, a = n.AspectHeight.value); const o = s / a; let l = 45; void 0 !== n.FieldOfView && (l = n.FieldOfView.value); const c = n.FocalLength ? n.FocalLength.value : null; switch (e) { case 0: t = new Qi(l, o, r, i), null !== c && t.setFocalLength(c); break; case 1: t = new Ms(-s / 2, s / 2, a / 2, -a / 2, r, i); break; default: console.warn("THREE.FBXLoader: Unknown camera type " + e + "."), t = new Nr } } return t } createLight(e) { let t, n; if (e.children.forEach(function (e) { const t = up.Objects.NodeAttribute[e.ID]; void 0 !== t && (n = t) }), void 0 === n) t = new Nr; else { let e; e = void 0 === n.LightType ? 0 : n.LightType.value; let r = 16777215; void 0 !== n.Color && (r = (new $r).fromArray(n.Color.value)); let i = void 0 === n.Intensity ? 1 : n.Intensity.value / 100; void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (i = 0); let s = 0; void 0 !== n.FarAttenuationEnd && (s = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value); const a = 1; switch (e) { case 0: t = new Pu(r, i, s, a); break; case 1: t = new Nu(r, i); break; case 2: let o = Math.PI / 3; void 0 !== n.InnerAngle && (o = fn.degToRad(n.InnerAngle.value)); let l = 0; void 0 !== n.OuterAngle && (l = fn.degToRad(n.OuterAngle.value), l = Math.max(l, 1)), t = new Su(r, i, s, o, l, a); break; default: console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new Pu(r, i) }void 0 !== n.CastShadows && 1 === n.CastShadows.value && (t.castShadow = !0) } return t } createMesh(e, t, n) { let r, i = null, s = null; const a = []; return e.children.forEach(function (e) { t.has(e.ID) && (i = t.get(e.ID)), n.has(e.ID) && a.push(n.get(e.ID)) }), a.length > 1 ? s = a : a.length > 0 ? s = a[0] : (s = new Bh({ color: 13421772 }), a.push(s)), "color" in i.attributes && a.forEach(function (e) { e.vertexColors = !0 }), i.FBX_Deformer ? (r = new Dl(i, s)).normalizeSkinWeights() : r = new ki(i, s), r } createCurve(e, t) { const n = e.children.reduce(function (e, n) { return t.has(n.ID) && (e = t.get(n.ID)), e }, null), r = new Xl({ color: 3342591, linewidth: 1 }); return new Ql(n, r) } getTransformData(e, t) { const n = {}; "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), n.eulerOrder = "RotationOrder" in t ? Rp(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n } setLookAtProperties(e, t) { if ("LookAtProperty" in t) { dp.get(e.ID).children.forEach(function (t) { if ("LookAtProperty" === t.relationship) { const n = up.Objects.Model[t.ID]; if ("Lcl_Translation" in n) { const t = n.Lcl_Translation.value; void 0 !== e.target ? (e.target.position.fromArray(t), pp.add(e.target)) : e.lookAt((new Pn).fromArray(t)) } } }) } } bindSkeleton(e, t, n) { const r = this.parsePoseNodes(); for (const i in e) { const s = e[i]; dp.get(parseInt(s.ID)).parents.forEach(function (e) { if (t.has(e.ID)) { const t = e.ID; dp.get(t).parents.forEach(function (e) { if (n.has(e.ID)) { n.get(e.ID).bind(new Hl(s.bones), r[e.ID]) } }) } }) } } parsePoseNodes() { const e = {}; if ("Pose" in up.Objects) { const t = up.Objects.Pose; for (const n in t) if ("BindPose" === t[n].attrType) { const r = t[n].PoseNode; Array.isArray(r) ? r.forEach(function (t) { e[t.Node] = (new lr).fromArray(t.Matrix.a) }) : e[r.Node] = (new lr).fromArray(r.Matrix.a) } } return e } createAmbientLight() { if ("GlobalSettings" in up && "AmbientColor" in up.GlobalSettings) { const e = up.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], r = e[2]; if (0 !== t || 0 !== n || 0 !== r) { const e = new $r(t, n, r); pp.add(new Du(e, 1)) } } } } class fp { parse(e) { const t = new Map; if ("Geometry" in up.Objects) { const n = up.Objects.Geometry; for (const r in n) { const i = dp.get(parseInt(r)), s = this.parseGeometry(i, n[r], e); t.set(parseInt(r), s) } } return t } parseGeometry(e, t, n) { switch (t.attrType) { case "Mesh": return this.parseMeshGeometry(e, t, n); case "NurbsCurve": return this.parseNurbsGeometry(t) } } parseMeshGeometry(e, t, n) { const r = n.skeletons, i = [], s = e.parents.map(function (e) { return up.Objects.Model[e.ID] }); if (0 === s.length) return; const a = e.children.reduce(function (e, t) { return void 0 !== r[t.ID] && (e = r[t.ID]), e }, null); e.children.forEach(function (e) { void 0 !== n.morphTargets[e.ID] && i.push(n.morphTargets[e.ID]) }); const o = s[0], l = {}; "RotationOrder" in o && (l.eulerOrder = Rp(o.RotationOrder.value)), "InheritType" in o && (l.inheritType = parseInt(o.InheritType.value)), "GeometricTranslation" in o && (l.translation = o.GeometricTranslation.value), "GeometricRotation" in o && (l.rotation = o.GeometricRotation.value), "GeometricScaling" in o && (l.scale = o.GeometricScaling.value); const c = Ap(l); return this.genGeometry(t, a, i, c) } genGeometry(e, t, n, r) { const i = new Ti; e.attrName && (i.name = e.attrName); const s = this.parseGeoNode(e, t), a = this.genBuffers(s), o = new di(a.vertex, 3); if (o.applyMatrix4(r), i.setAttribute("position", o), a.colors.length > 0 && i.setAttribute("color", new di(a.colors, 3)), t && (i.setAttribute("skinIndex", new li(a.weightsIndices, 4)), i.setAttribute("skinWeight", new di(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) { const e = (new vn).getNormalMatrix(r), t = new di(a.normal, 3); t.applyNormalMatrix(e), i.setAttribute("normal", t) } if (a.uvs.forEach(function (e, t) { let n = "uv" + (t + 1).toString(); 0 === t && (n = "uv"), i.setAttribute(n, new di(a.uvs[t], 2)) }), s.material && "AllSame" !== s.material.mappingType) { let e = a.materialIndex[0], t = 0; if (a.materialIndex.forEach(function (n, r) { n !== e && (i.addGroup(t, r - t, e), e = n, t = r) }), i.groups.length > 0) { const t = i.groups[i.groups.length - 1], n = t.start + t.count; n !== a.materialIndex.length && i.addGroup(n, a.materialIndex.length - n, e) } 0 === i.groups.length && i.addGroup(0, a.materialIndex.length, a.materialIndex[0]) } return this.addMorphTargets(i, e, n, r), i } parseGeoNode(e, t) { const n = {}; if (n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], n.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) { n.uv = []; let t = 0; for (; e.LayerElementUV[t];)e.LayerElementUV[t].UV && n.uv.push(this.parseUVs(e.LayerElementUV[t])), t++ } return n.weightTable = {}, null !== t && (n.skeleton = t, t.rawBones.forEach(function (e, t) { e.indices.forEach(function (r, i) { void 0 === n.weightTable[r] && (n.weightTable[r] = []), n.weightTable[r].push({ id: t, weight: e.weights[i] }) }) })), n } genBuffers(e) { const t = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] }; let n = 0, r = 0, i = !1, s = [], a = [], o = [], l = [], c = [], h = []; const u = this; return e.vertexIndices.forEach(function (d, p) { let m, f = !1; d < 0 && (d ^= -1, f = !0); let g = [], v = []; if (s.push(3 * d, 3 * d + 1, 3 * d + 2), e.color) { const t = Tp(p, n, d, e.color); o.push(t[0], t[1], t[2]) } if (e.skeleton) { if (void 0 !== e.weightTable[d] && e.weightTable[d].forEach(function (e) { v.push(e.weight), g.push(e.id) }), v.length > 4) { i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0); const e = [0, 0, 0, 0], t = [0, 0, 0, 0]; v.forEach(function (n, r) { let i = n, s = g[r]; t.forEach(function (t, n, r) { if (i > t) { r[n] = i, i = t; const a = e[n]; e[n] = s, s = a } }) }), g = e, v = t } for (; v.length < 4;)v.push(0), g.push(0); for (let e = 0; e < 4; ++e)c.push(v[e]), h.push(g[e]) } if (e.normal) { const t = Tp(p, n, d, e.normal); a.push(t[0], t[1], t[2]) } e.material && "AllSame" !== e.material.mappingType && (m = Tp(p, n, d, e.material)[0]), e.uv && e.uv.forEach(function (e, t) { const r = Tp(p, n, d, e); void 0 === l[t] && (l[t] = []), l[t].push(r[0]), l[t].push(r[1]) }), r++, f && (u.genFace(t, e, s, m, a, o, l, c, h, r), n++, r = 0, s = [], a = [], o = [], l = [], c = [], h = []) }), t } genFace(e, t, n, r, i, s, a, o, l, c) { for (let h = 2; h < c; h++)e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[3 * (h - 1)]]), e.vertex.push(t.vertexPositions[n[3 * (h - 1) + 1]]), e.vertex.push(t.vertexPositions[n[3 * (h - 1) + 2]]), e.vertex.push(t.vertexPositions[n[3 * h]]), e.vertex.push(t.vertexPositions[n[3 * h + 1]]), e.vertex.push(t.vertexPositions[n[3 * h + 2]]), t.skeleton && (e.vertexWeights.push(o[0]), e.vertexWeights.push(o[1]), e.vertexWeights.push(o[2]), e.vertexWeights.push(o[3]), e.vertexWeights.push(o[4 * (h - 1)]), e.vertexWeights.push(o[4 * (h - 1) + 1]), e.vertexWeights.push(o[4 * (h - 1) + 2]), e.vertexWeights.push(o[4 * (h - 1) + 3]), e.vertexWeights.push(o[4 * h]), e.vertexWeights.push(o[4 * h + 1]), e.vertexWeights.push(o[4 * h + 2]), e.vertexWeights.push(o[4 * h + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[4 * (h - 1)]), e.weightsIndices.push(l[4 * (h - 1) + 1]), e.weightsIndices.push(l[4 * (h - 1) + 2]), e.weightsIndices.push(l[4 * (h - 1) + 3]), e.weightsIndices.push(l[4 * h]), e.weightsIndices.push(l[4 * h + 1]), e.weightsIndices.push(l[4 * h + 2]), e.weightsIndices.push(l[4 * h + 3])), t.color && (e.colors.push(s[0]), e.colors.push(s[1]), e.colors.push(s[2]), e.colors.push(s[3 * (h - 1)]), e.colors.push(s[3 * (h - 1) + 1]), e.colors.push(s[3 * (h - 1) + 2]), e.colors.push(s[3 * h]), e.colors.push(s[3 * h + 1]), e.colors.push(s[3 * h + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(r), e.materialIndex.push(r), e.materialIndex.push(r)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[3 * (h - 1)]), e.normal.push(i[3 * (h - 1) + 1]), e.normal.push(i[3 * (h - 1) + 2]), e.normal.push(i[3 * h]), e.normal.push(i[3 * h + 1]), e.normal.push(i[3 * h + 2])), t.uv && t.uv.forEach(function (t, n) { void 0 === e.uvs[n] && (e.uvs[n] = []), e.uvs[n].push(a[n][0]), e.uvs[n].push(a[n][1]), e.uvs[n].push(a[n][2 * (h - 1)]), e.uvs[n].push(a[n][2 * (h - 1) + 1]), e.uvs[n].push(a[n][2 * h]), e.uvs[n].push(a[n][2 * h + 1]) }) } addMorphTargets(e, t, n, r) { if (0 === n.length) return; e.morphTargetsRelative = !0, e.morphAttributes.position = []; const i = this; n.forEach(function (n) { n.rawTargets.forEach(function (n) { const s = up.Objects.Geometry[n.geoID]; void 0 !== s && i.genMorphGeometry(e, t, s, r, n.name) }) }) } genMorphGeometry(e, t, n, r, i) { const s = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], a = void 0 !== n.Vertices ? n.Vertices.a : [], o = void 0 !== n.Indexes ? n.Indexes.a : [], l = 3 * e.attributes.position.count, c = new Float32Array(l); for (let e = 0; e < o.length; e++) { const t = 3 * o[e]; c[t] = a[3 * e], c[t + 1] = a[3 * e + 1], c[t + 2] = a[3 * e + 2] } const h = { vertexIndices: s, vertexPositions: c }, u = this.genBuffers(h), d = new di(u.vertex, 3); d.name = i || n.attrName, d.applyMatrix4(r), e.morphAttributes.position.push(d) } parseNormals(e) { const t = e.MappingInformationType, n = e.ReferenceInformationType, r = e.Normals.a; let i = []; return "IndexToDirect" === n && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), { dataSize: 3, buffer: r, indices: i, mappingType: t, referenceType: n } } parseUVs(e) { const t = e.MappingInformationType, n = e.ReferenceInformationType, r = e.UV.a; let i = []; return "IndexToDirect" === n && (i = e.UVIndex.a), { dataSize: 2, buffer: r, indices: i, mappingType: t, referenceType: n } } parseVertexColors(e) { const t = e.MappingInformationType, n = e.ReferenceInformationType, r = e.Colors.a; let i = []; return "IndexToDirect" === n && (i = e.ColorIndex.a), { dataSize: 4, buffer: r, indices: i, mappingType: t, referenceType: n } } parseMaterialIndices(e) { const t = e.MappingInformationType, n = e.ReferenceInformationType; if ("NoMappingInformation" === t) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: n }; const r = e.Materials.a, i = []; for (let e = 0; e < r.length; ++e)i.push(e); return { dataSize: 1, buffer: r, indices: i, mappingType: t, referenceType: n } } parseNurbsGeometry(e) { if (void 0 === hp) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new Ti; const t = parseInt(e.Order); if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Ti; const n = t - 1, r = e.KnotVector.a, i = [], s = e.Points.a; for (let e = 0, t = s.length; e < t; e += 4)i.push((new Sn).fromArray(s, e)); let a, o; if ("Closed" === e.Form) i.push(i[0]); else if ("Periodic" === e.Form) { a = n, o = r.length - 1 - a; for (let e = 0; e < n; ++e)i.push(i[e]) } const l = new hp(n, r, i, a, o).getPoints(12 * i.length); return (new Ti).setFromPoints(l) } } class gp { parse() { const e = [], t = this.parseClips(); if (void 0 !== t) for (const n in t) { const r = t[n], i = this.addClip(r); e.push(i) } return e } parseClips() { if (void 0 === up.Objects.AnimationCurve) return; const e = this.parseAnimationCurveNodes(); this.parseAnimationCurves(e); const t = this.parseAnimationLayers(e); return this.parseAnimStacks(t) } parseAnimationCurveNodes() { const e = up.Objects.AnimationCurveNode, t = new Map; for (const n in e) { const r = e[n]; if (null !== r.attrName.match(/S|R|T|DeformPercent/)) { const e = { id: r.id, attr: r.attrName, curves: {} }; t.set(e.id, e) } } return t } parseAnimationCurves(e) { const t = up.Objects.AnimationCurve; for (const n in t) { const r = { id: t[n].id, times: t[n].KeyTime.a.map(wp), values: t[n].KeyValueFloat.a }, i = dp.get(r.id); if (void 0 !== i) { const t = i.parents[0].ID, n = i.parents[0].relationship; n.match(/X/) ? e.get(t).curves.x = r : n.match(/Y/) ? e.get(t).curves.y = r : n.match(/Z/) ? e.get(t).curves.z = r : n.match(/d|DeformPercent/) && e.has(t) && (e.get(t).curves.morph = r) } } } parseAnimationLayers(e) { const t = up.Objects.AnimationLayer, n = new Map; for (const r in t) { const t = [], i = dp.get(parseInt(r)); if (void 0 !== i) { i.children.forEach(function (n, r) { if (e.has(n.ID)) { const i = e.get(n.ID); if (void 0 !== i.curves.x || void 0 !== i.curves.y || void 0 !== i.curves.z) { if (void 0 === t[r]) { const e = dp.get(n.ID).parents.filter(function (e) { return void 0 !== e.relationship })[0].ID; if (void 0 !== e) { const i = up.Objects.Model[e.toString()]; if (void 0 === i) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n); const s = { modelName: i.attrName ? Md.sanitizeNodeName(i.attrName) : "", ID: i.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] }; pp.traverse(function (e) { e.ID === i.id && (s.transform = e.matrix, e.userData.transformData && (s.eulerOrder = e.userData.transformData.eulerOrder)) }), s.transform || (s.transform = new lr), "PreRotation" in i && (s.preRotation = i.PreRotation.value), "PostRotation" in i && (s.postRotation = i.PostRotation.value), t[r] = s } } t[r] && (t[r][i.attr] = i) } else if (void 0 !== i.curves.morph) { if (void 0 === t[r]) { const e = dp.get(n.ID).parents.filter(function (e) { return void 0 !== e.relationship })[0].ID, i = dp.get(e).parents[0].ID, s = dp.get(i).parents[0].ID, a = dp.get(s).parents[0].ID, o = up.Objects.Model[a], l = { modelName: o.attrName ? Md.sanitizeNodeName(o.attrName) : "", morphName: up.Objects.Deformer[e].attrName }; t[r] = l } t[r][i.attr] = i } } }), n.set(parseInt(r), t) } } return n } parseAnimStacks(e) { const t = up.Objects.AnimationStack, n = {}; for (const r in t) { const i = dp.get(parseInt(r)).children; i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."); const s = e.get(i[0].ID); n[r] = { name: t[r].attrName, layer: s } } return n } addClip(e) { let t = []; const n = this; return e.layer.forEach(function (e) { t = t.concat(n.generateTracks(e)) }), new iu(e.name, -1, t) } generateTracks(e) { const t = []; let n = new Pn, r = new Cn, i = new Pn; if (e.transform && e.transform.decompose(n, r, i), n = n.toArray(), r = (new yr).setFromQuaternion(r, e.eulerOrder).toArray(), i = i.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) { const r = this.generateVectorTrack(e.modelName, e.T.curves, n, "position"); void 0 !== r && t.push(r) } if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) { const n = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder); void 0 !== n && t.push(n) } if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) { const n = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale"); void 0 !== n && t.push(n) } if (void 0 !== e.DeformPercent) { const n = this.generateMorphTrack(e); void 0 !== n && t.push(n) } return t } generateVectorTrack(e, t, n, r) { const i = this.getTimesForAllAxes(t), s = this.getKeyframeTrackValues(i, t, n); return new ru(e + "." + r, i, s) } generateRotationTrack(e, t, n, r, i, s) { void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(fn.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(fn.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(fn.degToRad)); const a = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(a, t, n); void 0 !== r && ((r = r.map(fn.degToRad)).push(s), r = (new yr).fromArray(r), r = (new Cn).setFromEuler(r)), void 0 !== i && ((i = i.map(fn.degToRad)).push(s), i = (new yr).fromArray(i), i = (new Cn).setFromEuler(i).invert()); const l = new Cn, c = new yr, h = []; for (let e = 0; e < o.length; e += 3)c.set(o[e], o[e + 1], o[e + 2], s), l.setFromEuler(c), void 0 !== r && l.premultiply(r), void 0 !== i && l.multiply(i), l.toArray(h, e / 3 * 4); return new tu(e + ".quaternion", a, h) } generateMorphTrack(e) { const t = e.DeformPercent.curves.morph, n = t.values.map(function (e) { return e / 100 }), r = pp.getObjectByName(e.modelName).morphTargetDictionary[e.morphName]; return new $h(e.modelName + ".morphTargetInfluences[" + r + "]", t.times, n) } getTimesForAllAxes(e) { let t = []; if (void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), (t = t.sort(function (e, t) { return e - t })).length > 1) { let e = 1, n = t[0]; for (let r = 1; r < t.length; r++) { const i = t[r]; i !== n && (t[e] = i, n = i, e++) } t = t.slice(0, e) } return t } getKeyframeTrackValues(e, t, n) { const r = n, i = []; let s = -1, a = -1, o = -1; return e.forEach(function (e) { if (t.x && (s = t.x.times.indexOf(e)), t.y && (a = t.y.times.indexOf(e)), t.z && (o = t.z.times.indexOf(e)), -1 !== s) { const e = t.x.values[s]; i.push(e), r[0] = e } else i.push(r[0]); if (-1 !== a) { const e = t.y.values[a]; i.push(e), r[1] = e } else i.push(r[1]); if (-1 !== o) { const e = t.z.values[o]; i.push(e), r[2] = e } else i.push(r[2]) }), i } interpolateRotations(e) { for (let t = 1; t < e.values.length; t++) { const n = e.values[t - 1], r = e.values[t] - n, i = Math.abs(r); if (i >= 180) { const s = i / 180, a = r / s; let o = n + a; const l = e.times[t - 1], c = (e.times[t] - l) / s; let h = l + c; const u = [], d = []; for (; h < e.times[t];)u.push(h), h += c, d.push(o), o += a; e.times = Pp(e.times, t, u), e.values = Pp(e.values, t, d) } } } } class vp { getPrevNode() { return this.nodeStack[this.currentIndent - 2] } getCurrentNode() { return this.nodeStack[this.currentIndent - 1] } getCurrentProp() { return this.currentProp } pushStack(e) { this.nodeStack.push(e), this.currentIndent += 1 } popStack() { this.nodeStack.pop(), this.currentIndent -= 1 } setCurrentProp(e, t) { this.currentProp = e, this.currentPropName = t } parse(e) { this.currentIndent = 0, this.allNodes = new _p, this.nodeStack = [], this.currentProp = [], this.currentPropName = ""; const t = this, n = e.split(/[\r\n]+/); return n.forEach(function (e, r) { const i = e.match(/^[\s\t]*;/), s = e.match(/^[\s\t]*$/); if (i || s) return; const a = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), o = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l = e.match("^\\t{" + (t.currentIndent - 1) + "}}"); a ? t.parseNodeBegin(e, a) : o ? t.parseNodeProperty(e, o, n[++r]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e) }), this.allNodes } parseNodeBegin(e, t) { const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), r = t[2].split(",").map(function (e) { return e.trim().replace(/^"/, "").replace(/"$/, "") }), i = { name: n }, s = this.parseNodeAttr(r), a = this.getCurrentNode(); 0 === this.currentIndent ? this.allNodes.add(n, i) : n in a ? ("PoseNode" === n ? a.PoseNode.push(i) : void 0 !== a[n].id && (a[n] = {}, a[n][a[n].id] = a[n]), "" !== s.id && (a[n][s.id] = i)) : "number" == typeof s.id ? (a[n] = {}, a[n][s.id] = i) : "Properties70" !== n && (a[n] = "PoseNode" === n ? [i] : i), "number" == typeof s.id && (i.id = s.id), "" !== s.name && (i.attrName = s.name), "" !== s.type && (i.attrType = s.type), this.pushStack(i) } parseNodeAttr(e) { let t = e[0]; "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0])); let n = "", r = ""; return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), r = e[2]), { id: t, name: n, type: r } } parseNodeProperty(e, t, n) { let r = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim(); "Content" === r && "," === i && (i = n.replace(/"/g, "").replace(/,$/, "").trim()); const s = this.getCurrentNode(); if ("Properties70" !== s.name) { if ("C" === r) { const e = i.split(",").slice(1), t = parseInt(e[0]), n = parseInt(e[1]); let a = i.split(",").slice(3); r = "connections", function (e, t) { for (let n = 0, r = e.length, i = t.length; n < i; n++, r++)e[r] = t[n] }(i = [t, n], a = a.map(function (e) { return e.trim().replace(/^"/, "") })), void 0 === s[r] && (s[r] = []) } "Node" === r && (s.id = i), r in s && Array.isArray(s[r]) ? s[r].push(i) : "a" !== r ? s[r] = i : s.a = i, this.setCurrentProp(s, r), "a" === r && "," !== i.slice(-1) && (s.a = Lp(i)) } else this.parseNodeSpecialProperty(e, r, i) } parseNodePropertyContinued(e) { const t = this.getCurrentNode(); t.a += e, "," !== e.slice(-1) && (t.a = Lp(t.a)) } parseNodeSpecialProperty(e, t, n) { const r = n.split('",').map(function (e) { return e.trim().replace(/^\"/, "").replace(/\s/, "_") }), i = r[0], s = r[1], a = r[2], o = r[3]; let l = r[4]; switch (s) { case "int": case "enum": case "bool": case "ULongLong": case "double": case "Number": case "FieldOfView": l = parseFloat(l); break; case "Color": case "ColorRGB": case "Vector3D": case "Lcl_Translation": case "Lcl_Rotation": case "Lcl_Scaling": l = Lp(l) }this.getPrevNode()[i] = { type: s, type2: a, flag: o, value: l }, this.setCurrentProp(this.getPrevNode(), i) } } class yp { parse(e) { const t = new xp(e); t.skip(23); const n = t.getUint32(); if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n); const r = new _p; for (; !this.endOfContent(t);) { const e = this.parseNode(t, n); null !== e && r.add(e.name, e) } return r } endOfContent(e) { return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size() } parseNode(e, t) { const n = {}, r = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32(); t >= 7500 ? e.getUint64() : e.getUint32(); const s = e.getUint8(), a = e.getString(s); if (0 === r) return null; const o = []; for (let t = 0; t < i; t++)o.push(this.parseProperty(e)); const l = o.length > 0 ? o[0] : "", c = o.length > 1 ? o[1] : "", h = o.length > 2 ? o[2] : ""; for (n.singleProperty = 1 === i && e.getOffset() === r; r > e.getOffset();) { const r = this.parseNode(e, t); null !== r && this.parseSubNode(a, n, r) } return n.propertyList = o, "number" == typeof l && (n.id = l), "" !== c && (n.attrName = c), "" !== h && (n.attrType = h), "" !== a && (n.name = a), n } parseSubNode(e, t, n) { if (!0 === n.singleProperty) { const e = n.propertyList[0]; Array.isArray(e) ? (t[n.name] = n, n.a = e) : t[n.name] = e } else if ("Connections" === e && "C" === n.name) { const e = []; n.propertyList.forEach(function (t, n) { 0 !== n && e.push(t) }), void 0 === t.connections && (t.connections = []), t.connections.push(e) } else if ("Properties70" === n.name) { Object.keys(n).forEach(function (e) { t[e] = n[e] }) } else if ("Properties70" === e && "P" === n.name) { let e = n.propertyList[0], r = n.propertyList[1]; const i = n.propertyList[2], s = n.propertyList[3]; let a; 0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")), 0 === r.indexOf("Lcl ") && (r = r.replace("Lcl ", "Lcl_")), a = "Color" === r || "ColorRGB" === r || "Vector" === r || "Vector3D" === r || 0 === r.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], t[e] = { type: r, type2: i, flag: s, value: a } } else void 0 === t[n.name] ? "number" == typeof n.id ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : "PoseNode" === n.name ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n) } parseProperty(e) { const t = e.getString(1); let n; switch (t) { case "C": return e.getBoolean(); case "D": return e.getFloat64(); case "F": return e.getFloat32(); case "I": return e.getInt32(); case "L": return e.getInt64(); case "R": return n = e.getUint32(), e.getArrayBuffer(n); case "S": return n = e.getUint32(), e.getString(n); case "Y": return e.getInt16(); case "b": case "c": case "d": case "f": case "i": case "l": const r = e.getUint32(), i = e.getUint32(), s = e.getUint32(); if (0 === i) switch (t) { case "b": case "c": return e.getBooleanArray(r); case "d": return e.getFloat64Array(r); case "f": return e.getFloat32Array(r); case "i": return e.getInt32Array(r); case "l": return e.getInt64Array(r) }"undefined" == typeof fflate && console.error("THREE.FBXLoader: External library fflate.min.js required."); const a = fflate.unzlibSync(new Uint8Array(e.getArrayBuffer(s))), o = new xp(a.buffer); switch (t) { case "b": case "c": return o.getBooleanArray(r); case "d": return o.getFloat64Array(r); case "f": return o.getFloat32Array(r); case "i": return o.getInt32Array(r); case "l": return o.getInt64Array(r) }default: throw new Error("THREE.FBXLoader: Unknown property type " + t) } } } class xp { constructor(e, t) { this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t } getOffset() { return this.offset } size() { return this.dv.buffer.byteLength } skip(e) { this.offset += e } getBoolean() { return 1 == (1 & this.getUint8()) } getBooleanArray(e) { const t = []; for (let n = 0; n < e; n++)t.push(this.getBoolean()); return t } getUint8() { const e = this.dv.getUint8(this.offset); return this.offset += 1, e } getInt16() { const e = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, e } getInt32() { const e = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, e } getInt32Array(e) { const t = []; for (let n = 0; n < e; n++)t.push(this.getInt32()); return t } getUint32() { const e = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, e } getInt64() { let e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, 4294967295 === (e = 4294967295 & ~e) && (t = t + 1 & 4294967295), -(4294967296 * t + (e = e + 1 & 4294967295))) : 4294967296 * t + e } getInt64Array(e) { const t = []; for (let n = 0; n < e; n++)t.push(this.getInt64()); return t } getUint64() { let e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e } getFloat32() { const e = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, e } getFloat32Array(e) { const t = []; for (let n = 0; n < e; n++)t.push(this.getFloat32()); return t } getFloat64() { const e = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, e } getFloat64Array(e) { const t = []; for (let n = 0; n < e; n++)t.push(this.getFloat64()); return t } getArrayBuffer(e) { const t = this.dv.buffer.slice(this.offset, this.offset + e); return this.offset += e, t } getString(e) { let t = []; for (let n = 0; n < e; n++)t[n] = this.getUint8(); const n = t.indexOf(0); return n >= 0 && (t = t.slice(0, n)), Hu.decodeText(new Uint8Array(t)) } } class _p { add(e, t) { this[e] = t } } function bp(e) { const t = e.match(/FBXVersion: (\d+)/); if (t) { return parseInt(t[1]) } throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.") } function wp(e) { return e / 46186158e3 } const Mp = []; function Tp(e, t, n, r) { let i; switch (r.mappingType) { case "ByPolygonVertex": i = e; break; case "ByPolygon": i = t; break; case "ByVertice": i = n; break; case "AllSame": i = r.indices[0]; break; default: console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType) }"IndexToDirect" === r.referenceType && (i = r.indices[i]); const s = i * r.dataSize, a = s + r.dataSize; return function (e, t, n, r) { for (let i = n, s = 0; i < r; i++, s++)e[s] = t[i]; return e }(Mp, r.buffer, s, a) } const Ep = new yr, Sp = new Pn; function Ap(e) { const t = new lr, n = new lr, r = new lr, i = new lr, s = new lr, a = new lr, o = new lr, l = new lr, c = new lr, h = new lr, u = new lr, d = new lr, p = e.inheritType ? e.inheritType : 0; if (e.translation && t.setPosition(Sp.fromArray(e.translation)), e.preRotation) { const t = e.preRotation.map(fn.degToRad); t.push(e.eulerOrder), n.makeRotationFromEuler(Ep.fromArray(t)) } if (e.rotation) { const t = e.rotation.map(fn.degToRad); t.push(e.eulerOrder), r.makeRotationFromEuler(Ep.fromArray(t)) } if (e.postRotation) { const t = e.postRotation.map(fn.degToRad); t.push(e.eulerOrder), i.makeRotationFromEuler(Ep.fromArray(t)), i.invert() } e.scale && s.scale(Sp.fromArray(e.scale)), e.scalingOffset && o.setPosition(Sp.fromArray(e.scalingOffset)), e.scalingPivot && a.setPosition(Sp.fromArray(e.scalingPivot)), e.rotationOffset && l.setPosition(Sp.fromArray(e.rotationOffset)), e.rotationPivot && c.setPosition(Sp.fromArray(e.rotationPivot)), e.parentMatrixWorld && (u.copy(e.parentMatrix), h.copy(e.parentMatrixWorld)); const m = n.clone().multiply(r).multiply(i), f = new lr; f.extractRotation(h); const g = new lr; g.copyPosition(h); const v = g.clone().invert().multiply(h), y = f.clone().invert().multiply(v), x = s, _ = new lr; if (0 === p) _.copy(f).multiply(m).multiply(y).multiply(x); else if (1 === p) _.copy(f).multiply(y).multiply(m).multiply(x); else { const e = (new lr).scale((new Pn).setFromMatrixScale(u)).clone().invert(), t = y.clone().multiply(e); _.copy(f).multiply(m).multiply(t).multiply(x) } const b = c.clone().invert(), w = a.clone().invert(); let M = t.clone().multiply(l).multiply(c).multiply(n).multiply(r).multiply(i).multiply(b).multiply(o).multiply(a).multiply(s).multiply(w); const T = (new lr).copyPosition(M), E = h.clone().multiply(T); return d.copyPosition(E), (M = d.clone().multiply(_)).premultiply(h.invert()), M } function Rp(e) { const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"]; return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e] } function Lp(e) { return e.split(",").map(function (e) { return parseFloat(e) }) } function Cp(e, t, n) { return void 0 === t && (t = 0), void 0 === n && (n = e.byteLength), Hu.decodeText(new Uint8Array(e, t, n)) } function Pp(e, t, n) { return e.slice(0, t).concat(n).concat(e.slice(t)) } function Ip() { let e = {}; return { get: function (t) { return e[t] }, add: function (t, n) { e[t] = n }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } const Np = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class Dp { constructor(e) { this.parser = e, this.name = Np.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let n = 0, r = t.length; n < r; n++) { const r = t[n]; r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, n = "light:" + e; let r = t.cache.get(n); if (r) return r; const i = t.json, s = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e]; let a; const o = new $r(16777215); void 0 !== s.color && o.fromArray(s.color); const l = void 0 !== s.range ? s.range : 0; switch (s.type) { case "directional": (a = new Nu(o)).target.position.set(0, 0, -1), a.add(a.target); break; case "point": (a = new Pu(o)).distance = l; break; case "spot": (a = new Su(o)).distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type) }return a.position.set(0, 0, 0), a.decay = 2, void 0 !== s.intensity && (a.intensity = s.intensity), a.name = t.createUniqueName(s.name || "light_" + e), r = Promise.resolve(a), t.cache.add(n, r), r } createNodeAttachment(e) { const t = this, n = this.parser, r = n.json.nodes[e], i = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === i ? null : this._loadLight(i).then(function (e) { return n._getNodeRef(t.cache, i, e) }) } } class Fp { constructor() { this.name = Np.KHR_MATERIALS_UNLIT } getMaterialType() { return ei } extendParams(e, t, n) { const r = []; e.color = new $r(1, 1, 1), e.opacity = 1; const i = t.pbrMetallicRoughness; if (i) { if (Array.isArray(i.baseColorFactor)) { const t = i.baseColorFactor; e.color.fromArray(t), e.opacity = t[3] } void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture)) } return Promise.all(r) } } class Op { constructor(e) { this.parser = e, this.name = Np.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Uh : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], s = r.extensions[this.name]; if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) { const e = s.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new gn(e, e) } return Promise.all(i) } } class Up { constructor(e) { this.parser = e, this.name = Np.KHR_MATERIALS_SHEEN } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Uh : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = []; t.sheenColor = new $r(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const s = r.extensions[this.name]; return void 0 !== s.sheenColorFactor && t.sheenColor.fromArray(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture)), void 0 !== s.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(i) } } class Bp { constructor(e) { this.parser = e, this.name = Np.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Uh : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], s = r.extensions[this.name]; return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(i) } } class Hp { constructor(e) { this.parser = e, this.name = Np.KHR_MATERIALS_VOLUME } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Uh : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], s = r.extensions[this.name]; t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 0; const a = s.attenuationColor || [1, 1, 1]; return t.attenuationColor = new $r(a[0], a[1], a[2]), Promise.all(i) } } class zp { constructor(e) { this.parser = e, this.name = Np.KHR_MATERIALS_IOR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Uh : null } extendMaterialParams(e, t) { const n = this.parser.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = n.extensions[this.name]; return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve() } } class Gp { constructor(e) { this.parser = e, this.name = Np.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Uh : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], s = r.extensions[this.name]; t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture)); const a = s.specularColorFactor || [1, 1, 1]; return t.specularColor = new $r(a[0], a[1], a[2]), void 0 !== s.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture).then(function (e) { e.encoding = zt })), Promise.all(i) } } class kp { constructor(e) { this.parser = e, this.name = Np.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, n = t.json, r = n.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; const i = r.extensions[this.name], s = n.images[i.source], a = t.options.ktx2Loader; if (!a) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, s, a) } } class Vp { constructor(e) { this.parser = e, this.name = Np.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, r = n.json, i = r.textures[e]; if (!i.extensions || !i.extensions[t]) return null; const s = i.extensions[t], a = r.images[s.source]; let o = n.textureLoader; if (a.uri) { const e = n.options.manager.getHandler(a.uri); null !== e && (o = e) } return this.detectSupport().then(function (i) { if (i) return n.loadTextureImage(e, a, o); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } })), this.isSupported } } class Wp { constructor(e) { this.name = Np.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, n = t.bufferViews[e]; if (n.extensions && n.extensions[this.name]) { const e = n.extensions[this.name], r = this.parser.getDependency("buffer", e.buffer), i = this.parser.options.meshoptDecoder; if (!i || !i.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return Promise.all([r, i.ready]).then(function (t) { const n = e.byteOffset || 0, r = e.byteLength || 0, s = e.count, a = e.byteStride, o = new ArrayBuffer(s * a), l = new Uint8Array(t[0], n, r); return i.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o }) } return null } } const jp = "glTF", Xp = 12, qp = { JSON: 1313821514, BIN: 5130562 }; class Yp { constructor(e) { this.name = Np.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, Xp); if (this.header = { magic: Hu.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== jp) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - Xp, r = new DataView(e, Xp); let i = 0; for (; i < n;) { const t = r.getUint32(i, !0); i += 4; const n = r.getUint32(i, !0); if (i += 4, n === qp.JSON) { const n = new Uint8Array(e, Xp + i, t); this.content = Hu.decodeText(n) } else if (n === qp.BIN) { const n = Xp + i; this.body = e.slice(n, n + t) } i += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class Zp { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = Np.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const n = this.json, r = this.dracoLoader, i = e.extensions[this.name].bufferView, s = e.extensions[this.name].attributes, a = {}, o = {}, l = {}; for (const e in s) { const t = lm[e] || e.toLowerCase(); a[t] = s[e] } for (const t in e.attributes) { const r = lm[t] || t.toLowerCase(); if (void 0 !== s[t]) { const i = n.accessors[e.attributes[t]], s = im[i.componentType]; l[r] = s, o[r] = !0 === i.normalized } } return t.getDependency("bufferView", i).then(function (e) { return new Promise(function (t) { r.decodeDracoFile(e, function (e) { for (const t in e.attributes) { const n = e.attributes[t], r = o[t]; void 0 !== r && (n.normalized = r) } t(e) }, a, l) }) }) } } class Jp { constructor() { this.name = Np.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale ? e : (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) } } class Kp extends Oh { constructor(e) { super(), this.isGLTFSpecularGlossinessMaterial = !0; const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), i = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), a = { specular: { value: (new $r).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = a, this.onBeforeCompile = function (e) { for (const t in a) e.uniforms[t] = a[t]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", i).replace("#include <lights_physical_fragment>", s) }, Object.defineProperties(this, { specular: { get: function () { return a.specular.value }, set: function (e) { a.specular.value = e } }, specularMap: { get: function () { return a.specularMap.value }, set: function (e) { a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return a.glossiness.value }, set: function (e) { a.glossiness.value = e } }, glossinessMap: { get: function () { return a.glossinessMap.value }, set: function (e) { a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } copy(e) { return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this } } class Qp { constructor() { this.name = Np.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return Kp } extendParams(e, t, n) { const r = t.extensions[this.name]; e.color = new $r(1, 1, 1), e.opacity = 1; const i = []; if (Array.isArray(r.diffuseFactor)) { const t = r.diffuseFactor; e.color.fromArray(t), e.opacity = t[3] } if (void 0 !== r.diffuseTexture && i.push(n.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new $r(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new $r(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) { const t = r.specularGlossinessTexture; i.push(n.assignTexture(e, "glossinessMap", t)), i.push(n.assignTexture(e, "specularMap", t)) } return Promise.all(i) } createMaterial(e) { const t = new Kp(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = Zt, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } class $p { constructor() { this.name = Np.KHR_MESH_QUANTIZATION } } class em extends Xh { constructor(e, t, n, r) { super(e, t, n, r) } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r; for (let e = 0; e !== r; e++)t[e] = n[i + e]; return t } } em.prototype.beforeStart_ = em.prototype.copySampleValue_, em.prototype.afterEnd_ = em.prototype.copySampleValue_, em.prototype.interpolate_ = function (e, t, n, r) { const i = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = 2 * a, l = 3 * a, c = r - t, h = (n - t) / c, u = h * h, d = u * h, p = e * l, m = p - l, f = -2 * d + 3 * u, g = d - u, v = 1 - f, y = g - u + h; for (let e = 0; e !== a; e++) { const t = s[m + e + a], n = s[m + e + o] * c, r = s[p + e + a], l = s[p + e] * c; i[e] = v * t + y * n + f * r + g * l } return i }; const tm = new Cn; class nm extends em { interpolate_(e, t, n, r) { const i = super.interpolate_(e, t, n, r); return tm.fromArray(i).normalize().toArray(i), i } } const rm = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, im = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, sm = { 9728: le, 9729: ue, 9984: ce, 9985: de, 9986: he, 9987: pe }, am = { 33071: ae, 33648: oe, 10497: se }, om = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, lm = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, cm = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, hm = { CUBICSPLINE: void 0, LINEAR: Ct, STEP: Lt }, um = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function dm(e, t, n) { for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r]) } function pm(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function mm(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, r = t.weights.length; n < r; n++)e.morphTargetInfluences[n] = t.weights[n]; if (t.extras && Array.isArray(t.extras.targetNames)) { const n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (let t = 0, r = n.length; t < r; t++)e.morphTargetDictionary[n[t]] = t } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function fm(e) { const t = e.extensions && e.extensions[Np.KHR_DRACO_MESH_COMPRESSION]; let n; return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + gm(t.attributes) : e.indices + ":" + gm(e.attributes) + ":" + e.mode } function gm(e) { let t = ""; const n = Object.keys(e).sort(); for (let r = 0, i = n.length; r < i; r++)t += n[r] + ":" + e[n[r]] + ";"; return t } function vm(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } class ym { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Ip, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new ju(this.options.manager) : this.textureLoader = new fu(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new uu(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const n = this, r = this.json, i = this.extensions; this.cache.removeAll(), this._invokeAll(function (e) { return e._markDefs && e._markDefs() }), Promise.all(this._invokeAll(function (e) { return e.beforeRoot && e.beforeRoot() })).then(function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) }).then(function (t) { const s = { scene: t[0][r.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: r.asset, parser: n, userData: {} }; dm(i, s, r), pm(s, r), Promise.all(n._invokeAll(function (e) { return e.afterRoot && e.afterRoot(s) })).then(function () { e(s) }) }).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || []; for (let n = 0, r = t.length; n < r; n++) { const r = t[n].joints; for (let t = 0, n = r.length; t < n; t++)e[r[t]].isBone = !0 } for (let t = 0, r = e.length; t < r; t++) { const r = e[t]; void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, n) { if (e.refs[t] <= 1) return n; const r = n.clone(), i = (e, t) => { const n = this.associations.get(e); null != n && this.associations.set(t, n); for (const [n, r] of e.children.entries()) i(r, t.children[n]) }; return i(n, r), r.name += "_instance_" + e.uses[t]++, r } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let n = 0; n < t.length; n++) { const r = e(t[n]); if (r) return r } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const n = []; for (let r = 0; r < t.length; r++) { const i = e(t[r]); i && n.push(i) } return n } getDependency(e, t) { const n = e + ":" + t; let r = this.cache.get(n); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne(function (e) { return e.loadMesh && e.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (e) { return e.loadBufferView && e.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (e) { return e.loadMaterial && e.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (e) { return e.loadTexture && e.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(n, r) } return r } getDependencies(e) { let t = this.cache.get(e); if (!t) { const n = this, r = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(r.map(function (t, r) { return n.getDependency(e, r) })), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], n = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Np.KHR_BINARY_GLTF].body); const r = this.options; return new Promise(function (e, i) { n.load(Hu.resolveURL(t.uri, r.path), e, void 0, function () { i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (e) { const n = t.byteLength || 0, r = t.byteOffset || 0; return e.slice(r, r + n) }) } loadAccessor(e) { const t = this, n = this.json, r = this.json.accessors[e]; if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null); const i = []; return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then(function (e) { const i = e[0], s = om[r.type], a = im[r.componentType], o = a.BYTES_PER_ELEMENT, l = o * s, c = r.byteOffset || 0, h = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0, u = !0 === r.normalized; let d, p; if (h && h !== l) { const e = Math.floor(c / h), n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count; let l = t.cache.get(n); l || (d = new a(i, e * h, r.count * h / o), l = new ol(d, h / o), t.cache.add(n, l)), p = new cl(l, s, c % h / o, u) } else d = null === i ? new a(r.count * s) : new a(i, c, r.count * s), p = new ri(d, s, u); if (void 0 !== r.sparse) { const t = om.SCALAR, n = im[r.sparse.indices.componentType], o = r.sparse.indices.byteOffset || 0, l = r.sparse.values.byteOffset || 0, c = new n(e[1], o, r.sparse.count * t), h = new a(e[2], l, r.sparse.count * s); null !== i && (p = new ri(p.array.slice(), p.itemSize, p.normalized)); for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; if (p.setX(t, h[e * s]), s >= 2 && p.setY(t, h[e * s + 1]), s >= 3 && p.setZ(t, h[e * s + 2]), s >= 4 && p.setW(t, h[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return p }) } loadTexture(e) { const t = this.json, n = this.options, r = t.textures[e], i = t.images[r.source]; let s = this.textureLoader; if (i.uri) { const e = n.manager.getHandler(i.uri); null !== e && (s = e) } return this.loadTextureImage(e, i, s) } loadTextureImage(e, t, n) { const r = this, i = this.json, s = this.options, a = i.textures[e], o = (t.uri || t.bufferView) + ":" + a.sampler; if (this.textureCache[o]) return this.textureCache[o]; const l = self.URL || self.webkitURL; let c = t.uri || "", h = !1; if (void 0 !== t.bufferView) c = r.getDependency("bufferView", t.bufferView).then(function (e) { h = !0; const n = new Blob([e], { type: t.mimeType }); return c = l.createObjectURL(n) }); else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const u = Promise.resolve(c).then(function (e) { return new Promise(function (t, r) { let i = t; !0 === n.isImageBitmapLoader && (i = function (e) { const n = new bn(e); n.needsUpdate = !0, t(n) }), n.load(Hu.resolveURL(e, s.path), i, void 0, r) }) }).then(function (t) { !0 === h && l.revokeObjectURL(c), t.flipY = !1, a.name && (t.name = a.name); const n = (i.samplers || {})[a.sampler] || {}; return t.magFilter = sm[n.magFilter] || ue, t.minFilter = sm[n.minFilter] || pe, t.wrapS = am[n.wrapS] || se, t.wrapT = am[n.wrapT] || se, r.associations.set(t, { textures: e }), t }).catch(function () { return console.error("THREE.GLTFLoader: Couldn't load texture", c), null }); return this.textureCache[o] = u, u } assignTexture(e, t, n) { const r = this; return this.getDependency("texture", n.index).then(function (i) { if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), r.extensions[Np.KHR_TEXTURE_TRANSFORM]) { const e = void 0 !== n.extensions ? n.extensions[Np.KHR_TEXTURE_TRANSFORM] : void 0; if (e) { const t = r.associations.get(i); i = r.extensions[Np.KHR_TEXTURE_TRANSFORM].extendTexture(i, e), r.associations.set(i, t) } } return e[t] = i, i }) } assignFinalMaterial(e) { const t = e.geometry; let n = e.material; const r = void 0 === t.attributes.tangent, i = void 0 !== t.attributes.color, s = void 0 === t.attributes.normal; if (e.isPoints) { const e = "PointsMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new rc, Xr.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t } else if (e.isLine) { const e = "LineBasicMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new Xl, Xr.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t } if (r || i || s) { let e = "ClonedMaterial:" + n.uuid + ":"; n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), r && (e += "derivative-tangents:"), i && (e += "vertex-colors:"), s && (e += "flat-shading:"); let t = this.cache.get(e); t || (t = n.clone(), i && (t.vertexColors = !0), s && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t } n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n } getMaterialType() { return Oh } loadMaterial(e) { const t = this, n = this.json, r = this.extensions, i = n.materials[e]; let s; const a = {}, o = i.extensions || {}, l = []; if (o[Np.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const e = r[Np.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; s = e.getMaterialType(), l.push(e.extendParams(a, i, t)) } else if (o[Np.KHR_MATERIALS_UNLIT]) { const e = r[Np.KHR_MATERIALS_UNLIT]; s = e.getMaterialType(), l.push(e.extendParams(a, i, t)) } else { const n = i.pbrMetallicRoughness || {}; if (a.color = new $r(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) { const e = n.baseColorFactor; a.color.fromArray(e), a.opacity = e[3] } void 0 !== n.baseColorTexture && l.push(t.assignTexture(a, "map", n.baseColorTexture)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), l.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne(function (t) { return t.getMaterialType && t.getMaterialType(e) }), l.push(Promise.all(this._invokeAll(function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, a) }))) } !0 === i.doubleSided && (a.side = u); const c = i.alphaMode || um.OPAQUE; if (c === um.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.format = Ae, a.transparent = !1, c === um.MASK && (a.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && s !== ei && (l.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new gn(1, 1), void 0 !== i.normalTexture.scale)) { const e = i.normalTexture.scale; a.normalScale.set(e, e) } return void 0 !== i.occlusionTexture && s !== ei && (l.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (a.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && s !== ei && (a.emissive = (new $r).fromArray(i.emissiveFactor)), void 0 !== i.emissiveTexture && s !== ei && l.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture)), Promise.all(l).then(function () { let n; return n = s === Kp ? r[Np.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a), i.name && (n.name = i.name), n.map && (n.map.encoding = zt), n.emissiveMap && (n.emissiveMap.encoding = zt), pm(n, i), t.associations.set(n, { materials: e }), i.extensions && dm(r, n, i), n }) } createUniqueName(e) { const t = Md.sanitizeNodeName(e || ""); let n = t; for (let e = 1; this.nodeNamesUsed[n]; ++e)n = t + "_" + e; return this.nodeNamesUsed[n] = !0, n } loadGeometries(e) { const t = this, n = this.extensions, r = this.primitiveCache; function i(e) { return n[Np.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (n) { return _m(n, e, t) }) } const s = []; for (let n = 0, a = e.length; n < a; n++) { const a = e[n], o = fm(a), l = r[o]; if (l) s.push(l.promise); else { let e; e = a.extensions && a.extensions[Np.KHR_DRACO_MESH_COMPRESSION] ? i(a) : _m(new Ti, a, t), r[o] = { primitive: a, promise: e }, s.push(e) } } return Promise.all(s) } loadMesh(e) { const t = this, n = this.json, r = this.extensions, i = n.meshes[e], s = i.primitives, a = []; for (let e = 0, t = s.length; e < t; e++) { const t = void 0 === s[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new Oh({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: c })), o.DefaultMaterial) : this.getDependency("material", s[e].material); a.push(t) } var o; return a.push(t.loadGeometries(s)), Promise.all(a).then(function (n) { const a = n.slice(0, n.length - 1), o = n[n.length - 1], l = []; for (let n = 0, c = o.length; n < c; n++) { const c = o[n], h = s[n]; let u; const d = a[n]; if (h.mode === rm.TRIANGLES || h.mode === rm.TRIANGLE_STRIP || h.mode === rm.TRIANGLE_FAN || void 0 === h.mode) !0 !== (u = !0 === i.isSkinnedMesh ? new Dl(c, d) : new ki(c, d)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), h.mode === rm.TRIANGLE_STRIP ? u.geometry = bm(u.geometry, Ut) : h.mode === rm.TRIANGLE_FAN && (u.geometry = bm(u.geometry, Bt)); else if (h.mode === rm.LINES) u = new tc(c, d); else if (h.mode === rm.LINE_STRIP) u = new Ql(c, d); else if (h.mode === rm.LINE_LOOP) u = new nc(c, d); else { if (h.mode !== rm.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode); u = new lc(c, d) } Object.keys(u.geometry.morphAttributes).length > 0 && mm(u, i), u.name = t.createUniqueName(i.name || "mesh_" + e), pm(u, i), h.extensions && dm(r, u, h), t.assignFinalMaterial(u), l.push(u) } for (let n = 0, r = l.length; n < r; n++)t.associations.set(l[n], { meshes: e, primitives: n }); if (1 === l.length) return l[0]; const c = new Ko; t.associations.set(c, { meshes: e }); for (let e = 0, t = l.length; e < t; e++)c.add(l[e]); return c }) } loadCamera(e) { let t; const n = this.json.cameras[e], r = n[n.type]; if (r) return "perspective" === n.type ? t = new Qi(fn.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new Ms(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), pm(t, n), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = this.json.skins[e], n = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) { return n.inverseBindMatrices = e, n }) } loadAnimation(e) { const t = this.json.animations[e], n = [], r = [], i = [], s = [], a = []; for (let e = 0, o = t.channels.length; e < o; e++) { const o = t.channels[e], l = t.samplers[o.sampler], c = o.target, h = void 0 !== c.node ? c.node : c.id, u = void 0 !== t.parameters ? t.parameters[l.input] : l.input, d = void 0 !== t.parameters ? t.parameters[l.output] : l.output; n.push(this.getDependency("node", h)), r.push(this.getDependency("accessor", u)), i.push(this.getDependency("accessor", d)), s.push(l), a.push(c) } return Promise.all([Promise.all(n), Promise.all(r), Promise.all(i), Promise.all(s), Promise.all(a)]).then(function (n) { const r = n[0], i = n[1], s = n[2], a = n[3], o = n[4], l = []; for (let e = 0, t = r.length; e < t; e++) { const t = r[e], n = i[e], c = s[e], h = a[e], u = o[e]; if (void 0 === t) continue; let d; switch (t.updateMatrix(), t.matrixAutoUpdate = !0, cm[u.path]) { case cm.weights: d = $h; break; case cm.rotation: d = tu; break; case cm.position: case cm.scale: default: d = ru }const p = t.name ? t.name : t.uuid, m = void 0 !== h.interpolation ? hm[h.interpolation] : Ct, f = []; cm[u.path] === cm.weights ? t.traverse(function (e) { !0 === e.isMesh && e.morphTargetInfluences && f.push(e.name ? e.name : e.uuid) }) : f.push(p); let g = c.array; if (c.normalized) { const e = vm(g.constructor), t = new Float32Array(g.length); for (let n = 0, r = g.length; n < r; n++)t[n] = g[n] * e; g = t } for (let e = 0, t = f.length; e < t; e++) { const t = new d(f[e] + "." + cm[u.path], n.array, g, m); "CUBICSPLINE" === h.interpolation && (t.createInterpolant = function (e) { return new (this instanceof tu ? nm : em)(this.times, this.values, this.getValueSize() / 3, e) }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(t) } } const c = t.name ? t.name : "animation_" + e; return new iu(c, void 0, l) }) } createNodeMesh(e) { const t = this.json, n = this, r = t.nodes[e]; return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then(function (e) { const t = n._getNodeRef(n.meshCache, r.mesh, e); return void 0 !== r.weights && t.traverse(function (e) { if (e.isMesh) for (let t = 0, n = r.weights.length; t < n; t++)e.morphTargetInfluences[t] = r.weights[t] }), t }) } loadNode(e) { const t = this.json, n = this.extensions, r = this, i = t.nodes[e], s = i.name ? r.createUniqueName(i.name) : ""; return function () { const t = [], n = r._invokeOne(function (t) { return t.createNodeMesh && t.createNodeMesh(e) }); return n && t.push(n), void 0 !== i.camera && t.push(r.getDependency("camera", i.camera).then(function (e) { return r._getNodeRef(r.cameraCache, i.camera, e) })), r._invokeAll(function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) }).forEach(function (e) { t.push(e) }), Promise.all(t) }().then(function (t) { let a; if ((a = !0 === i.isBone ? new Fl : t.length > 1 ? new Ko : 1 === t.length ? t[0] : new Nr) !== t[0]) for (let e = 0, n = t.length; e < n; e++)a.add(t[e]); if (i.name && (a.userData.name = i.name, a.name = s), pm(a, i), i.extensions && dm(n, a, i), void 0 !== i.matrix) { const e = new lr; e.fromArray(i.matrix), a.applyMatrix4(e) } else void 0 !== i.translation && a.position.fromArray(i.translation), void 0 !== i.rotation && a.quaternion.fromArray(i.rotation), void 0 !== i.scale && a.scale.fromArray(i.scale); return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = e, a }) } loadScene(e) { const t = this.json, n = this.extensions, r = this.json.scenes[e], i = this, s = new Ko; r.name && (s.name = i.createUniqueName(r.name)), pm(s, r), r.extensions && dm(n, s, r); const a = r.nodes || [], o = []; for (let e = 0, n = a.length; e < n; e++)o.push(xm(a[e], s, t, i)); return Promise.all(o).then(function () { return i.associations = (e => { const t = new Map; for (const [e, n] of i.associations) (e instanceof Xr || e instanceof bn) && t.set(e, n); return e.traverse(e => { const n = i.associations.get(e); null != n && t.set(e, n) }), t })(s), s }) } } function xm(e, t, n, r) { const i = n.nodes[e]; return r.getDependency("node", e).then(function (e) { if (void 0 === i.skin) return e; let t; return r.getDependency("skin", i.skin).then(function (e) { const n = []; for (let i = 0, s = (t = e).joints.length; i < s; i++)n.push(r.getDependency("node", t.joints[i])); return Promise.all(n) }).then(function (n) { return e.traverse(function (e) { if (!e.isMesh) return; const r = [], i = []; for (let e = 0, s = n.length; e < s; e++) { const s = n[e]; if (s) { r.push(s); const n = new lr; void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), i.push(n) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]) } e.bind(new Hl(r, i), e.matrixWorld) }), e }) }).then(function (e) { t.add(e); const s = []; if (i.children) { const t = i.children; for (let i = 0, a = t.length; i < a; i++) { const a = t[i]; s.push(xm(a, e, n, r)) } } return Promise.all(s) }) } function _m(e, t, n) { const r = t.attributes, i = []; function s(t, r) { return n.getDependency("accessor", t).then(function (t) { e.setAttribute(r, t) }) } for (const t in r) { const n = lm[t] || t.toLowerCase(); n in e.attributes || i.push(s(r[t], n)) } if (void 0 !== t.indices && !e.index) { const r = n.getDependency("accessor", t.indices).then(function (t) { e.setIndex(t) }); i.push(r) } return pm(e, t), function (e, t, n) { const r = t.attributes, i = new Dn; if (void 0 === r.POSITION) return; { const e = n.json.accessors[r.POSITION], t = e.min, s = e.max; if (void 0 === t || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (i.set(new Pn(t[0], t[1], t[2]), new Pn(s[0], s[1], s[2])), e.normalized) { const t = vm(im[e.componentType]); i.min.multiplyScalar(t), i.max.multiplyScalar(t) } } const s = t.targets; if (void 0 !== s) { const e = new Pn, t = new Pn; for (let r = 0, i = s.length; r < i; r++) { const i = s[r]; if (void 0 !== i.POSITION) { const r = n.json.accessors[i.POSITION], s = r.min, a = r.max; if (void 0 !== s && void 0 !== a) { if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), r.normalized) { const e = vm(im[r.componentType]); t.multiplyScalar(e) } e.max(t) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } i.expandByVector(e) } e.boundingBox = i; const a = new $n; i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = a }(e, t, n), Promise.all(i).then(function () { return void 0 !== t.targets ? function (e, t, n) { let r = !1, i = !1; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), r && i) break } if (!r && !i) return Promise.resolve(e); const s = [], a = []; for (let o = 0, l = t.length; o < l; o++) { const l = t[o]; if (r) { const t = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : e.attributes.position; s.push(t) } if (i) { const t = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : e.attributes.normal; a.push(t) } } return Promise.all([Promise.all(s), Promise.all(a)]).then(function (t) { const n = t[0], s = t[1]; return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = s), e.morphTargetsRelative = !0, e }) }(e, t.targets, n) : e }) } function bm(e, t) { let n = e.getIndex(); if (null === n) { const t = [], r = e.getAttribute("position"); if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let e = 0; e < r.count; e++)t.push(e); e.setIndex(t), n = e.getIndex() } const r = n.count - 2, i = []; if (t === Bt) for (let e = 1; e <= r; e++)i.push(n.getX(0)), i.push(n.getX(e)), i.push(n.getX(e + 1)); else for (let e = 0; e < r; e++)e % 2 == 0 ? (i.push(n.getX(e)), i.push(n.getX(e + 1)), i.push(n.getX(e + 2))) : (i.push(n.getX(e + 2)), i.push(n.getX(e + 1)), i.push(n.getX(e))); i.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = e.clone(); return s.setIndex(i), s } e.ACESFilmicToneMapping = J, e.AddEquation = x, e.AddOperation = j, e.AdditiveAnimationBlendMode = Ot, e.AdditiveBlending = f, e.AlphaFormat = Se, e.AlwaysDepth = O, e.AlwaysStencilFunc = Qt, e.AmbientLight = Du, e.AmbientLightProbe = $u, e.AnimationClip = iu, e.AnimationLoader = class extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = new uu(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } parse(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = iu.parse(e[n]); t.push(r) } return t } }, e.AnimationMixer = Sd, e.AnimationObjectGroup = Td, e.AnimationUtils = jh, e.ArcCurve = Sc, e.ArrayCamera = Jo, e.ArrowHelper = class extends Nr { constructor(e = new Pn(0, 0, 1), t = new Pn(0, 0, 0), n = 1, r = 16776960, i = .2 * n, s = .2 * i) { super(), this.type = "ArrowHelper", void 0 === rp && ((rp = new Ti).setAttribute("position", new di([0, 0, 0, 0, 1, 0], 3)), (ip = new fc(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Ql(rp, new Xl({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ki(ip, new ei({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, s) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { np.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(np, t) } } setLength(e, t = .2 * e, n = .2 * t) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } }, e.Audio = ld, e.AudioAnalyser = pd, e.AudioContext = Ju, e.AudioListener = class extends Nr { constructor() { super(), this.type = "AudioListener", this.context = Ju.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new nd } getInput() { return this.gain } removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, n = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(id, sd, ad), od.set(0, 0, -1).applyQuaternion(sd), t.positionX) { const e = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(id.x, e), t.positionY.linearRampToValueAtTime(id.y, e), t.positionZ.linearRampToValueAtTime(id.z, e), t.forwardX.linearRampToValueAtTime(od.x, e), t.forwardY.linearRampToValueAtTime(od.y, e), t.forwardZ.linearRampToValueAtTime(od.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e) } else t.setPosition(id.x, id.y, id.z), t.setOrientation(od.x, od.y, od.z, n.x, n.y, n.z) } }, e.AudioLoader = Ku, e.AxesHelper = sp, e.AxisHelper = function (e) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new sp(e) }, e.BackSide = h, e.BasicDepthPacking = qt, e.BasicShadowMap = 0, e.BinaryTextureLoader = function (e) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new mu(e) }, e.Bone = Fl, e.BooleanKeyframeTrack = Kh, e.BoundingBoxHelper = function (e, t) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new tp(e, t) }, e.Box2 = Dd, e.Box3 = Dn, e.Box3Helper = class extends tc { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Ti; r.setIndex(new ri(n, 1)), r.setAttribute("position", new di([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new Xl({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } }, e.BoxBufferGeometry = Wi, e.BoxGeometry = Wi, e.BoxHelper = tp, e.BufferAttribute = ri, e.BufferGeometry = Ti, e.BufferGeometryLoader = Gu, e.ByteType = fe, e.Cache = au, e.Camera = Ki, e.CameraHelper = class extends tc { constructor(e) { const t = new Ti, n = new Xl({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], i = [], s = {}, a = new $r(16755200), o = new $r(16711680), l = new $r(43775), c = new $r(16777215), h = new $r(3355443); function u(e, t, n) { d(e, n), d(t, n) } function d(e, t) { r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(r.length / 3 - 1) } u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), t.setAttribute("position", new di(r, 3)), t.setAttribute("color", new di(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update() } update() { const e = this.geometry, t = this.pointMap; Qd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), $d("c", t, e, Qd, 0, 0, -1), $d("t", t, e, Qd, 0, 0, 1), $d("n1", t, e, Qd, -1, -1, -1), $d("n2", t, e, Qd, 1, -1, -1), $d("n3", t, e, Qd, -1, 1, -1), $d("n4", t, e, Qd, 1, 1, -1), $d("f1", t, e, Qd, -1, -1, 1), $d("f2", t, e, Qd, 1, -1, 1), $d("f3", t, e, Qd, -1, 1, 1), $d("f4", t, e, Qd, 1, 1, 1), $d("u1", t, e, Qd, .7, 1.1, -1), $d("u2", t, e, Qd, -.7, 1.1, -1), $d("u3", t, e, Qd, 0, 2, -1), $d("cf1", t, e, Qd, -1, 0, 1), $d("cf2", t, e, Qd, 1, 0, 1), $d("cf3", t, e, Qd, 0, -1, 1), $d("cf4", t, e, Qd, 0, 1, 1), $d("cn1", t, e, Qd, -1, 0, -1), $d("cn2", t, e, Qd, 1, 0, -1), $d("cn3", t, e, Qd, 0, -1, -1), $d("cn4", t, e, Qd, 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } }, e.CanvasRenderer = function () { console.error("THREE.CanvasRenderer has been removed") }, e.CanvasTexture = dc, e.CatmullRomCurve3 = Ic, e.CineonToneMapping = Z, e.CircleBufferGeometry = mc, e.CircleGeometry = mc, e.ClampToEdgeWrapping = ae, e.Clock = nd, e.Color = $r, e.ColorKeyframeTrack = Qh, e.CompressedTexture = uc, e.CompressedTextureLoader = class extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = [], a = new uc, o = new uu(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(i.withCredentials); let l = 0; function c(c) { o.load(e[c], function (e) { const n = i.parse(e, !0); s[c] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === (l += 1) && (1 === n.mipmapCount && (a.minFilter = ue), a.image = s, a.format = n.format, a.needsUpdate = !0, t && t(a)) }, n, r) } if (Array.isArray(e)) for (let t = 0, n = e.length; t < n; ++t)c(t); else o.load(e, function (e) { const n = i.parse(e, !0); if (n.isCubemap) { const e = n.mipmaps.length / n.mipmapCount; for (let t = 0; t < e; t++) { s[t] = { mipmaps: [] }; for (let e = 0; e < n.mipmapCount; e++)s[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), s[t].format = n.format, s[t].width = n.width, s[t].height = n.height } a.image = s } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps; 1 === n.mipmapCount && (a.minFilter = ue), a.format = n.format, a.needsUpdate = !0, t && t(a) }, n, r); return a } }, e.ConeBufferGeometry = gc, e.ConeGeometry = gc, e.CubeCamera = ts, e.CubeReflectionMapping = $, e.CubeRefractionMapping = ee, e.CubeTexture = ns, e.CubeTextureLoader = pu, e.CubeUVReflectionMapping = re, e.CubeUVRefractionMapping = ie, e.CubicBezierCurve = Oc, e.CubicBezierCurve3 = Uc, e.CubicInterpolant = qh, e.CullFaceBack = i, e.CullFaceFront = s, e.CullFaceFrontBack = 3, e.CullFaceNone = r, e.Curve = Tc, e.CurvePath = gu, e.CustomBlending = y, e.CustomToneMapping = K, e.CylinderBufferGeometry = fc, e.CylinderGeometry = fc, e.Cylindrical = class { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.theta = t, this.y = n, this } set(e, t, n) { return this.radius = e, this.theta = t, this.y = n, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this } clone() { return (new this.constructor).copy(this) } }, e.DataTexture = Ol, e.DataTexture2DArray = sa, e.DataTexture3D = aa, e.DataTextureLoader = mu, e.DataUtils = class { static toHalfFloat(e) { ap[0] = e; const t = op[0]; let n = t >> 16 & 32768, r = t >> 12 & 2047; const i = t >> 23 & 255; return i < 103 ? n : i > 142 ? (n |= 31744, n |= (255 == i ? 0 : 1) && 8388607 & t) : i < 113 ? n |= ((r |= 2048) >> 114 - i) + (r >> 113 - i & 1) : (n |= i - 112 << 10 | r >> 1, n += 1 & r) } }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = lu, e.DepthFormat = Ie, e.DepthStencilFormat = Ne, e.DepthTexture = pc, e.DirectionalLight = Nu, e.DirectionalLightHelper = class extends Nr { constructor(e, t, n) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1); let r = new Ti; r.setAttribute("position", new di([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const i = new Xl({ fog: !1, toneMapped: !1 }); this.lightPlane = new Ql(r, i), this.add(this.lightPlane), (r = new Ti).setAttribute("position", new di([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ql(r, i), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { Yd.setFromMatrixPosition(this.light.matrixWorld), Zd.setFromMatrixPosition(this.light.target.matrixWorld), Jd.subVectors(Zd, Yd), this.lightPlane.lookAt(Zd), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Zd), this.targetLine.scale.z = Jd.length() } }, e.DiscreteInterpolant = Zh, e.DodecahedronBufferGeometry = yc, e.DodecahedronGeometry = yc, e.DoubleSide = u, e.DstAlphaFactor = C, e.DstColorFactor = I, e.DynamicBufferAttribute = function (e, t) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new ri(e, t).setUsage(en) }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = en, e.DynamicReadUsage = 35049, e.EdgesGeometry = Mc, e.EdgesHelper = function (e, t) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new tc(new Mc(e.geometry), new Xl({ color: void 0 !== t ? t : 16777215 })) }, e.EllipseCurve = Ec, e.EqualDepth = H, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = te, e.EquirectangularRefractionMapping = ne, e.Euler = yr, e.EventDispatcher = nn, e.ExtrudeBufferGeometry = yh, e.ExtrudeGeometry = yh, e.FaceColors = 1, e.FileLoader = uu, e.FlatShading = d, e.Float16BufferAttribute = ui, e.Float32Attribute = function (e, t) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new di(e, t) }, e.Float32BufferAttribute = di, e.Float64Attribute = function (e, t) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new pi(e, t) }, e.Float64BufferAttribute = pi, e.FloatType = _e, e.Fog = sl, e.FogExp2 = il, e.Font = qu, e.FontLoader = class extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = new uu(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (e) { let n; try { n = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2)) } const r = i.parse(n); t && t(r) }, n, r) } parse(e) { return new qu(e) } }, e.FrontSide = c, e.Frustum = hs, e.GLBufferAttribute = Ld, e.GLSL1 = "100", e.GLSL3 = tn, e.GammaEncoding = Gt, e.GreaterDepth = G, e.GreaterEqualDepth = z, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = qd, e.Group = Ko, e.HalfFloatType = be, e.HemisphereLight = _u, e.HemisphereLightHelper = class extends Nr { constructor(e, t, n) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n; const r = new wh(t); r.rotateY(.5 * Math.PI), this.material = new ei({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0); const i = r.getAttribute("position"), s = new Float32Array(3 * i.count); r.setAttribute("color", new ri(s, 3)), this.add(new ki(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); jd.copy(this.light.color), Xd.copy(this.light.groundColor); for (let e = 0, n = t.count; e < n; e++) { const r = e < n / 2 ? jd : Xd; t.setXYZ(e, r.r, r.g, r.b) } t.needsUpdate = !0 } e.lookAt(Wd.setFromMatrixPosition(this.light.matrixWorld).negate()) } }, e.HemisphereLightProbe = Qu, e.IcosahedronBufferGeometry = _h, e.IcosahedronGeometry = _h, e.ImageBitmapLoader = ju, e.ImageLoader = du, e.ImageUtils = xn, e.ImmediateRenderObject = Bd, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = zl, e.InstancedBufferGeometry = zu, e.InstancedInterleavedBuffer = Rd, e.InstancedMesh = jl, e.Int16Attribute = function (e, t) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new oi(e, t) }, e.Int16BufferAttribute = oi, e.Int32Attribute = function (e, t) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new ci(e, t) }, e.Int32BufferAttribute = ci, e.Int8Attribute = function (e, t) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new ii(e, t) }, e.Int8BufferAttribute = ii, e.IntType = ye, e.InterleavedBuffer = ol, e.InterleavedBufferAttribute = cl, e.Interpolant = Xh, e.InterpolateDiscrete = Lt, e.InterpolateLinear = Ct, e.InterpolateSmooth = Pt, e.InvertStencilOp = 5386, e.JSONLoader = function () { console.error("THREE.JSONLoader has been removed.") }, e.KeepStencilOp = Kt, e.KeyframeTrack = Jh, e.LOD = Rl, e.LatheBufferGeometry = bh, e.LatheGeometry = bh, e.Layers = xr, e.LensFlare = function () { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") }, e.LessDepth = U, e.LessEqualDepth = B, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = xu, e.LightProbe = Uu, e.Line = Ql, e.Line3 = Ud, e.LineBasicMaterial = Xl, e.LineCurve = Bc, e.LineCurve3 = Hc, e.LineDashedMaterial = Vh, e.LineLoop = nc, e.LinePieces = 1, e.LineSegments = tc, e.LineStrip = 0, e.LinearEncoding = Ht, e.LinearFilter = ue, e.LinearInterpolant = Yh, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = pe, e.LinearMipmapNearestFilter = de, e.LinearToneMapping = q, e.Loader = cu, e.LoaderUtils = Hu, e.LoadingManager = ou, e.LogLuvEncoding = Vt, e.LoopOnce = St, e.LoopPingPong = Rt, e.LoopRepeat = At, e.LuminanceAlphaFormat = Ce, e.LuminanceFormat = Le, e.MOUSE = t, e.Material = Xr, e.MaterialLoader = Bu, e.Math = fn, e.MathUtils = fn, e.Matrix3 = vn, e.Matrix4 = lr, e.MaxEquation = M, e.Mesh = ki, e.MeshBasicMaterial = ei, e.MeshDepthMaterial = ko, e.MeshDistanceMaterial = Vo, e.MeshFaceMaterial = function (e) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e }, e.MeshLambertMaterial = Gh, e.MeshMatcapMaterial = kh, e.MeshNormalMaterial = zh, e.MeshPhongMaterial = Bh, e.MeshPhysicalMaterial = Uh, e.MeshStandardMaterial = Oh, e.MeshToonMaterial = Hh, e.MinEquation = w, e.MirroredRepeatWrapping = oe, e.MixOperation = W, e.MultiMaterial = function (e = []) { return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function () { return e.slice() }, e }, e.MultiplyBlending = v, e.MultiplyOperation = V, e.NearestFilter = le, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = he, e.NearestMipmapNearestFilter = ce, e.NeverDepth = F, e.NeverStencilFunc = 512, e.NoBlending = p, e.NoColors = 0, e.NoToneMapping = X, e.NormalAnimationBlendMode = Ft, e.NormalBlending = m, e.NotEqualDepth = k, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = $h, e.Object3D = Nr, e.ObjectLoader = class extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = "" === this.path ? Hu.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || s; const a = new uu(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (n) { let s = null; try { s = JSON.parse(n) } catch (t) { return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message) } const a = s.metadata; void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(s, t) : console.error("THREE.ObjectLoader: Can't load " + e) }, n, r) } async loadAsync(e, t) { const n = "" === this.path ? Hu.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || n; const r = new uu(this.manager); r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials); const i = await r.loadAsync(e, t), s = JSON.parse(i), a = s.metadata; if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e); return await this.parseAsync(s) } parse(e, t) { const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), s = this.parseImages(e.images, function () { void 0 !== t && t(l) }), a = this.parseTextures(e.textures, s), o = this.parseMaterials(e.materials, a), l = this.parseObject(e.object, i, o, a, n), c = this.parseSkeletons(e.skeletons, l); if (this.bindSkeletons(l, c), void 0 !== t) { let e = !1; for (const t in s) if (s[t] instanceof HTMLImageElement) { e = !0; break } !1 === e && t(l) } return l } async parseAsync(e) { const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), i = await this.parseImagesAsync(e.images), s = this.parseTextures(e.textures, i), a = this.parseMaterials(e.materials, s), o = this.parseObject(e.object, r, a, s, t), l = this.parseSkeletons(e.skeletons, o); return this.bindSkeletons(o, l), o } parseShapes(e) { const t = {}; if (void 0 !== e) for (let n = 0, r = e.length; n < r; n++) { const r = (new yu).fromJSON(e[n]); t[r.uuid] = r } return t } parseSkeletons(e, t) { const n = {}, r = {}; if (t.traverse(function (e) { e.isBone && (r[e.uuid] = e) }), void 0 !== e) for (let t = 0, i = e.length; t < i; t++) { const i = (new Hl).fromJSON(e[t], r); n[i.uuid] = i } return n } parseGeometries(e, t) { const n = {}; if (void 0 !== e) { const r = new Gu; for (let i = 0, s = e.length; i < s; i++) { let s; const a = e[i]; switch (a.type) { case "BufferGeometry": case "InstancedBufferGeometry": s = r.parse(a); break; case "Geometry": console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported."); break; default: a.type in Dh ? s = Dh[a.type].fromJSON(a, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`) }s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s } } return n } parseMaterials(e, t) { const n = {}, r = {}; if (void 0 !== e) { const i = new Bu; i.setTextures(t); for (let t = 0, s = e.length; t < s; t++) { const s = e[t]; if ("MultiMaterial" === s.type) { const e = []; for (let t = 0; t < s.materials.length; t++) { const r = s.materials[t]; void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)), e.push(n[r.uuid]) } r[s.uuid] = e } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid] } } return r } parseAnimations(e) { const t = {}; if (void 0 !== e) for (let n = 0; n < e.length; n++) { const r = e[n], i = iu.parse(r); t[i.uuid] = i } return t } parseImages(e, t) { const n = this, r = {}; let i; function s(e) { if ("string" == typeof e) { const t = e; return function (e) { return n.manager.itemStart(e), i.load(e, function () { n.manager.itemEnd(e) }, void 0, function () { n.manager.itemError(e), n.manager.itemEnd(e) }) }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t) } return e.data ? { data: gi(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== e && e.length > 0) { const n = new ou(t); (i = new du(n)).setCrossOrigin(this.crossOrigin); for (let t = 0, n = e.length; t < n; t++) { const n = e[t], i = n.url; if (Array.isArray(i)) { r[n.uuid] = []; for (let e = 0, t = i.length; e < t; e++) { const t = s(i[e]); null !== t && (t instanceof HTMLImageElement ? r[n.uuid].push(t) : r[n.uuid].push(new Ol(t.data, t.width, t.height))) } } else { const e = s(n.url); null !== e && (r[n.uuid] = e) } } } return r } async parseImagesAsync(e) { const t = this, n = {}; let r; async function i(e) { if ("string" == typeof e) { const n = e, i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n; return await r.loadAsync(i) } return e.data ? { data: gi(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== e && e.length > 0) { (r = new du(this.manager)).setCrossOrigin(this.crossOrigin); for (let t = 0, r = e.length; t < r; t++) { const r = e[t], s = r.url; if (Array.isArray(s)) { n[r.uuid] = []; for (let e = 0, t = s.length; e < t; e++) { const t = s[e], a = await i(t); null !== a && (a instanceof HTMLImageElement ? n[r.uuid].push(a) : n[r.uuid].push(new Ol(a.data, a.width, a.height))) } } else { const e = await i(r.url); null !== e && (n[r.uuid] = e) } } } return n } parseTextures(e, t) { function n(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } const r = {}; if (void 0 !== e) for (let i = 0, s = e.length; i < s; i++) { const s = e[i]; let a; void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image); const o = t[s.image]; Array.isArray(o) ? (a = new ns(o), 6 === o.length && (a.needsUpdate = !0)) : (a = o && o.data ? new Ol(o.data, o.width, o.height) : new bn(o), o && (a.needsUpdate = !0)), a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, ku)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], Vu), a.wrapT = n(s.wrap[1], Vu)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Wu)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Wu)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), r[s.uuid] = a } return r } parseObject(e, t, n, r, i) { let s, a, o; function l(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] } function c(e) { if (void 0 !== e) { if (Array.isArray(e)) { const t = []; for (let r = 0, i = e.length; r < i; r++) { const i = e[r]; void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(n[i]) } return t } return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e] } } function h(e) { return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e] } switch (e.type) { case "Scene": s = new al, void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new $r(e.background) : s.background = h(e.background)), void 0 !== e.environment && (s.environment = h(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new sl(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new il(e.fog.color, e.fog.density))); break; case "PerspectiveCamera": s = new Qi(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (s.focus = e.focus), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset), void 0 !== e.view && (s.view = Object.assign({}, e.view)); break; case "OrthographicCamera": s = new Ms(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.view && (s.view = Object.assign({}, e.view)); break; case "AmbientLight": s = new Du(e.color, e.intensity); break; case "DirectionalLight": s = new Nu(e.color, e.intensity); break; case "PointLight": s = new Pu(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": s = new Fu(e.color, e.intensity, e.width, e.height); break; case "SpotLight": s = new Su(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": s = new _u(e.color, e.groundColor, e.intensity); break; case "LightProbe": s = (new Uu).fromJSON(e); break; case "SkinnedMesh": a = l(e.geometry), o = c(e.material), s = new Dl(a, o), void 0 !== e.bindMode && (s.bindMode = e.bindMode), void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (s.skeleton = e.skeleton); break; case "Mesh": a = l(e.geometry), o = c(e.material), s = new ki(a, o); break; case "InstancedMesh": a = l(e.geometry), o = c(e.material); const t = e.count, n = e.instanceMatrix, r = e.instanceColor; (s = new jl(a, o, t)).instanceMatrix = new zl(new Float32Array(n.array), 16), void 0 !== r && (s.instanceColor = new zl(new Float32Array(r.array), r.itemSize)); break; case "LOD": s = new Rl; break; case "Line": s = new Ql(l(e.geometry), c(e.material)); break; case "LineLoop": s = new nc(l(e.geometry), c(e.material)); break; case "LineSegments": s = new tc(l(e.geometry), c(e.material)); break; case "PointCloud": case "Points": s = new lc(l(e.geometry), c(e.material)); break; case "Sprite": s = new Tl(c(e.material)); break; case "Group": s = new Ko; break; case "Bone": s = new Fl; break; default: s = new Nr }if (s.uuid = e.uuid, void 0 !== e.name && (s.name = e.name), void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position), void 0 !== e.rotation && s.rotation.fromArray(e.rotation), void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion), void 0 !== e.scale && s.scale.fromArray(e.scale)), void 0 !== e.castShadow && (s.castShadow = e.castShadow), void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.layers && (s.layers.mask = e.layers), void 0 !== e.children) { const a = e.children; for (let e = 0; e < a.length; e++)s.add(this.parseObject(a[e], t, n, r, i)) } if (void 0 !== e.animations) { const t = e.animations; for (let e = 0; e < t.length; e++) { const n = t[e]; s.animations.push(i[n]) } } if ("LOD" === e.type) { void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate); const t = e.levels; for (let e = 0; e < t.length; e++) { const n = t[e], r = s.getObjectByProperty("uuid", n.object); void 0 !== r && s.addLevel(r, n.distance) } } return s } bindSkeletons(e, t) { 0 !== Object.keys(t).length && e.traverse(function (e) { if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) { const n = t[e.skeleton]; void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix) } }) } setTexturePath(e) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } }, e.ObjectSpaceNormalMap = Jt, e.OctahedronBufferGeometry = wh, e.OctahedronGeometry = wh, e.OneFactor = E, e.OneMinusDstAlphaFactor = P, e.OneMinusDstColorFactor = N, e.OneMinusSrcAlphaFactor = L, e.OneMinusSrcColorFactor = A, e.OrthographicCamera = Ms, e.PCFShadowMap = a, e.PCFSoftShadowMap = o, e.PMREMGenerator = Gs, e.ParametricBufferGeometry = Mh, e.ParametricGeometry = Mh, e.Particle = function (e) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Tl(e) }, e.ParticleBasicMaterial = function (e) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new rc(e) }, e.ParticleSystem = function (e, t) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new lc(e, t) }, e.ParticleSystemMaterial = function (e) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new rc(e) }, e.Path = vu, e.PerspectiveCamera = Qi, e.Plane = os, e.PlaneBufferGeometry = ps, e.PlaneGeometry = ps, e.PlaneHelper = class extends Ql { constructor(e, t = 1, n = 16776960) { const r = n, i = new Ti; i.setAttribute("position", new di([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), super(i, new Xl({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const s = new Ti; s.setAttribute("position", new di([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new ki(s, new ei({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { let t = -this.plane.constant; Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? h : c, this.lookAt(this.plane.normal), super.updateMatrixWorld(e) } }, e.PointCloud = function (e, t) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new lc(e, t) }, e.PointCloudMaterial = function (e) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new rc(e) }, e.PointLight = Pu, e.PointLightHelper = class extends ki { constructor(e, t, n) { super(new Sh(t, 4, 2), new ei({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } }, e.Points = lc, e.PointsMaterial = rc, e.PolarGridHelper = class extends tc { constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, s = 8947848) { i = new $r(i), s = new $r(s); const a = [], o = []; for (let n = 0; n <= t; n++) { const r = n / t * (2 * Math.PI), l = Math.sin(r) * e, c = Math.cos(r) * e; a.push(0, 0, 0), a.push(l, 0, c); const h = 1 & n ? i : s; o.push(h.r, h.g, h.b), o.push(h.r, h.g, h.b) } for (let t = 0; t <= n; t++) { const l = 1 & t ? i : s, c = e - e / n * t; for (let e = 0; e < r; e++) { let t = e / r * (2 * Math.PI), n = Math.sin(t) * c, i = Math.cos(t) * c; a.push(n, 0, i), o.push(l.r, l.g, l.b), t = (e + 1) / r * (2 * Math.PI), n = Math.sin(t) * c, i = Math.cos(t) * c, a.push(n, 0, i), o.push(l.r, l.g, l.b) } } const l = new Ti; l.setAttribute("position", new di(a, 3)), l.setAttribute("color", new di(o, 3)), super(l, new Xl({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper" } }, e.PolyhedronBufferGeometry = vc, e.PolyhedronGeometry = vc, e.PositionalAudio = class extends ld { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, n) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return; this.matrixWorld.decompose(cd, hd, ud), dd.set(0, 0, 1).applyQuaternion(hd); const t = this.panner; if (t.positionX) { const e = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(cd.x, e), t.positionY.linearRampToValueAtTime(cd.y, e), t.positionZ.linearRampToValueAtTime(cd.z, e), t.orientationX.linearRampToValueAtTime(dd.x, e), t.orientationY.linearRampToValueAtTime(dd.y, e), t.orientationZ.linearRampToValueAtTime(dd.z, e) } else t.setPosition(cd.x, cd.y, cd.z), t.setOrientation(dd.x, dd.y, dd.z) } }, e.PropertyBinding = Md, e.PropertyMixer = md, e.QuadraticBezierCurve = zc, e.QuadraticBezierCurve3 = Gc, e.Quaternion = Cn, e.QuaternionKeyframeTrack = tu, e.QuaternionLinearInterpolant = eu, e.REVISION = "132", e.RGBADepthPacking = Yt, e.RGBAFormat = Re, e.RGBAIntegerFormat = He, e.RGBA_ASTC_10x10_Format = lt, e.RGBA_ASTC_10x5_Format = st, e.RGBA_ASTC_10x6_Format = at, e.RGBA_ASTC_10x8_Format = ot, e.RGBA_ASTC_12x10_Format = ct, e.RGBA_ASTC_12x12_Format = ht, e.RGBA_ASTC_4x4_Format = Ke, e.RGBA_ASTC_5x4_Format = Qe, e.RGBA_ASTC_5x5_Format = $e, e.RGBA_ASTC_6x5_Format = et, e.RGBA_ASTC_6x6_Format = tt, e.RGBA_ASTC_8x5_Format = nt, e.RGBA_ASTC_8x6_Format = rt, e.RGBA_ASTC_8x8_Format = it, e.RGBA_BPTC_Format = ut, e.RGBA_ETC2_EAC_Format = Je, e.RGBA_PVRTC_2BPPV1_Format = qe, e.RGBA_PVRTC_4BPPV1_Format = Xe, e.RGBA_S3TC_DXT1_Format = Ge, e.RGBA_S3TC_DXT3_Format = ke, e.RGBA_S3TC_DXT5_Format = Ve, e.RGBDEncoding = Xt, e.RGBEEncoding = kt, e.RGBEFormat = Pe, e.RGBFormat = Ae, e.RGBIntegerFormat = Be, e.RGBM16Encoding = jt, e.RGBM7Encoding = Wt, e.RGB_ETC1_Format = Ye, e.RGB_ETC2_Format = Ze, e.RGB_PVRTC_2BPPV1_Format = je, e.RGB_PVRTC_4BPPV1_Format = We, e.RGB_S3TC_DXT1_Format = ze, e.RGFormat = Oe, e.RGIntegerFormat = Ue, e.RawShaderMaterial = Ts, e.Ray = or, e.Raycaster = class { constructor(e, t, n = 0, r = 1 / 0) { this.ray = new or(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new xr, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !1, n = []) { return Pd(e, this, n, t), n.sort(Cd), n } intersectObjects(e, t = !1, n = []) { for (let r = 0, i = e.length; r < i; r++)Pd(e[r], this, n, t); return n.sort(Cd), n } }, e.RectAreaLight = Fu, e.RedFormat = De, e.RedIntegerFormat = Fe, e.ReinhardToneMapping = Y, e.RepeatWrapping = se, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = b, e.RingBufferGeometry = Th, e.RingGeometry = Th, e.SRGB8_ALPHA8_ASTC_10x10_Format = Mt, e.SRGB8_ALPHA8_ASTC_10x5_Format = _t, e.SRGB8_ALPHA8_ASTC_10x6_Format = bt, e.SRGB8_ALPHA8_ASTC_10x8_Format = wt, e.SRGB8_ALPHA8_ASTC_12x10_Format = Tt, e.SRGB8_ALPHA8_ASTC_12x12_Format = Et, e.SRGB8_ALPHA8_ASTC_4x4_Format = dt, e.SRGB8_ALPHA8_ASTC_5x4_Format = pt, e.SRGB8_ALPHA8_ASTC_5x5_Format = mt, e.SRGB8_ALPHA8_ASTC_6x5_Format = ft, e.SRGB8_ALPHA8_ASTC_6x6_Format = gt, e.SRGB8_ALPHA8_ASTC_8x5_Format = vt, e.SRGB8_ALPHA8_ASTC_8x6_Format = yt, e.SRGB8_ALPHA8_ASTC_8x8_Format = xt, e.Scene = al, e.SceneUtils = lp, e.ShaderChunk = ms, e.ShaderLib = gs, e.ShaderMaterial = Ji, e.ShadowMaterial = Fh, e.Shape = yu, e.ShapeBufferGeometry = Eh, e.ShapeGeometry = Eh, e.ShapePath = Xu, e.ShapeUtils = fh, e.ShortType = ge, e.Skeleton = Hl, e.SkeletonHelper = Vd, e.SkinnedMesh = Dl, e.SmoothShading = 2, e.Sphere = $n, e.SphereBufferGeometry = Sh, e.SphereGeometry = Sh, e.Spherical = Id, e.SphericalHarmonics3 = Ou, e.SplineCurve = kc, e.SpotLight = Su, e.SpotLightHelper = class extends Nr { constructor(e, t) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t; const n = new Ti, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let e = 0, t = 1, n = 32; e < n; e++, t++) { const i = e / n * Math.PI * 2, s = t / n * Math.PI * 2; r.push(Math.cos(i), Math.sin(i), 1, Math.cos(s), Math.sin(s), 1) } n.setAttribute("position", new di(r, 3)); const i = new Xl({ fog: !1, toneMapped: !1 }); this.cone = new tc(n, i), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateMatrixWorld(); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), Hd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Hd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } }, e.Sprite = Tl, e.SpriteMaterial = hl, e.SrcAlphaFactor = R, e.SrcAlphaSaturateFactor = D, e.SrcColorFactor = S, e.StaticCopyUsage = 35046, e.StaticDrawUsage = $t, e.StaticReadUsage = 35045, e.StereoCamera = class { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Qi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Qi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep; const n = e.projectionMatrix.clone(), r = t.eyeSep / 2, i = r * t.near / t.focus, s = t.near * Math.tan(an * t.fov * .5) / t.zoom; let a, o; td.elements[12] = -r, ed.elements[12] = r, a = -s * t.aspect + i, o = s * t.aspect + i, n.elements[0] = 2 * t.near / (o - a), n.elements[8] = (o + a) / (o - a), this.cameraL.projectionMatrix.copy(n), a = -s * t.aspect - i, o = s * t.aspect - i, n.elements[0] = 2 * t.near / (o - a), n.elements[8] = (o + a) / (o - a), this.cameraR.projectionMatrix.copy(n) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(td), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ed) } }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = nu, e.SubtractEquation = _, e.SubtractiveBlending = g, e.TOUCH = n, e.TangentSpaceNormalMap = Zt, e.TetrahedronBufferGeometry = Ah, e.TetrahedronGeometry = Ah, e.TextBufferGeometry = Rh, e.TextGeometry = Rh, e.Texture = bn, e.TextureLoader = fu, e.TorusBufferGeometry = Lh, e.TorusGeometry = Lh, e.TorusKnotBufferGeometry = Ch, e.TorusKnotGeometry = Ch, e.Triangle = Wr, e.TriangleFanDrawMode = Bt, e.TriangleStripDrawMode = Ut, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = Ph, e.TubeGeometry = Ph, e.UVMapping = Q, e.Uint16Attribute = function (e, t) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new li(e, t) }, e.Uint16BufferAttribute = li, e.Uint32Attribute = function (e, t) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new hi(e, t) }, e.Uint32BufferAttribute = hi, e.Uint8Attribute = function (e, t) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new si(e, t) }, e.Uint8BufferAttribute = si, e.Uint8ClampedAttribute = function (e, t) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new ai(e, t) }, e.Uint8ClampedBufferAttribute = ai, e.Uniform = Ad, e.UniformsLib = fs, e.UniformsUtils = qi, e.UnsignedByteType = me, e.UnsignedInt248Type = Ee, e.UnsignedIntType = xe, e.UnsignedShort4444Type = we, e.UnsignedShort5551Type = Me, e.UnsignedShort565Type = Te, e.UnsignedShortType = ve, e.VSMShadowMap = l, e.Vector2 = gn, e.Vector3 = Pn, e.Vector4 = Sn, e.VectorKeyframeTrack = ru, e.Vertex = function (e, t, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Pn(e, t, n) }, e.VertexColors = 2, e.VideoTexture = hc, e.WebGL1Renderer = rl, e.WebGLCubeRenderTarget = rs, e.WebGLMultipleRenderTargets = Rn, e.WebGLMultisampleRenderTarget = Ln, e.WebGLRenderTarget = An, e.WebGLRenderTargetCube = function (e, t, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new rs(e, n) }, e.WebGLRenderer = nl, e.WebGLUtils = Zo, e.WireframeGeometry = Ih, e.WireframeHelper = function (e, t) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new tc(new Ih(e.geometry), new Xl({ color: void 0 !== t ? t : 16777215 })) }, e.WrapAroundEnding = Dt, e.XHRLoader = function (e) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new uu(e) }, e.ZeroCurvatureEnding = It, e.ZeroFactor = T, e.ZeroSlopeEnding = Nt, e.ZeroStencilOp = 0, e.sRGBEncoding = zt, e.ThreeMFLoader = class extends cu { constructor(e) { super(e), this.availableExtensions = [] } load(e, t, n, r) { const i = this, s = new uu(i.manager); s.setPath(i.path), s.setResponseType("arraybuffer"), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, function (n) { try { t(i.parse(n)) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } parse(e) { const t = this, n = new fu(this.manager); function r(e) { const t = [], n = (new DOMParser).parseFromString(e, "application/xml").querySelectorAll("Relationship"); for (let e = 0; e < n.length; e++) { const r = n[e], i = { target: r.getAttribute("Target"), id: r.getAttribute("Id"), type: r.getAttribute("Type") }; t.push(i) } return t } function i(e) { const t = { id: e.getAttribute("id"), basematerials: [] }, n = e.querySelectorAll("base"); for (let e = 0; e < n.length; e++) { const r = l(n[e]); r.index = e, t.basematerials.push(r) } return t } function s(e) { const t = { id: e.getAttribute("id"), texid: e.getAttribute("texid"), displaypropertiesid: e.getAttribute("displaypropertiesid") }, n = e.querySelectorAll("tex2coord"), r = []; for (let e = 0; e < n.length; e++) { const t = n[e], i = t.getAttribute("u"), s = t.getAttribute("v"); r.push(parseFloat(i), parseFloat(s)) } return t.uvs = new Float32Array(r), t } function a(e) { const t = { id: e.getAttribute("id"), displaypropertiesid: e.getAttribute("displaypropertiesid") }, n = e.querySelectorAll("color"), r = [], i = new $r; for (let e = 0; e < n.length; e++) { const t = n[e].getAttribute("color"); i.setStyle(t.substring(0, 7)), i.convertSRGBToLinear(), r.push(i.r, i.g, i.b) } return t.colors = new Float32Array(r), t } function o(e) { const t = { id: e.getAttribute("id") }, n = e.querySelectorAll("pbmetallic"), r = []; for (let e = 0; e < n.length; e++) { const t = n[e]; r.push({ name: t.getAttribute("name"), metallicness: parseFloat(t.getAttribute("metallicness")), roughness: parseFloat(t.getAttribute("roughness")) }) } return t.data = r, t } function l(e) { const t = {}; return t.name = e.getAttribute("name"), t.displaycolor = e.getAttribute("displaycolor"), t.displaypropertiesid = e.getAttribute("displaypropertiesid"), t } function c(e) { const t = e.querySelectorAll("triangles triangle"); if (0 == t.length) return function (e) { const t = {}, n = [], r = e.querySelectorAll("vertices vertex"), i = [], s = []; var a = parseFloat(e.getAttribute("ps")); for (let e = 0; e < r.length; e++) { const t = r[e], c = parseFloat(t.getAttribute("x")), h = parseFloat(t.getAttribute("y")), u = parseFloat(t.getAttribute("z")), d = t.getAttribute("p1"); n.push(c - a, h, u - a), n.push(c + a, h, u - a), n.push(c + a, h, u + a), n.push(c - a, h, u + a); var o = e << 2, l = {}; l.v1 = o, l.v2 = o + 1, l.v3 = o + 2, s.push(l.v1, l.v2, l.v3), d && (l.p1 = parseInt(d, 10)), l.pid = "m0", 0 < Object.keys(l).length && i.push(l), (l = {}).v1 = o + 2, l.v2 = o + 3, l.v3 = o + 0, s.push(l.v1, l.v2, l.v3), d && (l.p1 = parseInt(d, 10)), l.pid = "m0", 0 < Object.keys(l).length && i.push(l) } return t.vertices = new Float32Array(n), t.triangleProperties = i, t.triangles = new Uint32Array(s), t }(e); const n = e.querySelectorAll("vertices vertex"), r = {}, i = []; for (let e = 0; e < n.length; e++) { const t = n[e], r = t.getAttribute("x"), s = t.getAttribute("y"), a = t.getAttribute("z"); i.push(parseFloat(r), parseFloat(s), parseFloat(a)) } r.vertices = new Float32Array(i); const s = [], a = []; for (let e = 0; e < t.length; e++) { const n = t[e], r = n.getAttribute("v1"), i = n.getAttribute("v2"), o = n.getAttribute("v3"), l = n.getAttribute("p1"), c = n.getAttribute("p2"), h = n.getAttribute("p3"), u = n.getAttribute("pid"), d = {}; d.v1 = parseInt(r, 10), d.v2 = parseInt(i, 10), d.v3 = parseInt(o, 10), a.push(d.v1, d.v2, d.v3), l && (d.p1 = parseInt(l, 10)), c && (d.p2 = parseInt(c, 10)), h && (d.p3 = parseInt(h, 10)), u && (d.pid = u), 0 < Object.keys(d).length && s.push(d) } return r.triangleProperties = s, r.triangles = new Uint32Array(a), r } function h(e) { const t = {}; t.objectId = e.getAttribute("objectid"); const n = e.getAttribute("transform"); return n && (t.transform = u(n)), t } function u(e) { const t = []; e.split(" ").forEach(function (e) { t.push(parseFloat(e)) }); const n = new lr; return n.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0, 0, 0, 1), n } function d(e) { const t = { type: e.getAttribute("type") }, n = e.getAttribute("id"); n && (t.id = n); const r = e.getAttribute("pid"); r && (t.pid = r); const i = e.getAttribute("pindex"); i && (t.pindex = i); const s = e.getAttribute("thumbnail"); s && (t.thumbnail = s); const a = e.getAttribute("partnumber"); a && (t.partnumber = a); const o = e.getAttribute("name"); o && (t.name = o); const l = e.querySelector("mesh"); l && (t.mesh = c(l)); const u = e.querySelector("components"); return u && (t.components = function (e) { const t = [], n = e.querySelectorAll("component"); for (let e = 0; e < n.length; e++) { const r = h(n[e]); t.push(r) } return t }(u)), t } function p(e) { const t = { unit: e.getAttribute("unit") || "millimeter" }, n = e.querySelectorAll("metadata"); n && (t.metadata = function (e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n], i = r.getAttribute("name"); 0 <= ["Title", "Designer", "Description", "Copyright", "LicenseTerms", "Rating", "CreationDate", "ModificationDate"].indexOf(i) && (t[i] = r.textContent) } return t }(n)); const r = e.querySelector("resources"); r && (t.resources = function (e) { const t = { basematerials: {} }, n = e.querySelectorAll("basematerials"); for (let e = 0; e < n.length; e++) { const r = i(n[e]); t.basematerials[r.id] = r } t.texture2d = {}; const r = e.querySelectorAll("texture2d"); for (let e = 0; e < r.length; e++) { const n = r[e], i = { id: (l = n).getAttribute("id"), path: l.getAttribute("path"), contenttype: l.getAttribute("contenttype"), tilestyleu: l.getAttribute("tilestyleu"), tilestylev: l.getAttribute("tilestylev"), filter: l.getAttribute("filter") }; t.texture2d[i.id] = i } var l; t.colorgroup = {}; const c = e.querySelectorAll("colorgroup"); for (let e = 0; e < c.length; e++) { const n = a(c[e]); t.colorgroup[n.id] = n } t.pbmetallicdisplayproperties = {}; const h = e.querySelectorAll("pbmetallicdisplayproperties"); for (let e = 0; e < h.length; e++) { const n = o(h[e]); t.pbmetallicdisplayproperties[n.id] = n } t.texture2dgroup = {}; const u = e.querySelectorAll("texture2dgroup"); for (let e = 0; e < u.length; e++) { const n = s(u[e]); t.texture2dgroup[n.id] = n } t.object = {}; const p = e.querySelectorAll("object"); for (let e = 0; e < p.length; e++) { const n = d(p[e]); t.object[n.id] = n } return t }(r)); const l = e.querySelector("build"); return l && (t.build = function (e) { const t = [], n = e.querySelectorAll("item"); for (let e = 0; e < n.length; e++) { const r = n[e], i = { objectId: r.getAttribute("objectid") }, s = r.getAttribute("transform"); s && (i.transform = u(s)), t.push(i) } return t }(l)), t } function m(e, t, r, i) { const s = e.texid, a = r.resources.texture2d[s]; if (a) { const e = i[a.path], t = a.contenttype, r = new Blob([e], { type: t }), s = URL.createObjectURL(r), o = n.load(s, function () { URL.revokeObjectURL(s) }); switch (o.encoding = zt, a.tilestyleu) { case "wrap": o.wrapS = se; break; case "mirror": o.wrapS = oe; break; case "none": case "clamp": o.wrapS = ae; break; default: o.wrapS = se }switch (a.tilestylev) { case "wrap": o.wrapT = se; break; case "mirror": o.wrapT = oe; break; case "none": case "clamp": o.wrapT = ae; break; default: o.wrapT = se }switch (a.filter) { case "auto": o.magFilter = ue, o.minFilter = pe; break; case "linear": o.magFilter = ue, o.minFilter = ue; break; case "nearest": o.magFilter = le, o.minFilter = le; break; default: o.magFilter = ue, o.minFilter = pe }return o } return null } function f(e, t, n, r, i, s, a) { const o = a.pindex, l = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e], r = void 0 !== n.p1 ? n.p1 : o; void 0 === l[r] && (l[r] = []), l[r].push(n) } const c = Object.keys(l), h = []; for (let t = 0, o = c.length; t < o; t++) { const o = c[t], u = l[o], d = b(e.basematerials[o], r, i, s, a, w), p = new Ti, m = [], f = n.vertices; for (let e = 0, t = u.length; e < t; e++) { const t = u[e]; m.push(f[3 * t.v1 + 0]), m.push(f[3 * t.v1 + 1]), m.push(f[3 * t.v1 + 2]), m.push(f[3 * t.v2 + 0]), m.push(f[3 * t.v2 + 1]), m.push(f[3 * t.v2 + 2]), m.push(f[3 * t.v3 + 0]), m.push(f[3 * t.v3 + 1]), m.push(f[3 * t.v3 + 2]) } p.setAttribute("position", new di(m, 3)); const g = new ki(p, d); h.push(g) } return h } function g(e, t, n, r, i, s, a) { const o = new Ti, l = [], c = [], h = n.vertices, u = e.uvs; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; l.push(h[3 * n.v1 + 0]), l.push(h[3 * n.v1 + 1]), l.push(h[3 * n.v1 + 2]), l.push(h[3 * n.v2 + 0]), l.push(h[3 * n.v2 + 1]), l.push(h[3 * n.v2 + 2]), l.push(h[3 * n.v3 + 0]), l.push(h[3 * n.v3 + 1]), l.push(h[3 * n.v3 + 2]), c.push(u[2 * n.p1 + 0]), c.push(u[2 * n.p1 + 1]), c.push(u[2 * n.p2 + 0]), c.push(u[2 * n.p2 + 1]), c.push(u[2 * n.p3 + 0]), c.push(u[2 * n.p3 + 1]) } o.setAttribute("position", new di(l, 3)), o.setAttribute("uv", new di(c, 2)); const d = b(e, r, i, s, a, m), p = new Bh({ map: d, flatShading: !0 }); return new ki(o, p) } function v(e, t, n, r, i, s) { const a = new Ti, o = [], l = [], c = n.vertices, h = e.colors; for (let e = 0, n = t.length; e < n; e++) { const n = t[e], r = n.v1, i = n.v2, a = n.v3; o.push(c[3 * r + 0]), o.push(c[3 * r + 1]), o.push(c[3 * r + 2]), o.push(c[3 * i + 0]), o.push(c[3 * i + 1]), o.push(c[3 * i + 2]), o.push(c[3 * a + 0]), o.push(c[3 * a + 1]), o.push(c[3 * a + 2]); const u = void 0 !== n.p1 ? n.p1 : s.pindex, d = void 0 !== n.p2 ? n.p2 : u, p = void 0 !== n.p3 ? n.p3 : u; l.push(h[3 * u + 0]), l.push(h[3 * u + 1]), l.push(h[3 * u + 2]), l.push(h[3 * d + 0]), l.push(h[3 * d + 1]), l.push(h[3 * d + 2]), l.push(h[3 * p + 0]), l.push(h[3 * p + 1]), l.push(h[3 * p + 2]) } a.setAttribute("position", new di(o, 3)), a.setAttribute("color", new di(l, 3)); const u = new Bh({ vertexColors: !0, flatShading: !0 }); return new ki(a, u) } function y(e) { const t = new Ti; t.setIndex(new ri(e.triangles, 1)), t.setAttribute("position", new ri(e.vertices, 3)); const n = new Bh({ color: 16777215, flatShading: !0 }); return new ki(t, n) } function x(e, t) { return void 0 !== t.resources.texture2dgroup[e] ? "texture" : void 0 !== t.resources.basematerials[e] ? "material" : void 0 !== t.resources.colorgroup[e] ? "vertexColors" : "default" === e ? "default" : void 0 } function _(e, t, n, r, i) { const s = new Ko, a = function (e, t, n, r, i, s) { const a = Object.keys(e), o = []; for (let l = 0, c = a.length; l < c; l++) { const c = a[l], h = e[c]; switch (x(c, r)) { case "material": const e = f(r.resources.basematerials[c], h, t, n, r, i, s); for (let t = 0, n = e.length; t < n; t++)o.push(e[t]); break; case "texture": const a = r.resources.texture2dgroup[c]; o.push(g(a, h, t, n, r, i, s)); break; case "vertexColors": const l = r.resources.colorgroup[c]; o.push(v(l, h, t, 0, 0, s)); break; case "default": o.push(y(t)); break; default: console.error("THREE.3MFLoader: Unsupported resource type.") } } return o }(function (e, t, n) { const r = {}, i = t.triangleProperties, s = n.pid; for (let e = 0, t = i.length; e < t; e++) { const t = i[e]; let n = void 0 !== t.pid ? t.pid : s; void 0 === n && (n = "default"), void 0 === r[n] && (r[n] = []), r[n].push(t) } return r }(0, e, i), e, t, n, r, i); for (let e = 0, t = a.length; e < t; e++)s.add(a[e]); return s } function b(e, t, n, r, i, s) { return void 0 !== e.build ? e.build : (e.build = s(e, t, n, r, i), e.build) } function w(e, t, n) { let r; const i = e.displaypropertiesid, s = n.resources.pbmetallicdisplayproperties; if (null !== i && void 0 !== s[i]) { const t = s[i].data[e.index]; r = new Oh({ flatShading: !0, roughness: t.roughness, metalness: t.metallicness }) } else r = new Bh({ flatShading: !0 }); r.name = e.name; const a = e.displaycolor, o = a.substring(0, 7); return r.color.setStyle(o), r.color.convertSRGBToLinear(), 9 === a.length && (r.opacity = parseInt(a.charAt(7) + a.charAt(8), 16) / 255), r } function M(e, t, n, r) { const i = new Ko; for (let s = 0; s < e.length; s++) { const a = e[s]; let o = t[a.objectId]; void 0 === o && (T(a.objectId, t, n, r), o = t[a.objectId]); const l = o.clone(), c = a.transform; c && l.applyMatrix4(c), i.add(l) } return i } function T(e, n, r, i) { const s = r.resources.object[e]; if (s.mesh) { const e = s.mesh; !function (e, n, r) { if (!e) return; const i = [], s = Object.keys(e); for (let e = 0; e < s.length; e++) { const n = s[e]; for (let e = 0; e < t.availableExtensions.length; e++) { const r = t.availableExtensions[e]; r.ns === n && i.push(r) } } for (let t = 0; t < i.length; t++) { const s = i[t]; s.apply(r, e[s.ns], n) } }(r.extensions, e, r.xml), n[s.id] = b(e, n, r, i, s, _) } else { const e = s.components; n[s.id] = b(e, n, r, i, s, M) } } const E = function (e) { let t, n, i = null, s = null; const a = [], o = [], l = [], c = []; let h; const u = {}, d = {}; try { i = fflate.unzipSync(new Uint8Array(e)) } catch (e) { if (e instanceof ReferenceError) return console.error("THREE.3MFLoader: fflate missing and file is compressed."), null } for (s in i) s.match(/\_rels\/.rels$/) ? t = s : s.match(/3D\/_rels\/.*\.model\.rels$/) ? n = s : s.match(/^3D\/.*\.model$/) ? a.push(s) : s.match(/^3D\/Metadata\/.*\.xml$/) ? o.push(s) : s.match(/^3D\/Textures?\/.*/) ? l.push(s) : s.match(/^3D\/Other\/.*/) && c.push(s); const m = i[t], f = r(Hu.decodeText(m)); if (n) { const e = i[n]; h = r(Hu.decodeText(e)) } for (let e = 0; e < a.length; e++) { const t = a[e], n = i[t], r = Hu.decodeText(n), s = (new DOMParser).parseFromString(r, "application/xml"); "model" !== s.documentElement.nodeName.toLowerCase() && console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ", t); const o = s.querySelector("model"), l = {}; for (let e = 0; e < o.attributes.length; e++) { const t = o.attributes[e]; t.name.match(/^xmlns:(.+)$/) && (l[t.value] = RegExp.$1) } const c = p(o); c.xml = o, 0 < Object.keys(l).length && (c.extensions = l), u[t] = c } for (let e = 0; e < l.length; e++) { const t = l[e]; d[t] = i[t].buffer } return { rels: f, modelRels: h, model: u, printTicket: {}, texture: d, other: {} } }(e); return function (e, t) { const n = new Ko, r = function (e) { for (let t = 0; t < e.length; t++) { const n = e[t]; if ("model" === n.target.split(".").pop().toLowerCase()) return n } }(t.rels), i = t.model[r.target.substring(1)].build; for (let t = 0; t < i.length; t++) { const r = i[t], s = e[r.objectId], a = r.transform; a && s.applyMatrix4(a), n.add(s) } return n }(function (e) { const t = e.model, n = e.modelRels, r = {}, i = Object.keys(t), s = {}; if (n) for (let t = 0, r = n.length; t < r; t++) { const r = n[t], i = r.target.substring(1); e.texture[i] && (s[r.target] = e.texture[i]) } for (let e = 0; e < i.length; e++) { const n = t[i[e]], a = Object.keys(n.resources.object); for (let e = 0; e < a.length; e++)T(a[e], r, n, s) } return r }(E), E) } addExtension(e) { this.availableExtensions.push(e) } }, e.STLLoader = class extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = new uu(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (n) { try { t(i.parse(n)) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } parse(e) { function t(e, t, n) { for (let r = 0, i = e.length; r < i; r++)if (e[r] !== t.getUint8(n + r, !1)) return !1; return !0 } const n = function (e) { if ("string" == typeof e) { const t = new Uint8Array(e.length); for (let n = 0; n < e.length; n++)t[n] = 255 & e.charCodeAt(n); return t.buffer || t } return e }(e); return function (e) { const n = new DataView(e); if (84 + 50 * n.getUint32(80, !0) === n.byteLength) return !0; const r = [115, 111, 108, 105, 100]; for (let e = 0; e < 5; e++)if (t(r, n, e)) return !1; return !0 }(n) ? function (e) { const t = new DataView(e), n = t.getUint32(80, !0); let r, i, s, a, o, l, c, h, u = !1; for (let e = 0; e < 70; e++)1129270351 == t.getUint32(e, !1) && 82 == t.getUint8(e + 4) && 61 == t.getUint8(e + 5) && (u = !0, a = new Float32Array(3 * n * 3), o = t.getUint8(e + 6) / 255, l = t.getUint8(e + 7) / 255, c = t.getUint8(e + 8) / 255, h = t.getUint8(e + 9) / 255); const d = new Ti, p = new Float32Array(3 * n * 3), m = new Float32Array(3 * n * 3); for (let e = 0; e < n; e++) { const n = 84 + 50 * e, h = t.getFloat32(n, !0), d = t.getFloat32(n + 4, !0), f = t.getFloat32(n + 8, !0); if (u) { const e = t.getUint16(n + 48, !0); 0 == (32768 & e) ? (r = (31 & e) / 31, i = (e >> 5 & 31) / 31, s = (e >> 10 & 31) / 31) : (r = o, i = l, s = c) } for (let o = 1; o <= 3; o++) { const l = n + 12 * o, c = 3 * e * 3 + 3 * (o - 1); p[c] = t.getFloat32(l, !0), p[c + 1] = t.getFloat32(l + 4, !0), p[c + 2] = t.getFloat32(l + 8, !0), m[c] = h, m[c + 1] = d, m[c + 2] = f, u && (a[c] = r, a[c + 1] = i, a[c + 2] = s) } } return d.setAttribute("position", new ri(p, 3)), d.setAttribute("normal", new ri(m, 3)), u && (d.setAttribute("color", new ri(a, 3)), d.hasColors = !0, d.alpha = h), d }(n) : function (e) { const t = new Ti, n = /solid([\s\S]*?)endsolid/g, r = /facet([\s\S]*?)endfacet/g; let i = 0; const s = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source, a = new RegExp("vertex" + s + s + s, "g"), o = new RegExp("normal" + s + s + s, "g"), l = [], c = [], h = new Pn; let u, d = 0, p = 0, m = 0; for (; null !== (u = n.exec(e));) { p = m; const e = u[0]; for (; null !== (u = r.exec(e));) { let e = 0, t = 0; const n = u[0]; for (; null !== (u = o.exec(n));)h.x = parseFloat(u[1]), h.y = parseFloat(u[2]), h.z = parseFloat(u[3]), t++; for (; null !== (u = a.exec(n));)l.push(parseFloat(u[1]), parseFloat(u[2]), parseFloat(u[3])), c.push(h.x, h.y, h.z), e++, m++; 1 !== t && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + i), 3 !== e && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + i), i++ } const n = p, s = m - p; t.addGroup(n, s, d), d++ } return t.setAttribute("position", new di(l, 3)), t.setAttribute("normal", new di(c, 3)), t }("string" != typeof (r = e) ? Hu.decodeText(new Uint8Array(r)) : r); var r } }, e.FBXLoader = class extends cu { constructor(e) { super(e) } load(e, t, n, r) { const i = this, s = "" === i.path ? Hu.extractUrlBase(e) : i.path, a = new uu(this.manager); a.setPath(i.path), a.setResponseType("arraybuffer"), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function (n) { try { t(i.parse(n, s)) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } parse(e, t) { if (function (e) { const t = "Kaydara FBX Binary  \0"; return e.byteLength >= t.length && t === Cp(e, 0, t.length) }(e)) up = (new yp).parse(e); else { const t = Cp(e); if (!function (e) { const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"]; let n = 0; function r(t) { const r = e[t - 1]; return e = e.slice(n + t), n++, r } for (let e = 0; e < t.length; ++e) { const n = r(1); if (n === t[e]) return !1 } return !0 }(t)) throw new Error("THREE.FBXLoader: Unknown format."); if (bp(t) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + bp(t)); up = (new vp).parse(t) } const n = new fu(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin); return new mp(n, this.manager).parse(up) } }, e.OrbitControls = class extends nn { constructor(e, r) { super(), void 0 === r && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), r === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = r, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new Pn, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: t.ROTATE, MIDDLE: t.DOLLY, RIGHT: t.PAN }, this.touches = { ONE: n.ROTATE, TWO: n.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return l.phi }, this.getAzimuthalAngle = function () { return l.theta }, this.getDistance = function () { return this.object.position.distanceTo(this.target) }, this.listenToKeyEvents = function (e) { e.addEventListener("keydown", j), this._domElementKeyEvents = e }, this.saveState = function () { i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom }, this.reset = function () { i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(wn), i.update(), a = s.NONE }, this.update = function () { const t = new Pn, n = (new Cn).setFromUnitVectors(e.up, new Pn(0, 1, 0)), r = n.clone().invert(), p = new Pn, m = new Cn, f = 2 * Math.PI; return function () { const e = i.object.position; t.copy(e).sub(i.target), t.applyQuaternion(n), l.setFromVector3(t), i.autoRotate && a === s.NONE && E(2 * Math.PI / 60 / 60 * i.autoRotateSpeed), i.enableDamping ? (l.theta += c.theta * i.dampingFactor, l.phi += c.phi * i.dampingFactor) : (l.theta += c.theta, l.phi += c.phi); let g = i.minAzimuthAngle, v = i.maxAzimuthAngle; return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += f : g > Math.PI && (g -= f), v < -Math.PI ? v += f : v > Math.PI && (v -= f), l.theta = g <= v ? Math.max(g, Math.min(v, l.theta)) : l.theta > (g + v) / 2 ? Math.max(g, l.theta) : Math.min(v, l.theta)), l.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, l.phi)), l.makeSafe(), l.radius *= h, l.radius = Math.max(i.minDistance, Math.min(i.maxDistance, l.radius)), !0 === i.enableDamping ? i.target.addScaledVector(u, i.dampingFactor) : i.target.add(u), t.setFromSpherical(l), t.applyQuaternion(r), e.copy(i.target).add(t), i.object.lookAt(i.target), !0 === i.enableDamping ? (c.theta *= 1 - i.dampingFactor, c.phi *= 1 - i.dampingFactor, u.multiplyScalar(1 - i.dampingFactor)) : (c.set(0, 0, 0), u.set(0, 0, 0)), h = 1, !!(d || p.distanceToSquared(i.object.position) > o || 8 * (1 - m.dot(i.object.quaternion)) > o) && (i.dispatchEvent(wn), p.copy(i.object.position), m.copy(i.object.quaternion), d = !1, !0) } }(), this.dispose = function () { i.domElement.removeEventListener("contextmenu", X), i.domElement.removeEventListener("pointerdown", z), i.domElement.removeEventListener("pointercancel", V), i.domElement.removeEventListener("wheel", W), i.domElement.removeEventListener("pointermove", G), i.domElement.removeEventListener("pointerup", k), null !== i._domElementKeyEvents && i._domElementKeyEvents.removeEventListener("keydown", j) }; const i = this, s = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let a = s.NONE; const o = 1e-6, l = new Id, c = new Id; let h = 1; const u = new Pn; let d = !1; const p = new gn, m = new gn, f = new gn, g = new gn, v = new gn, y = new gn, x = new gn, _ = new gn, b = new gn, w = [], M = {}; function T() { return Math.pow(.95, i.zoomSpeed) } function E(e) { c.theta -= e } function S(e) { c.phi -= e } const A = function () { const e = new Pn; return function (t, n) { e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), u.add(e) } }(), R = function () { const e = new Pn; return function (t, n) { !0 === i.screenSpacePanning ? e.setFromMatrixColumn(n, 1) : (e.setFromMatrixColumn(n, 0), e.crossVectors(i.object.up, e)), e.multiplyScalar(t), u.add(e) } }(), L = function () { const e = new Pn; return function (t, n) { const r = i.domElement; if (i.object.isPerspectiveCamera) { const s = i.object.position; e.copy(s).sub(i.target); let a = e.length(); a *= Math.tan(i.object.fov / 2 * Math.PI / 180), A(2 * t * a / r.clientHeight, i.object.matrix), R(2 * n * a / r.clientHeight, i.object.matrix) } else i.object.isOrthographicCamera ? (A(t * (i.object.right - i.object.left) / i.object.zoom / r.clientWidth, i.object.matrix), R(n * (i.object.top - i.object.bottom) / i.object.zoom / r.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1) } }(); function C(e) { i.object.isPerspectiveCamera ? h /= e : i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * e)), i.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1) } function P(e) { i.object.isPerspectiveCamera ? h *= e : i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / e)), i.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1) } function I(e) { p.set(e.clientX, e.clientY) } function N(e) { g.set(e.clientX, e.clientY) } function D() { if (1 === w.length) p.set(w[0].pageX, w[0].pageY); else { const e = .5 * (w[0].pageX + w[1].pageX), t = .5 * (w[0].pageY + w[1].pageY); p.set(e, t) } } function F() { if (1 === w.length) g.set(w[0].pageX, w[0].pageY); else { const e = .5 * (w[0].pageX + w[1].pageX), t = .5 * (w[0].pageY + w[1].pageY); g.set(e, t) } } function O() { const e = w[0].pageX - w[1].pageX, t = w[0].pageY - w[1].pageY, n = Math.sqrt(e * e + t * t); x.set(0, n) } function U(e) { if (1 == w.length) m.set(e.pageX, e.pageY); else { const t = Z(e), n = .5 * (e.pageX + t.x), r = .5 * (e.pageY + t.y); m.set(n, r) } f.subVectors(m, p).multiplyScalar(i.rotateSpeed); const t = i.domElement; E(2 * Math.PI * f.x / t.clientHeight), S(2 * Math.PI * f.y / t.clientHeight), p.copy(m) } function B(e) { if (1 === w.length) v.set(e.pageX, e.pageY); else { const t = Z(e), n = .5 * (e.pageX + t.x), r = .5 * (e.pageY + t.y); v.set(n, r) } y.subVectors(v, g).multiplyScalar(i.panSpeed), L(y.x, y.y), g.copy(v) } function H(e) { const t = Z(e), n = e.pageX - t.x, r = e.pageY - t.y, s = Math.sqrt(n * n + r * r); _.set(0, s), b.set(0, Math.pow(_.y / x.y, i.zoomSpeed)), C(b.y), x.copy(_) } function z(e) { !1 !== i.enabled && (0 === w.length && (i.domElement.setPointerCapture(e.pointerId), i.domElement.addEventListener("pointermove", G), i.domElement.addEventListener("pointerup", k)), function (e) { w.push(e) }(e), "touch" === e.pointerType ? function (e) { switch (Y(e), w.length) { case 1: switch (i.touches.ONE) { case n.ROTATE: if (!1 === i.enableRotate) return; D(), a = s.TOUCH_ROTATE; break; case n.PAN: if (!1 === i.enablePan) return; F(), a = s.TOUCH_PAN; break; default: a = s.NONE }break; case 2: switch (i.touches.TWO) { case n.DOLLY_PAN: if (!1 === i.enableZoom && !1 === i.enablePan) return; i.enableZoom && O(), i.enablePan && F(), a = s.TOUCH_DOLLY_PAN; break; case n.DOLLY_ROTATE: if (!1 === i.enableZoom && !1 === i.enableRotate) return; i.enableZoom && O(), i.enableRotate && D(), a = s.TOUCH_DOLLY_ROTATE; break; default: a = s.NONE }break; default: a = s.NONE }a !== s.NONE && i.dispatchEvent(Mn) }(e) : function (e) { let n; switch (e.button) { case 0: n = i.mouseButtons.LEFT; break; case 1: n = i.mouseButtons.MIDDLE; break; case 2: n = i.mouseButtons.RIGHT; break; default: n = -1 }switch (n) { case t.DOLLY: if (!1 === i.enableZoom) return; !function (e) { x.set(e.clientX, e.clientY) }(e), a = s.DOLLY; break; case t.ROTATE: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === i.enablePan) return; N(e), a = s.PAN } else { if (!1 === i.enableRotate) return; I(e), a = s.ROTATE } break; case t.PAN: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === i.enableRotate) return; I(e), a = s.ROTATE } else { if (!1 === i.enablePan) return; N(e), a = s.PAN } break; default: a = s.NONE }a !== s.NONE && i.dispatchEvent(Mn) }(e)) } function G(e) { !1 !== i.enabled && ("touch" === e.pointerType ? function (e) { switch (Y(e), a) { case s.TOUCH_ROTATE: if (!1 === i.enableRotate) return; U(e), i.update(); break; case s.TOUCH_PAN: if (!1 === i.enablePan) return; B(e), i.update(); break; case s.TOUCH_DOLLY_PAN: if (!1 === i.enableZoom && !1 === i.enablePan) return; !function (e) { i.enableZoom && H(e), i.enablePan && B(e) }(e), i.update(); break; case s.TOUCH_DOLLY_ROTATE: if (!1 === i.enableZoom && !1 === i.enableRotate) return; !function (e) { i.enableZoom && H(e), i.enableRotate && U(e) }(e), i.update(); break; default: a = s.NONE } }(e) : function (e) { if (!1 !== i.enabled) switch (a) { case s.ROTATE: if (!1 === i.enableRotate) return; !function (e) { m.set(e.clientX, e.clientY), f.subVectors(m, p).multiplyScalar(i.rotateSpeed); const t = i.domElement; E(2 * Math.PI * f.x / t.clientHeight), S(2 * Math.PI * f.y / t.clientHeight), p.copy(m), i.update() }(e); break; case s.DOLLY: if (!1 === i.enableZoom) return; !function (e) { _.set(e.clientX, e.clientY), b.subVectors(_, x), b.y > 0 ? C(T()) : b.y < 0 && P(T()), x.copy(_), i.update() }(e); break; case s.PAN: if (!1 === i.enablePan) return; !function (e) { v.set(e.clientX, e.clientY), y.subVectors(v, g).multiplyScalar(i.panSpeed), L(y.x, y.y), g.copy(v), i.update() }(e) } }(e)) } function k(e) { !1 !== i.enabled && (e.pointerType, i.dispatchEvent(Tn), a = s.NONE, q(e), 0 === w.length && (i.domElement.releasePointerCapture(e.pointerId), i.domElement.removeEventListener("pointermove", G), i.domElement.removeEventListener("pointerup", k))) } function V(e) { q(e) } function W(e) { !1 === i.enabled || !1 === i.enableZoom || a !== s.NONE && a !== s.ROTATE || (e.preventDefault(), i.dispatchEvent(Mn), function (e) { e.deltaY < 0 ? P(T()) : e.deltaY > 0 && C(T()), i.update() }(e), i.dispatchEvent(Tn)) } function j(e) { !1 !== i.enabled && !1 !== i.enablePan && function (e) { let t = !1; switch (e.code) { case i.keys.UP: L(0, i.keyPanSpeed), t = !0; break; case i.keys.BOTTOM: L(0, -i.keyPanSpeed), t = !0; break; case i.keys.LEFT: L(i.keyPanSpeed, 0), t = !0; break; case i.keys.RIGHT: L(-i.keyPanSpeed, 0), t = !0 }t && (e.preventDefault(), i.update()) }(e) } function X(e) { !1 !== i.enabled && e.preventDefault() } function q(e) { delete M[e.pointerId]; for (let t = 0; t < w.length; t++)if (w[t].pointerId == e.pointerId) return void w.splice(t, 1) } function Y(e) { let t = M[e.pointerId]; void 0 === t && (t = new gn, M[e.pointerId] = t), t.set(e.pageX, e.pageY) } function Z(e) { const t = e.pointerId === w[0].pointerId ? w[1] : w[0]; return M[t.pointerId] } i.domElement.addEventListener("contextmenu", X), i.domElement.addEventListener("pointerdown", z), i.domElement.addEventListener("pointercancel", V), i.domElement.addEventListener("wheel", W, { passive: !1 }), this.update() } }, e.DRACOLoader = class extends cu { constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, n, r) { const i = new uu(this.manager); i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, e => { const n = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(e, n).then(t).catch(r) }, n, r) } decodeDracoFile(e, t, n, r) { const i = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n }; this.decodeGeometry(e, i).then(t) } decodeGeometry(e, t) { for (const e in t.attributeTypes) { const n = t.attributeTypes[e]; void 0 !== n.BYTES_PER_ELEMENT && (t.attributeTypes[e] = n.name) } const n = JSON.stringify(t); if (cp.has(e)) { const t = cp.get(e); if (t.key === n) return t.promise; if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let r; const i = this.workerNextTaskID++, s = e.byteLength, a = this._getWorker(i, s).then(n => (r = n, new Promise((n, s) => { r._callbacks[i] = { resolve: n, reject: s }, r.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]) }))).then(e => this._createGeometry(e.geometry)); return a.catch(() => !0).then(() => { r && i && this._releaseTask(r, i) }), cp.set(e, { key: n, promise: a }), a } _createGeometry(e) { const t = new Ti; e.index && t.setIndex(new ri(e.index.array, 1)); for (let n = 0; n < e.attributes.length; n++) { const r = e.attributes[n], i = r.name, s = r.array, a = r.itemSize; t.setAttribute(i, new ri(s, a)) } return t } _loadLibrary(e, t) { const n = new uu(this.manager); return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((t, r) => { n.load(e, t, void 0, r) }) } preload() { return this._initDecoder(), this } _initDecoder() { if (this.decoderPending) return this.decoderPending; const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(t => { const n = t[0]; e || (this.decoderConfig.wasmBinary = t[1]); const r = function () { let e, t; function n(e, t, n, i) { const s = i.attributeIDs, a = i.attributeTypes; let o, l; const c = t.GetEncodedGeometryType(n); if (c === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeBufferToMesh(n, o); else { if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); o = new e.PointCloud, l = t.DecodeBufferToPointCloud(n, o) } if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg()); const h = { index: null, attributes: [] }; for (const n in s) { const l = self[a[n]]; let c, u; if (i.useUniqueIDs) u = s[n], c = t.GetAttributeByUniqueId(o, u); else { if (-1 === (u = t.GetAttributeId(o, e[s[n]]))) continue; c = t.GetAttribute(o, u) } h.attributes.push(r(e, t, o, n, l, c)) } return c === e.TRIANGULAR_MESH && (h.index = function (e, t, n) { const r = 3 * n.num_faces(), i = 4 * r, s = e._malloc(i); t.GetTrianglesUInt32Array(n, i, s); const a = new Uint32Array(e.HEAPF32.buffer, s, r).slice(); return e._free(s), { array: a, itemSize: 1 } }(e, t, o)), e.destroy(o), h } function r(e, t, n, r, i, s) { const a = s.num_components(), o = n.num_points(), l = o * a, c = l * i.BYTES_PER_ELEMENT, h = function (e, t) { switch (t) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32 } }(e, i), u = e._malloc(c); t.GetAttributeDataArrayForAllPoints(n, s, h, c, u); const d = new i(e.HEAPF32.buffer, u, l).slice(); return e._free(u), { name: r, array: d, itemSize: a } } onmessage = function (r) { const i = r.data; switch (i.type) { case "init": e = i.decoderConfig, t = new Promise(function (t) { e.onModuleLoaded = function (e) { t({ draco: e }) }, DracoDecoderModule(e) }); break; case "decode": const r = i.buffer, s = i.taskConfig; t.then(e => { const t = e.draco, a = new t.Decoder, o = new t.DecoderBuffer; o.Init(new Int8Array(r), r.byteLength); try { const e = n(t, a, o, s), r = e.attributes.map(e => e.array.buffer); e.index && r.push(e.index.array.buffer), self.postMessage({ type: "decode", id: i.id, geometry: e }, r) } catch (e) { console.error(e), self.postMessage({ type: "error", id: i.id, error: e.message }) } finally { t.destroy(o), t.destroy(a) } }) } } }.toString(), i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([i])) }), this.decoderPending } _getWorker(e, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const e = new Worker(this.workerSourceURL); e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({ type: "init", decoderConfig: this.decoderConfig }), e.onmessage = function (t) { const n = t.data; switch (n.type) { case "decode": e._callbacks[n.id].resolve(n); break; case "error": e._callbacks[n.id].reject(n); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"') } }, this.workerPool.push(e) } else this.workerPool.sort(function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 }); const n = this.workerPool[this.workerPool.length - 1]; return n._taskCosts[e] = t, n._taskLoad += t, n }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this } }, e.GLTFLoader = class extends cu { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) { return new Op(e) }), this.register(function (e) { return new kp(e) }), this.register(function (e) { return new Vp(e) }), this.register(function (e) { return new Up(e) }), this.register(function (e) { return new Bp(e) }), this.register(function (e) { return new Hp(e) }), this.register(function (e) { return new zp(e) }), this.register(function (e) { return new Gp(e) }), this.register(function (e) { return new Dp(e) }), this.register(function (e) { return new Wp(e) }) } load(e, t, n, r) { const i = this; let s; s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Hu.extractUrlBase(e), this.manager.itemStart(e); const a = function (t) { r ? r(t) : console.error(t), i.manager.itemError(e), i.manager.itemEnd(e) }, o = new uu(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (n) { try { i.parse(n, s, function (n) { t(n), i.manager.itemEnd(e) }, a) } catch (e) { a(e) } }, n, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, n, r) { let i; const s = {}, a = {}; if ("string" == typeof e) i = e; else if (Hu.decodeText(new Uint8Array(e, 0, 4)) === jp) { try { s[Np.KHR_BINARY_GLTF] = new Yp(e) } catch (e) { return void (r && r(e)) } i = s[Np.KHR_BINARY_GLTF].content } else i = Hu.decodeText(new Uint8Array(e)); const o = JSON.parse(i); if (void 0 === o.asset || o.asset.version[0] < 2) return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const l = new ym(o, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](l); a[t.name] = t, s[t.name] = !0 } if (o.extensionsUsed) for (let e = 0; e < o.extensionsUsed.length; ++e) { const t = o.extensionsUsed[e], n = o.extensionsRequired || []; switch (t) { case Np.KHR_MATERIALS_UNLIT: s[t] = new Fp; break; case Np.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: s[t] = new Qp; break; case Np.KHR_DRACO_MESH_COMPRESSION: s[t] = new Zp(o, this.dracoLoader); break; case Np.KHR_TEXTURE_TRANSFORM: s[t] = new Jp; break; case Np.KHR_MESH_QUANTIZATION: s[t] = new $p; break; default: n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } l.setExtensions(s), l.setPlugins(a), l.parse(n, r) } }, e.ThreeDMLoader = class extends cu { constructor(e) { super(e), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = [] } setLibraryPath(e) { return this.libraryPath = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, n, r) { const i = new uu(this.manager); i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), this.url = e, i.load(e, n => { if (cp.has(n)) return cp.get(n).promise.then(t).catch(r); this.decodeObjects(n, e).then(e => { e.userData.warnings = this.warnings, t(e) }).catch(e => r(e)) }, n, r) } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } decodeObjects(e, t) { let n, r; const i = e.byteLength, s = this._getWorker(i).then(t => (n = t, r = this.workerNextTaskID++, new Promise((t, i) => { n._callbacks[r] = { resolve: t, reject: i }, n.postMessage({ type: "decode", id: r, buffer: e }, [e]) }))).then(e => this._createGeometry(e.data)).catch(e => { throw e }); return s.catch(() => !0).then(() => { n && r && this._releaseTask(n, r) }), cp.set(e, { url: t, promise: s }), s } parse(e, t, n) { this.decodeObjects(e, "").then(e => { e.userData.warnings = this.warnings, t(e) }).catch(e => n(e)) } _compareMaterials(e) { const t = {}; t.name = e.name, t.color = {}, t.color.r = e.color.r, t.color.g = e.color.g, t.color.b = e.color.b, t.type = e.type; for (let e = 0; e < this.materials.length; e++) { const n = this.materials[e], r = {}; if (r.name = n.name, r.color = {}, r.color.r = n.color.r, r.color.g = n.color.g, r.color.b = n.color.b, r.type = n.type, JSON.stringify(t) === JSON.stringify(r)) return n } return this.materials.push(e), e } _createMaterial(e) { if (void 0 === e) return new Oh({ color: new $r(1, 1, 1), metalness: .8, name: "default", side: 2 }); const t = e.diffuseColor, n = new $r(t.r / 255, t.g / 255, t.b / 255); 0 === t.r && 0 === t.g && 0 === t.b && (n.r = 1, n.g = 1, n.b = 1); const r = new Oh({ color: n, name: e.name, side: 2, transparent: e.transparency > 0, opacity: 1 - e.transparency }), i = new fu; for (let t = 0; t < e.textures.length; t++) { const n = e.textures[t]; if (null !== n.image) { const e = i.load(n.image); switch (n.type) { case "Diffuse": r.map = e; break; case "Bump": r.bumpMap = e; break; case "Transparency": r.alphaMap = e, r.transparent = !0; break; case "Emap": r.envMap = e } } } return r } _createGeometry(e) { const t = new Nr, n = [], r = [], i = []; t.userData.layers = e.layers, t.userData.groups = e.groups, t.userData.settings = e.settings, t.userData.objectType = "File3dm", t.userData.materials = null, t.name = this.url; let s = e.objects; const a = e.materials; for (let o = 0; o < s.length; o++) { const l = s[o], c = l.attributes; switch (l.objectType) { case "InstanceDefinition": r.push(l); break; case "InstanceReference": i.push(l); break; default: let s; if (c.materialIndex >= 0) { const e = a[c.materialIndex]; let t = this._createMaterial(e); t = this._compareMaterials(t), s = this._createObject(l, t) } else { const e = this._createMaterial(); s = this._createObject(l, e) } if (void 0 === s) continue; const o = e.layers[c.layerIndex]; s.visible = !o || e.layers[c.layerIndex].visible, c.isInstanceDefinitionObject ? n.push(s) : t.add(s) } } for (let e = 0; e < r.length; e++) { const a = r[e]; s = []; for (let e = 0; e < a.attributes.objectIds.length; e++) { const t = a.attributes.objectIds[e]; for (let e = 0; e < n.length; e++)t === n[e].userData.attributes.id && s.push(n[e]) } for (let e = 0; e < i.length; e++) { const n = i[e]; if (n.geometry.parentIdefId === a.attributes.id) { const e = new Nr, r = n.geometry.xform.array, i = new lr; i.set(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]), e.applyMatrix4(i); for (let t = 0; t < s.length; t++)e.add(s[t].clone(!0)); t.add(e) } } } return t.userData.materials = this.materials, t } _createObject(e, t) { const n = new Gu, r = e.attributes; let i, s, a, o; switch (e.objectType) { case "Point": case "PointSet": (i = n.parse(e.geometry)).attributes.hasOwnProperty("color") ? s = new rc({ vertexColors: !0, sizeAttenuation: !1, size: 2 }) : (a = r.drawColor, o = new $r(a.r / 255, a.g / 255, a.b / 255), s = new rc({ color: o, sizeAttenuation: !1, size: 2 })), s = this._compareMaterials(s); const l = new lc(i, s); return l.userData.attributes = r, l.userData.objectType = e.objectType, r.name && (l.name = r.name), l; case "Mesh": case "Extrusion": case "SubD": case "Brep": if (null === e.geometry) return; (i = n.parse(e.geometry)).attributes.hasOwnProperty("color") && (t.vertexColors = !0), null === t && (t = this._createMaterial(), t = this._compareMaterials(t)); const c = new ki(i, t); return c.castShadow = r.castsShadows, c.receiveShadow = r.receivesShadows, c.userData.attributes = r, c.userData.objectType = e.objectType, r.name && (c.name = r.name), c; case "Curve": i = n.parse(e.geometry), a = r.drawColor, o = new $r(a.r / 255, a.g / 255, a.b / 255), s = new Xl({ color: o }), s = this._compareMaterials(s); const h = new Ql(i, s); return h.userData.attributes = r, h.userData.objectType = e.objectType, r.name && (h.name = r.name), h; case "TextDot": i = e.geometry; const u = document.createElement("canvas").getContext("2d"), d = `${i.fontHeight}px ${i.fontFace}`; u.font = d; const p = u.measureText(i.text).width + 10, m = i.fontHeight + 10, f = window.devicePixelRatio; u.canvas.width = p * f, u.canvas.height = m * f, u.canvas.style.width = p + "px", u.canvas.style.height = m + "px", u.setTransform(f, 0, 0, f, 0, 0), u.font = d, u.textBaseline = "middle", u.textAlign = "center", o = r.drawColor, u.fillStyle = `rgba(${o.r},${o.g},${o.b},${o.a})`, u.fillRect(0, 0, p, m), u.fillStyle = "white", u.fillText(i.text, p / 2, m / 2); const g = new dc(u.canvas); g.minFilter = ue, g.wrapS = ae, g.wrapT = ae, s = new hl({ map: g, depthTest: !1 }); const v = new Tl(s); return v.position.set(i.point[0], i.point[1], i.point[2]), v.scale.set(p / 10, m / 10, 1), v.userData.attributes = r, v.userData.objectType = e.objectType, r.name && (v.name = r.name), v; case "Light": let y; switch ((i = e.geometry).lightStyle.name) { case "LightStyle_WorldPoint": (y = new Pu).castShadow = r.castsShadows, y.position.set(i.location[0], i.location[1], i.location[2]), y.shadow.normalBias = .1; break; case "LightStyle_WorldSpot": (y = new Su).castShadow = r.castsShadows, y.position.set(i.location[0], i.location[1], i.location[2]), y.target.position.set(i.direction[0], i.direction[1], i.direction[2]), y.angle = i.spotAngleRadians, y.shadow.normalBias = .1; break; case "LightStyle_WorldRectangular": y = new Fu; const t = Math.abs(i.width[2]), n = Math.abs(i.length[0]); y.position.set(i.location[0] - n / 2, i.location[1], i.location[2] - t / 2), y.height = n, y.width = t, y.lookAt(new Pn(i.direction[0], i.direction[1], i.direction[2])); break; case "LightStyle_WorldDirectional": (y = new Nu).castShadow = r.castsShadows, y.position.set(i.location[0], i.location[1], i.location[2]), y.target.position.set(i.direction[0], i.direction[1], i.direction[2]), y.shadow.normalBias = .1 }return y && (y.intensity = i.intensity, a = i.diffuse, o = new $r(a.r / 255, a.g / 255, a.b / 255), y.color = o, y.userData.attributes = r, y.userData.objectType = e.objectType), y } } _initLibrary() { if (!this.libraryPending) { const e = new uu(this.manager); e.setPath(this.libraryPath); const t = new Promise((t, n) => { e.load("rhino3dm.js", t, void 0, n) }), n = new uu(this.manager); n.setPath(this.libraryPath), n.setResponseType("arraybuffer"); const r = new Promise((e, t) => { n.load("rhino3dm.wasm", e, void 0, t) }); this.libraryPending = Promise.all([t, r]).then(([e, t]) => { this.libraryConfig.wasmBinary = t; const n = function () { let e, t, n, r; function i(e, t) { const i = e.geometry(), a = e.attributes(); let o, l, c, h, u, d = i.objectType; switch (d) { case n.ObjectType.Curve: const e = function e(t, r) { let i = r, s = []; const a = []; if (t instanceof n.LineCurve) return [t.pointAtStart, t.pointAtEnd]; if (t instanceof n.PolylineCurve) { i = t.pointCount; for (let e = 0; e < i; e++)s.push(t.point(e)); return s } if (t instanceof n.PolyCurve) { const n = t.segmentCount; for (let r = 0; r < n; r++) { const n = t.segmentCurve(r), a = e(n, i); s = s.concat(a), n.delete() } return s } if (t instanceof n.ArcCurve && (i = (i = Math.floor(t.angleDegrees / 5)) < 2 ? 2 : i), t instanceof n.NurbsCurve && 1 === t.degree) { const e = t.tryGetPolyline(); for (let t = 0; t < e.count; t++)s.push(e.get(t)); return e.delete(), s } const o = t.domain, l = i - 1; for (let e = 0; e < i; e++) { const n = o[0] + e / l * (o[1] - o[0]); if (n === o[0] || n === o[1]) { a.push(n); continue } const r = t.tangentAt(n), i = t.tangentAt(a.slice(-1)[0]), s = r[0] * r[0] + r[1] * r[1] + r[2] * r[2], c = i[0] * i[0] + i[1] * i[1] + i[2] * i[2], h = Math.sqrt(s * c); let u; if (0 === h) u = Math.PI / 2; else { const e = (r.x * i.x + r.y * i.y + r.z * i.z) / h; u = Math.acos(Math.max(-1, Math.min(1, e))) } u < .1 || a.push(n) } return s = a.map(e => t.pointAt(e)) }(i, 100); l = {}, h = {}, (c = {}).itemSize = 3, c.type = "Float32Array", c.array = []; for (let t = 0; t < e.length; t++)c.array.push(e[t][0]), c.array.push(e[t][1]), c.array.push(e[t][2]); l.position = c, h.attributes = l, o = { data: h }; break; case n.ObjectType.Point: const p = i.location, m = {}; l = {}, h = {}, (c = {}).itemSize = 3, c.type = "Float32Array", c.array = [p[0], p[1], p[2]]; const f = a.drawColor(t); m.itemSize = 3, m.type = "Float32Array", m.array = [f.r / 255, f.g / 255, f.b / 255], l.position = c, l.color = m, h.attributes = l, o = { data: h }; break; case n.ObjectType.PointSet: case n.ObjectType.Mesh: o = i.toThreejsJSON(); break; case n.ObjectType.Brep: const g = i.faces(); u = new n.Mesh; for (let e = 0; e < g.count; e++) { const t = g.get(e), r = t.getMesh(n.MeshType.Any); r && (u.append(r), r.delete()), t.delete() } u.faces().count > 0 && (u.compact(), o = u.toThreejsJSON(), g.delete()), u.delete(); break; case n.ObjectType.Extrusion: (u = i.getMesh(n.MeshType.Any)) && (o = u.toThreejsJSON(), u.delete()); break; case n.ObjectType.TextDot: o = s(i); break; case n.ObjectType.Light: "LightStyle_WorldLinear" === (o = s(i)).lightStyle.name && self.postMessage({ type: "warning", id: r, data: { message: `THREE.3DMLoader: No conversion exists for ${d.constructor.name} ${o.lightStyle.name}`, type: "no conversion", guid: a.id } }); break; case n.ObjectType.InstanceReference: (o = s(i)).xform = s(i.xform), o.xform.array = i.xform.toFloatArray(!0); break; case n.ObjectType.SubD: i.subdivide(3), (u = n.Mesh.createFromSubDControlNet(i)) && (o = u.toThreejsJSON(), u.delete()); break; default: self.postMessage({ type: "warning", id: r, data: { message: `THREE.3DMLoader: Conversion not implemented for ${d.constructor.name}`, type: "not implemented", guid: a.id } }) }if (o) return (l = s(a)).geometry = s(i), a.groupCount > 0 && (l.groupIds = a.getGroupList()), a.userStringCount > 0 && (l.userStrings = a.getUserStrings()), i.userStringCount > 0 && (l.geometry.userStrings = i.getUserStrings()), l.drawColor = a.drawColor(t), d = (d = d.constructor.name).substring(11, d.length), { geometry: o, attributes: l, objectType: d }; self.postMessage({ type: "warning", id: r, data: { message: `THREE.3DMLoader: ${d.constructor.name} has no associated mesh geometry.`, type: "missing mesh", guid: a.id } }) } function s(e) { const t = {}; for (const n in e) { const r = e[n]; "function" != typeof r && ("object" == typeof r && null !== r && r.hasOwnProperty("constructor") ? t[n] = { name: r.constructor.name, value: r.value } : t[n] = r) } return t } onmessage = function (a) { const o = a.data; switch (o.type) { case "init": const a = (t = o.libraryConfig).wasmBinary; let l; e = new Promise(function (e) { l = { wasmBinary: a, onRuntimeInitialized: e }, rhino3dm(l) }).then(() => { n = l }); break; case "decode": r = o.id; const c = o.buffer; e.then(() => { try { const e = function (e, t) { const n = new Uint8Array(t), a = e.File3dm.fromByteArray(n), o = [], l = [], c = [], h = [], u = [], d = [], p = a.objects(), m = p.count; for (let e = 0; e < m; e++) { const t = p.get(e), n = i(t, a); t.delete(), n && o.push(n) } for (let e = 0; e < a.instanceDefinitions().count(); e++) { const t = a.instanceDefinitions().get(e), n = s(t); n.objectIds = t.getObjectIds(), o.push({ geometry: null, attributes: n, objectType: "InstanceDefinition" }) } const f = [e.TextureType.Diffuse, e.TextureType.Bump, e.TextureType.Transparency, e.TextureType.Opacity, e.TextureType.Emap], g = [e.TextureType.PBR_BaseColor, e.TextureType.PBR_Subsurface, e.TextureType.PBR_SubsurfaceScattering, e.TextureType.PBR_SubsurfaceScatteringRadius, e.TextureType.PBR_Metallic, e.TextureType.PBR_Specular, e.TextureType.PBR_SpecularTint, e.TextureType.PBR_Roughness, e.TextureType.PBR_Anisotropic, e.TextureType.PBR_Anisotropic_Rotation, e.TextureType.PBR_Sheen, e.TextureType.PBR_SheenTint, e.TextureType.PBR_Clearcoat, e.TextureType.PBR_ClearcoatBump, e.TextureType.PBR_ClearcoatRoughness, e.TextureType.PBR_OpacityIor, e.TextureType.PBR_OpacityRoughness, e.TextureType.PBR_Emission, e.TextureType.PBR_AmbientOcclusion, e.TextureType.PBR_Displacement]; for (let e = 0; e < a.materials().count(); e++) { const t = a.materials().get(e), n = t.physicallyBased(); let i = s(t); const o = []; for (let e = 0; e < f.length; e++) { const n = t.getTexture(f[e]); if (n) { let t = f[e].constructor.name; const i = { type: t = t.substring(12, t.length) }, s = a.getEmbeddedFileAsBase64(n.fileName); s ? i.image = "data:image/png;base64," + s : (self.postMessage({ type: "warning", id: r, data: { message: `THREE.3DMLoader: Image for ${t} texture not embedded in file.`, type: "missing resource" } }), i.image = null), o.push(i), n.delete() } } if (i.textures = o, n.supported) { for (let e = 0; e < g.length; e++) { const n = t.getTexture(g[e]); if (n) { const t = a.getEmbeddedFileAsBase64(n.fileName); let r = g[e].constructor.name; const i = { type: r = r.substring(12, r.length), image: "data:image/png;base64," + t }; o.push(i), n.delete() } } const e = s(t.physicallyBased()); i = Object.assign(e, i) } l.push(i), t.delete(), n.delete() } for (let e = 0; e < a.layers().count(); e++) { const t = a.layers().get(e), n = s(t); c.push(n), t.delete() } for (let e = 0; e < a.views().count(); e++) { const t = a.views().get(e), n = s(t); h.push(n), t.delete() } for (let e = 0; e < a.namedViews().count(); e++) { const t = a.namedViews().get(e), n = s(t); u.push(n), t.delete() } for (let e = 0; e < a.groups().count(); e++) { const t = a.groups().get(e), n = s(t); d.push(n), t.delete() } const v = s(a.settings()); return a.delete(), { objects: o, materials: l, layers: c, views: h, namedViews: u, groups: d, settings: v } }(n, c); self.postMessage({ type: "decode", id: o.id, data: e }) } catch (e) { self.postMessage({ type: "error", id: o.id, error: e }) } }) } } }.toString(), r = ["/* rhino3dm.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([r])) }) } return this.libraryPending } _getWorker(e) { return this._initLibrary().then(() => { if (this.workerPool.length < this.workerLimit) { const e = new Worker(this.workerSourceURL); e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({ type: "init", libraryConfig: this.libraryConfig }), e.onmessage = (t => { const n = t.data; switch (n.type) { case "warning": this.warnings.push(n.data), console.warn(n.data); break; case "decode": e._callbacks[n.id].resolve(n); break; case "error": e._callbacks[n.id].reject(n); break; default: console.error('THREE.Rhino3dmLoader: Unexpected message, "' + n.type + '"') } }), this.workerPool.push(e) } else this.workerPool.sort(function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 }); const t = this.workerPool[this.workerPool.length - 1]; return t._taskLoad += e, t }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this } }, Object.defineProperty(e, "__esModule", { value: !0 }) });
